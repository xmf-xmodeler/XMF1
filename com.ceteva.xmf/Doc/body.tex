\NameSpace{Root}{Root}

      The root name space contains all XMF definitions. Adding a named element to 
      this name space makes it globally available. XMF is initialized with a
      number of named elements in this name space. Typically you will add your
      own elements here when developing new name spaces containing your definitions.
      Although named elements are added to a name space using the 'add/1' 
      operation, the preferred (and more declarative) way of adding definitions
      to name spaces (including packages and classes) is to use the 'context'
      construct. Typically the 'context' construct appears at the top level of
      a file or equivalent collection of definitions.
\Package{Root}{Assembler}

      Once compiled, the resulting instructions must be assembled to produce a code box.
      The code box can then be linearized to produce a binary stream that will re-create
      the code box at load time in the machine.
\Class{Root::Assembler}{CodeBox}

         A code box is a modelled eqivalent of the machine data structure

         that contains executable machine instructions. A code box can be

         serialized to a file which will cause the machine data structure to

         be constructed when the file is loaded or can be transformed directly

         into a machine function of 0 arguments.
       
         Constructor: CodeBox(name)
           Constructs a code box with the given name.
\begin{Interface}
@Class CodeBox extends Resource
  @Attribute code : Seq(Element) end
  @Attribute constants : Seq(Element) end
  @Attribute locals : Integer end
  @Attribute name : String end
  @Attribute source : String end
  @Operation addInstr end
  @Operation constOffset end
  @Operation codeBoxes end
  @Operation init end
  @Operation offset end
  @Operation pprint end
  @Operation ppSource end
  @Operation ppConstants end
  @Operation ppCode end
  @Operation resolveLabelsForward end
  @Operation resolveLabelsBackward end
  @Operation resolveLabels end
  @Operation symbolOffset end
  @Operation setResourceName end
  @Operation setCodeBoxNames end
  @Operation toMachineFun end
  @Operation toMachineCodeBox end
  @Operation toMachineCode end
  @Operation toMachineValue end
  @Operation toMachineArray end
  @Operation writeValue end
  @Operation writeSymbol end
  @Operation writeString end
  @Operation writeInteger end
  @Operation writeInstrs end
  @Operation writeFile end
  @Operation writeCode end
  @Operation writeArray end
end
\end{Interface}
\ClassOperation{Root::Assembler::CodeBox}{addInstr}

          Instructions are added to the head of the code stream which

          must be reversed before use.
          Parameter: instr:Instr

            The instruction to add to the code box.
\ClassOperation{Root::Assembler::CodeBox}{constOffset}

          Find the offset in the constants are of the code box for a

          given value. A given value should not occur more than once

          in the constants area of a code box.
\ClassOperation{Root::Assembler::CodeBox}{codeBoxes}

          A code box may contain sub-code-boxes as part of its constants area.
          typically the sub-code-boxes contain instructions for functions that

          are created when the parent is executed. This operation returns all

          the code boxes in a parent.
\ClassOperation{Root::Assembler::CodeBox}{init}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{offset}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{pprint}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{ppSource}

          Code boxes contains source code strings. The string may be empty

          if the compiler has not dumped source code into the code box.
          You can request the compiler save source code which will be used

          in displaying diagnostics.
\ClassOperation{Root::Assembler::CodeBox}{ppConstants}

          The constants of a code box pretty printed to an output channel. 
          Constants live at particular offets in the constants area.
\ClassOperation{Root::Assembler::CodeBox}{ppCode}

          The instructions of a code box written to an output channel.
\ClassOperation{Root::Assembler::CodeBox}{resolveLabelsForward}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{resolveLabelsBackward}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{resolveLabels}

          This operation is called in order to transform symbolic labels

          to relative instruction offsets in SKIP instructions.
\ClassOperation{Root::Assembler::CodeBox}{symbolOffset}

           Symbols are objects are are therefore not = to each other even

           if they have the same name. This operation finds symbols in the

           constants area based on the equality of their names.
           Parameter: symbol:Symbol

             The symbol that is to be added to the constants area of the code

             box.
\ClassOperation{Root::Assembler::CodeBox}{setResourceName}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{setCodeBoxNames}

          Some code boxes are named. For example because they correspond to 
          named class operations. If a code box is not given a name then 
          it it is allocated a unique name here.
\ClassOperation{Root::Assembler::CodeBox}{toMachineFun}

          Translates a code box to a machine function suitable for applying to 
          the appropriate number of arguments. The function can then be called

          or serialized as appropriate. It is assumed that the correct number of

          locals has been set in the code box to support at least the required number

          arguments. 
          Parameter: arity:Integer

            The number of arguments required by the function.
          Parameter: dynamics:Seq(Element)
            The dynamics of the function. The dynamics define the non-local variables

            that can be referenced by the function body. The dynamics are supplied as

            a sequence of pairs of the form: Seq{<INTEGER> | <ELEMENT>}
            where the first element is a type code and the second is a dynamic value.
            If the first element is 1 then the second element should be a pair containing

            a symbol and a value. If the forst element is 2 then the second element should

            be a hashtable that associates symbols (the names) with values.
\ClassOperation{Root::Assembler::CodeBox}{toMachineCodeBox}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{toMachineCode}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{toMachineValue}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{toMachineArray}

          Translates a sequence of values to an array. This is necessary to

          represent code box constants (for example) as a machine data structure.
          Parameter: values:Seq(Element)
            A sequence of values to be translated to an array.
\ClassOperation{Root::Assembler::CodeBox}{writeValue}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{writeSymbol}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{writeString}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{writeInteger}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{writeInstrs}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{writeFile}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{writeCode}
No Documentation Specified
\ClassOperation{Root::Assembler::CodeBox}{writeArray}
No Documentation Specified
\Operation{Root::Assembler}{assemble}

        Produces a code box from a sequence of instructions, the required number of locals
        and the source code represented as a string. The source code is optional and may be
        supplied as the empty string.
\NameSpace{Root}{AllAspects}
No Documentation Specified
\Package{Root}{Aspects}

      This package defines classes that support XMF aspects. An aspect is a collection
      of definitions that are added to model elements. An aspect allows you to group
      structure and behaviour that relate to a collection of (possibly otherwise unrelated)
      classes. An aspect contains a collection of aspect components. Each aspect component
      is a name space and a collection of named elements for that name space. By adding
      an aspect component to an aspect, each component causes the named elements to be added
      to the component name space. For example, consider defining an aspect that allows
      certain types of EMOF element to be translated to HTML. The HTML aspect will contain
      class definitions for just the attributes and operations that need to be added to
      the existing EMOF classes.
\Class{Root::Aspects}{Aspect}

      An aspect contains a collection of definitions that are added to
      existing model elements. The definitions take the form of class
      definitions where the names are paths to existing classes and
      the component definitions are attributes and operations.
     
     Constructor: Aspect(name,components)
     
       Each element of the sequence components is a ComponentDef.
\begin{Interface}
@Class Aspect extends Sugar
  @Attribute components : Seq(ComponentDef) end
  @Attribute name : Name end
  @Operation desugar end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Aspects::Aspect}{desugar}
No Documentation Specified
\ClassOperation{Root::Aspects::Aspect}{pprint}
No Documentation Specified
\ClassOperation{Root::Aspects::Aspect}{toString}
No Documentation Specified
\Class{Root::Aspects}{Class}

       A class component definition in an aspect allows an existing class to
       be exten-ded with new elements such as attributes and operations. The
       name of the class can be a full path to allow the existing class to be
       referenced.
     
       Constructor: Class(path,elements)
\begin{Interface}
@Class Class extends ComponentDef
  @Attribute elements : Seq(Performable) end
  @Attribute path : Path end
  @Operation desugar end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Aspects::Class}{desugar}
No Documentation Specified
\ClassOperation{Root::Aspects::Class}{pprint}
No Documentation Specified
\ClassOperation{Root::Aspects::Class}{toString}
No Documentation Specified
\Class{Root::Aspects}{ComponentDef}

      ComponentDef is the abstract superclass of all aspect component 
      definitions.
\begin{Interface}
@Class ComponentDef isabstract extends Sugar
end
\end{Interface}
\Package{Root::Aspects}{Semantics}
No Documentation Specified
\Class{Root::Aspects::Semantics}{Aspect}
No Documentation Specified
\begin{Interface}
@Class Aspect extends Container,NamedElement
  @Attribute components : Set(Component) end
  @Operation add end
  @Operation toString end
  @Operation test end
end
\end{Interface}
\ClassOperation{Root::Aspects::Semantics::Aspect}{add}
No Documentation Specified
\ClassOperation{Root::Aspects::Semantics::Aspect}{toString}
No Documentation Specified
\ClassOperation{Root::Aspects::Semantics::Aspect}{test}
No Documentation Specified
\Class{Root::Aspects::Semantics}{Component}
No Documentation Specified
\begin{Interface}
@Class Component extends Object
  @Attribute contents : Set(NamedElement) end
  @Attribute nameSpace : NameSpace end
  @Operation add end
  @Operation perform end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Aspects::Semantics::Component}{add}
No Documentation Specified
\ClassOperation{Root::Aspects::Semantics::Component}{perform}
No Documentation Specified
\ClassOperation{Root::Aspects::Semantics::Component}{toString}
No Documentation Specified
\Package{Root}{Associations}

      The associations package defines elements used to represent
      binary associations. Associations between classes are implemented
      as attributes on each class plus a round-trip constraint that
      must hold between instances of the classes.
\Class{Root::Associations}{Association}

      An association is a binary relationship between two classes.
      The association has two ends that correspond to two attributes,
      one for each class. The relationship requires an invariant to 
      hold between the classes. The invariant relates to the properties
      of the round-trip from an instance of each class using the
      attributes.
\begin{Interface}
@Class Association extends NameSpace
  @Attribute end2 : End end
  @Attribute end1 : End end
  @Operation addEnd end
  @Operation add end
  @Operation init end
  @Operation setEnd2 end
  @Operation setEnd1 end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Associations::Association}{addEnd}
No Documentation Specified
\ClassOperation{Root::Associations::Association}{add}
No Documentation Specified
\ClassOperation{Root::Associations::Association}{init}
No Documentation Specified
\ClassOperation{Root::Associations::Association}{setEnd2}
No Documentation Specified
\ClassOperation{Root::Associations::Association}{setEnd1}
No Documentation Specified
\ClassOperation{Root::Associations::Association}{toString}
No Documentation Specified
\Class{Root::Associations}{AssociationDef}

      An association definition that creates an association when
      it is performed.
\begin{Interface}
@Class AssociationDef extends Sugar
  @Attribute end2 : EndDef end
  @Attribute end1 : EndDef end
  @Attribute name : String end
  @Operation compile end
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::Associations::AssociationDef}{compile}

        Types in association en-ds are set to be operations that reference
        the types. Initialization of the ends will call the operation to de-reference
        the type. We increment the name space references to get the right offsets
        at run time.
\ClassOperation{Root::Associations::AssociationDef}{desugar}
No Documentation Specified
\Class{Root::Associations}{End}

      An association en-d is a specialization of Attribute including a
      multiplicity. the multiplicity defines part of an invariant that
      holds between instances of the two en-ds of an association and
      the slot values for the attributes. An en-d is also a constraint
      that is attached to its type. The constraint requires that the
      round trip from an instance of the type using both association ends
      returns to the source of the trip.
\begin{Interface}
@Class End extends Attribute,Constraint
  @Attribute association : Element end
  @Attribute mult : Multiplicity end
  @Operation checkRoundTrip end
  @Operation checkRoundTrip end
  @Operation init end
  @Operation otherEnd end
  @Operation setAssociation end
  @Operation setType end
  @Operation setReason end
  @Operation setBody end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Associations::End}{checkRoundTrip}
No Documentation Specified
\ClassOperation{Root::Associations::End}{checkRoundTrip}

        Starting with object we navigate to the other en-d of the
        association and back again. The round trip should return
        us to the starting point (modulo the multiplicities involved).
\ClassOperation{Root::Associations::End}{init}

        When an en-d is initialised we initialise as for an attribute
        and then add the en-d to the type.
\ClassOperation{Root::Associations::End}{otherEnd}
No Documentation Specified
\ClassOperation{Root::Associations::End}{setAssociation}
No Documentation Specified
\ClassOperation{Root::Associations::End}{setType}
No Documentation Specified
\ClassOperation{Root::Associations::End}{setReason}
No Documentation Specified
\ClassOperation{Root::Associations::End}{setBody}
No Documentation Specified
\ClassOperation{Root::Associations::End}{toString}
No Documentation Specified
\Class{Root::Associations}{EndDef}
No Documentation Specified
\begin{Interface}
@Class EndDef extends Attribute
  @Attribute mult : Multiplicity end
  @Operation initSlotsExp end
  @Operation multExp end
  @Operation metaExp end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Associations::EndDef}{initSlotsExp}
No Documentation Specified
\ClassOperation{Root::Associations::EndDef}{multExp}
No Documentation Specified
\ClassOperation{Root::Associations::EndDef}{metaExp}
No Documentation Specified
\ClassOperation{Root::Associations::EndDef}{toString}
No Documentation Specified
\Class{Root::Associations}{Multiplicity}

      The multiplicity of attribute en-ds is represented as an instance
      of a concrete sub-class of this class. Ends may have multiplicity
      1, 0-1, * or a range n to m. The multiplicity of both en-ds defines 
      the invariant constraint that holds between the classes and the
      attributes corresponding to the en-ds.
\begin{Interface}
@Class Multiplicity isabstract extends Object
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::Associations::Multiplicity}{typeExp}

        Association en-d types are specified without collection constructors.
        This operation wraps a collection type constructor if required.
\Class{Root::Associations}{Opt}

      An en-d with multiplicity 0 .. 1 requires that the attribute
      is associated with 0 or one instance of the appropriate class.
\begin{Interface}
@Class Opt extends Multiplicity
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::Associations::Opt}{typeExp}
No Documentation Specified
\Class{Root::Associations}{One}

      An en-d with multiplicity 1 requires that the attribute
      is associated with exactly one instance of the appropriate 
      class.
\begin{Interface}
@Class One extends Multiplicity
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::Associations::One}{typeExp}
No Documentation Specified
\Class{Root::Associations}{Range}

      An en-d with multiplicity n .. m requires that the attribute
      is associated with a minimum of n and a maximum of m instances 
      of the appropriate class.
\begin{Interface}
@Class Range extends Multiplicity
  @Attribute lower : Integer end
  @Attribute upper : Integer end
  @Operation toString end
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::Associations::Range}{toString}
No Documentation Specified
\ClassOperation{Root::Associations::Range}{typeExp}
No Documentation Specified
\Class{Root::Associations}{Star}

      An en-d with multiplicity * requires that the attribute
      is associated with 0 or more instances of the appropriate 
      class.
\begin{Interface}
@Class Star extends Multiplicity
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::Associations::Star}{typeExp}
No Documentation Specified
\Package{Root}{Clients}

       This package contains definitions relating to XMF clients.
       An XMF client is a (possibly external) program that communicates
       with the XMF engine.
\Class{Root::Clients}{CommandInterpreter}
No Documentation Specified
\begin{Interface}
@Class CommandInterpreter isabstract extends Contained
  @Attribute debug : Boolean end
  @Attribute output : OutputChannel end
  @Operation allocateId end
  @Operation debug end
  @Operation debug end
  @Operation toString end
  @Operation writeCommand end
end
\end{Interface}
\ClassOperation{Root::Clients::CommandInterpreter}{allocateId}
No Documentation Specified
\ClassOperation{Root::Clients::CommandInterpreter}{debug}
No Documentation Specified
\ClassOperation{Root::Clients::CommandInterpreter}{debug}
No Documentation Specified
\ClassOperation{Root::Clients::CommandInterpreter}{toString}
No Documentation Specified
\ClassOperation{Root::Clients::CommandInterpreter}{writeCommand}
No Documentation Specified
\Class{Root::Clients}{ClientManager}
No Documentation Specified
\begin{Interface}
@Class ClientManager extends Object
  @Attribute clients : Set(Client) end
  @Attribute idManager : IdManager end
  @Operation addToClients end
  @Operation allocateId end
  @Operation add end
  @Operation connect end
  @Operation findClient end
  @Operation find end
  @Operation idManager end
end
\end{Interface}
\ClassOperation{Root::Clients::ClientManager}{addToClients}
No Documentation Specified
\ClassOperation{Root::Clients::ClientManager}{allocateId}
No Documentation Specified
\ClassOperation{Root::Clients::ClientManager}{add}
No Documentation Specified
\ClassOperation{Root::Clients::ClientManager}{connect}
No Documentation Specified
\ClassOperation{Root::Clients::ClientManager}{findClient}
No Documentation Specified
\ClassOperation{Root::Clients::ClientManager}{find}
No Documentation Specified
\ClassOperation{Root::Clients::ClientManager}{idManager}
No Documentation Specified
\Class{Root::Clients}{ContainedClientElement}
No Documentation Specified
\begin{Interface}
@Class ContainedClientElement isabstract extends ClientElement,Contained
  @Attribute id : Element end
  @Operation commandInterpreter end
  @Operation id end
  @Operation origin end
  @Operation setId end
end
\end{Interface}
\ClassOperation{Root::Clients::ContainedClientElement}{commandInterpreter}
No Documentation Specified
\ClassOperation{Root::Clients::ContainedClientElement}{id}
No Documentation Specified
\ClassOperation{Root::Clients::ContainedClientElement}{origin}
No Documentation Specified
\ClassOperation{Root::Clients::ContainedClientElement}{setId}
No Documentation Specified
\Class{Root::Clients}{ClientElement}
No Documentation Specified
\begin{Interface}
@Class ClientElement isabstract extends Object
  @Attribute id : Element end
  @Operation id end
  @Operation setId end
end
\end{Interface}
\ClassOperation{Root::Clients::ClientElement}{id}
No Documentation Specified
\ClassOperation{Root::Clients::ClientElement}{setId}
No Documentation Specified
\Class{Root::Clients}{Client}
No Documentation Specified
\begin{Interface}
@Class Client isabstract extends Contained
  @Attribute commandInterpreter : CommandInterpreter end
  @Attribute eventHandler : EventHandler end
  @Operation allocateId end
  @Operation commandInterpreter end
  @Operation debug end
  @Operation eventHandler end
  @Operation find end
  @Operation start end
  @Operation setEventHandler end
  @Operation setCommandInterpreter end
end
\end{Interface}
\ClassOperation{Root::Clients::Client}{allocateId}
No Documentation Specified
\ClassOperation{Root::Clients::Client}{commandInterpreter}
No Documentation Specified
\ClassOperation{Root::Clients::Client}{debug}
No Documentation Specified
\ClassOperation{Root::Clients::Client}{eventHandler}
No Documentation Specified
\ClassOperation{Root::Clients::Client}{find}
No Documentation Specified
\ClassOperation{Root::Clients::Client}{start}
No Documentation Specified
\ClassOperation{Root::Clients::Client}{setEventHandler}
No Documentation Specified
\ClassOperation{Root::Clients::Client}{setCommandInterpreter}
No Documentation Specified
\Class{Root::Clients}{EventHandler}
No Documentation Specified
\begin{Interface}
@Class EventHandler isabstract extends Contained
  @Attribute debug : Boolean end
  @Attribute input : TokenInputChannel end
  @Operation debug end
  @Operation debug end
  @Operation find end
  @Operation start end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Clients::EventHandler}{debug}
No Documentation Specified
\ClassOperation{Root::Clients::EventHandler}{debug}
No Documentation Specified
\ClassOperation{Root::Clients::EventHandler}{find}
No Documentation Specified
\ClassOperation{Root::Clients::EventHandler}{start}
No Documentation Specified
\ClassOperation{Root::Clients::EventHandler}{toString}
No Documentation Specified
\Class{Root::Clients}{ExternalClient}
No Documentation Specified
\begin{Interface}
@Class ExternalClient extends Client
  @Attribute args : Seq(String) end
  @Attribute command : String end
  @Operation connect end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Clients::ExternalClient}{connect}
No Documentation Specified
\ClassOperation{Root::Clients::ExternalClient}{toString}
No Documentation Specified
\Class{Root::Clients}{IdManager}
No Documentation Specified
\begin{Interface}
@Class IdManager extends Object
  @Attribute idTable : Table end
  @Attribute idCounter : Integer end
  @Operation allocateId end
  @Operation find end
  @Operation hasId end
  @Operation newId end
end
\end{Interface}
\ClassOperation{Root::Clients::IdManager}{allocateId}
No Documentation Specified
\ClassOperation{Root::Clients::IdManager}{find}
No Documentation Specified
\ClassOperation{Root::Clients::IdManager}{hasId}
No Documentation Specified
\ClassOperation{Root::Clients::IdManager}{newId}
No Documentation Specified
\Class{Root::Clients}{Point}
No Documentation Specified
\begin{Interface}
@Class Point extends Object
  @Attribute x : Integer end
  @Attribute y : Integer end
  @Operation x end
  @Operation y end
end
\end{Interface}
\ClassOperation{Root::Clients::Point}{x}
No Documentation Specified
\ClassOperation{Root::Clients::Point}{y}
No Documentation Specified
\Package{Root}{Comms}
No Documentation Specified
\Class{Root::Comms}{Client}

       A class that implements a client interface. Use this class to
       connect to a server either in blocking or non-blocking mode.
       By default, a client is blocking.
\begin{Interface}
@Class Client extends Object
  @Attribute block : Boolean end
  @Attribute input : InputChannel end
  @Attribute output : OutputChannel end
  @Operation connect end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Comms::Client}{connect}

        Supply an address string and a port number to attempt to
        connect to the server at the given address and port. If the
        client is blocking then the call will only return when the
        connection is successful; meanwhile other threads are
        given a chance to run. If the client is non blocking then
        it will return immediately with true or false depen-ding on
        whether the connection was successful.
\ClassOperation{Root::Comms::Client}{toString}
No Documentation Specified
\Class{Root::Comms}{Server}

      This class implements a server interface for the host XMF. It 
      provides an operation that listens for clients attempting to
      connect to XMF and sets up the appropriate channels when the 
      connection is established.
\begin{Interface}
@Class Server extends Object
  @Attribute input : InputChannel end
  @Attribute output : OutputChannel end
  @Attribute port : Integer end
  @Attribute server : Element end
  @Operation accept end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Comms::Server}{accept}

        Listen for connections on the port. Blocks until someone
        connects but permits other threads to run simultaneously.
\ClassOperation{Root::Comms::Server}{toString}
No Documentation Specified
\Package{Root}{Compiler}

      The compiler package defines operations and classes that are used for compiling.
      Loading the compiler package also exten-ds the OCL abstract syntax classes with

      operations that support the compilation of OCL. Use the operations defined in

      this package to compile files and compile abstract syntax directly to core.
\Class{Root::Compiler}{CompilationError}

      This class represents a compilation error. By default, compilation
      errors occur silently and and added to a collection of errors
      maintained by the Compiler package.
\begin{Interface}
@Class CompilationError extends Object
  @Attribute exception : Exception end
  @Attribute message : String end
  @Attribute resource : String end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Compiler::CompilationError}{pprint}
No Documentation Specified
\ClassOperation{Root::Compiler::CompilationError}{toString}
No Documentation Specified
\Class{Root::Compiler}{CompilationUnit}

      A compilation unit is produced by the parser when we load a file for

      compiling. Se-nd the compilation unit a 'compile' message to compile

      the contents.
      Constructor: CompilationUnit(imports,exps)
        The imports are those packages that are imported at run-time and 
        are referenced by the program code. The expressions are evaluated 
        in the environment created by the imports.
\begin{Interface}
@Class CompilationUnit extends Object
  @Attribute exps : Seq(Performable) end
  @Attribute imports : Seq(Import) end
  @Operation compileFile end
  @Operation clearInstrs end
  @Operation env end
  @Operation foldImports end
  @Operation foldExps end
  @Operation init end
  @Operation writeInstrs end
end
\end{Interface}
\ClassOperation{Root::Compiler::CompilationUnit}{compileFile}
No Documentation Specified
\ClassOperation{Root::Compiler::CompilationUnit}{clearInstrs}
No Documentation Specified
\ClassOperation{Root::Compiler::CompilationUnit}{env}
No Documentation Specified
\ClassOperation{Root::Compiler::CompilationUnit}{foldImports}
No Documentation Specified
\ClassOperation{Root::Compiler::CompilationUnit}{foldExps}
No Documentation Specified
\ClassOperation{Root::Compiler::CompilationUnit}{init}
No Documentation Specified
\ClassOperation{Root::Compiler::CompilationUnit}{writeInstrs}
No Documentation Specified
\Class{Root::Compiler}{Dynamic}
No Documentation Specified
\begin{Interface}
@Class Dynamic extends Var
  @Operation ref end
end
\end{Interface}
\ClassOperation{Root::Compiler::Dynamic}{ref}
No Documentation Specified
\Class{Root::Compiler}{Env}
No Documentation Specified
\begin{Interface}
@Class Env extends Object
  @Attribute vars : Seq(Var) end
  @Operation allocateLocals end
  @Operation consNameSpaceRef end
  @Operation consLocal end
  @Operation deleteLocals end
  @Operation globalOffset end
  @Operation globalFrame end
  @Operation globals end
  @Operation isLocal end
  @Operation isGlobal end
  @Operation incNameSpaceRefs end
  @Operation init end
  @Operation locals end
  @Operation localIndex end
  @Operation maxLocal end
  @Operation newLocals end
  @Operation newGlobals end
  @Operation newFrame end
  @Operation ref end
  @Operation refs end
  @Operation setVarCode end
  @Operation setLocalCode end
  @Operation setLocalsCode end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Compiler::Env}{allocateLocals}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{consNameSpaceRef}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{consLocal}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{deleteLocals}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{globalOffset}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{globalFrame}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{globals}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{isLocal}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{isGlobal}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{incNameSpaceRefs}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{init}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{locals}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{localIndex}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{maxLocal}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{newLocals}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{newGlobals}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{newFrame}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{ref}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{refs}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{setVarCode}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{setLocalCode}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{setLocalsCode}
No Documentation Specified
\ClassOperation{Root::Compiler::Env}{toString}
No Documentation Specified
\Class{Root::Compiler}{Global}
No Documentation Specified
\begin{Interface}
@Class Global extends Var
  @Attribute frame : Integer end
  @Attribute offset : Integer end
  @Operation ref end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Compiler::Global}{ref}
No Documentation Specified
\ClassOperation{Root::Compiler::Global}{toString}
No Documentation Specified
\Class{Root::Compiler}{Import}
No Documentation Specified
\begin{Interface}
@Class Import extends OCL
  @Attribute nameSpace : Performable end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation init end
  @Operation maxLocals end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Compiler::Import}{FV}
No Documentation Specified
\ClassOperation{Root::Compiler::Import}{compile}
No Documentation Specified
\ClassOperation{Root::Compiler::Import}{desugar}
No Documentation Specified
\ClassOperation{Root::Compiler::Import}{init}
No Documentation Specified
\ClassOperation{Root::Compiler::Import}{maxLocals}
No Documentation Specified
\ClassOperation{Root::Compiler::Import}{pprint}
No Documentation Specified
\Class{Root::Compiler}{Local}
No Documentation Specified
\begin{Interface}
@Class Local extends Var
  @Attribute offset : Integer end
  @Operation ref end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Compiler::Local}{ref}
No Documentation Specified
\ClassOperation{Root::Compiler::Local}{toString}
No Documentation Specified
\Class{Root::Compiler}{NameSpaceRef}
No Documentation Specified
\begin{Interface}
@Class NameSpaceRef extends Var
  @Attribute contour : Integer end
  @Operation init end
  @Operation inc end
  @Operation ref end
end
\end{Interface}
\ClassOperation{Root::Compiler::NameSpaceRef}{init}
No Documentation Specified
\ClassOperation{Root::Compiler::NameSpaceRef}{inc}
No Documentation Specified
\ClassOperation{Root::Compiler::NameSpaceRef}{ref}
No Documentation Specified
\Class{Root::Compiler}{Operations}

      A collection of operations that are defined in the same
      scope and which should be merged into a single operation
      via pattern maching. The order of the operation elements
      is important since they will be each tried in turn when
      pattern matching occurs.
      
      Constructor: Operations(name,ops)
        Ops is a sequence of operations.
\begin{Interface}
@Class Operations extends Object
  @Attribute name : String end
  @Attribute operations : Seq(Operation) end
  @Operation arity end
  @Operation bindVars end
  @Operation compile end
  @Operation desugarBody end
  @Operation matchCode end
end
\end{Interface}
\ClassOperation{Root::Compiler::Operations}{arity}
No Documentation Specified
\ClassOperation{Root::Compiler::Operations}{bindVars}
No Documentation Specified
\ClassOperation{Root::Compiler::Operations}{compile}
No Documentation Specified
\ClassOperation{Root::Compiler::Operations}{desugarBody}
No Documentation Specified
\ClassOperation{Root::Compiler::Operations}{matchCode}
No Documentation Specified
\Class{Root::Compiler}{Symbol}
No Documentation Specified
\begin{Interface}
@Class Symbol extends NamedElement
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::Compiler::Symbol}{init}
No Documentation Specified
\Class{Root::Compiler}{Var}
No Documentation Specified
\begin{Interface}
@Class Var extends NamedElement
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Compiler::Var}{toString}
No Documentation Specified
\Operation{Root::Compiler}{compileToFun}
No Documentation Specified
\Operation{Root::Compiler}{compilationError}
No Documentation Specified
\Operation{Root::Compiler}{compilationErrors}
No Documentation Specified
\Operation{Root::Compiler}{compileExp}
No Documentation Specified
\Operation{Root::Compiler}{compileFile}
No Documentation Specified
\Operation{Root::Compiler}{expandFileName}
No Documentation Specified
\Operation{Root::Compiler}{label}

        Compile the performable object p and label the first instruction

        with a new label. Returns a sequence of machine instructions for p.
\Operation{Root::Compiler}{labelInstrs}

        Set the label of the first instruction.
\Operation{Root::Compiler}{newLabel}

        Allocates a label to be used as the symbolic address of a

        machine instruction.
\Operation{Root::Compiler}{pprintCompilationErrors}
No Documentation Specified
\Operation{Root::Compiler}{resetCompilationErrors}
No Documentation Specified
\Package{Root}{Dialogs}

      The Dialogs package defines a collection of classes that model
      user dialogs (i.e. questions, requests for information etc.)
      in a way that is indepen-dent of the representation used to
      display the dialog.
\Class{Root::Dialogs}{Choose}
No Documentation Specified
\begin{Interface}
@Class Choose extends Sugar
  @Attribute choices : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Choose}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Choose}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Commands}
No Documentation Specified
\begin{Interface}
@Class Commands extends Sugar
  @Attribute commands : Seq(Performable) end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Commands}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Commands}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Display}
No Documentation Specified
\begin{Interface}
@Class Display isabstract extends Object
  @Operation choose end
  @Operation option end
  @Operation reset end
  @Operation show end
  @Operation separator end
  @Operation value end
  @Operation yesOrNo end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Display}{choose}

        Halts current execution until the user chooses an
        option from those currently registered with the display.
        Continues with the chosen dialog.
\ClassOperation{Root::Dialogs::Display}{option}

        Registers an option. The option consists of something to
        display and where to go if the option is chosen. Note that
        the second argument is a 0-arity operation that returns a 
        display.
\ClassOperation{Root::Dialogs::Display}{reset}

        Resets all options.
\ClassOperation{Root::Dialogs::Display}{show}

        Displays a value with an optional label (empty string if ignored).
\ClassOperation{Root::Dialogs::Display}{separator}

        Causes a separator to be displayed in the output.
\ClassOperation{Root::Dialogs::Display}{value}

        Passes a value of the appropriate type to the continuation.
        The type is supplied as a path.
\ClassOperation{Root::Dialogs::Display}{yesOrNo}

        Asks a question and supplies true or false to the continuation.
\Class{Root::Dialogs}{Dialog}

      A dialog defines an interation with the user. Dialog components
      are written in the dialog language defined in the package Dialogs.
\begin{Interface}
@Class Dialog extends Sugar
  @Attribute args : Seq(String) end
  @Attribute body : Performable end
  @Attribute dialogs : Seq(Dialog) end
  @Attribute name : String end
  @Operation desugarOperation end
  @Operation desugarDialogs end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Dialog}{desugarOperation}
No Documentation Specified
\ClassOperation{Root::Dialogs::Dialog}{desugarDialogs}
No Documentation Specified
\ClassOperation{Root::Dialogs::Dialog}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Dialog}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Let}
No Documentation Specified
\begin{Interface}
@Class Let extends Sugar
  @Attribute body : Performable end
  @Attribute name : String end
  @Attribute value : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Let}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Let}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Options}
No Documentation Specified
\begin{Interface}
@Class Options extends Sugar
  @Attribute options : Seq(Option) end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Options}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Options}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Option}
No Documentation Specified
\begin{Interface}
@Class Option extends Sugar
  @Attribute dialog : Performable end
  @Attribute guard : Performable end
  @Attribute message : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Option}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Option}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Quit}
No Documentation Specified
\begin{Interface}
@Class Quit extends Sugar
  @Attribute exp : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Quit}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Quit}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{StandardDialog}
No Documentation Specified
\begin{Interface}
@Class StandardDialog extends Sugar
  @Attribute dialog : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::StandardDialog}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::StandardDialog}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Show}
No Documentation Specified
\begin{Interface}
@Class Show extends Sugar
  @Attribute label : Performable end
  @Attribute value : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Show}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Show}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Separator}
No Documentation Specified
\begin{Interface}
@Class Separator extends Sugar
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Separator}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Separator}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{Skip}
No Documentation Specified
\begin{Interface}
@Class Skip extends Sugar
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Skip}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Skip}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{TextDisplay}

      The TextDisplay class implements the Display operations to produce a command
      line interface for dialogs.
\begin{Interface}
@Class TextDisplay extends Display
  @Attribute dialogs : Seq(Operation) end
  @Attribute input : InputChannel end
  @Attribute messages : Seq(String) end
  @Attribute output : OutputChannel end
  @Operation choose end
  @Operation getOption end
  @Operation option end
  @Operation printOptions end
  @Operation reset end
  @Operation readYesOrNo end
  @Operation readSymbol end
  @Operation readString end
  @Operation readInteger end
  @Operation readElement end
  @Operation readBoolean end
  @Operation show end
  @Operation separator end
  @Operation toString end
  @Operation value end
  @Operation yesOrNo end
end
\end{Interface}
\ClassOperation{Root::Dialogs::TextDisplay}{choose}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{getOption}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{option}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{printOptions}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{reset}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{readYesOrNo}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{readSymbol}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{readString}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{readInteger}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{readElement}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{readBoolean}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{show}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{separator}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{toString}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{value}
No Documentation Specified
\ClassOperation{Root::Dialogs::TextDisplay}{yesOrNo}
No Documentation Specified
\Class{Root::Dialogs}{Value}
No Documentation Specified
\begin{Interface}
@Class Value extends Sugar
  @Attribute label : Performable end
  @Attribute type : Seq(String) end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::Value}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::Value}{pprint}
No Documentation Specified
\Class{Root::Dialogs}{YesOrNo}
No Documentation Specified
\begin{Interface}
@Class YesOrNo extends Sugar
  @Attribute question : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::Dialogs::YesOrNo}{desugar}
No Documentation Specified
\ClassOperation{Root::Dialogs::YesOrNo}{pprint}
No Documentation Specified
\Package{Root}{Env}

    The Env package implements environments. An environment is a
    lookup table associating keys and values. Environment update
    produces a new environment, making them suitable for systems
    that backtrack for example.
\Class{Root::Env}{Binding}

      An internal class to the package Env. Used to represent bindings.
      Always use the 'bind' operation to add bindings to an environment.
\begin{Interface}
@Class Binding extends Env
  @Attribute name : String end
  @Attribute value : Element end
  @Operation binds end
  @Operation binding end
  @Operation dom end
  @Operation lookup end
  @Operation setValue end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Env::Binding}{binds}
No Documentation Specified
\ClassOperation{Root::Env::Binding}{binding}
No Documentation Specified
\ClassOperation{Root::Env::Binding}{dom}
No Documentation Specified
\ClassOperation{Root::Env::Binding}{lookup}
No Documentation Specified
\ClassOperation{Root::Env::Binding}{setValue}
No Documentation Specified
\ClassOperation{Root::Env::Binding}{toString}
No Documentation Specified
\Class{Root::Env}{Env}

      The class Env is abstract and is the superclass of
      all environment implementation classes. Use Env as the 
      type for all environments.
\begin{Interface}
@Class Env isabstract extends Object
  @Operation add end
  @Operation binding end
  @Operation bind end
  @Operation binds end
  @Operation dom end
  @Operation lookup end
  @Operation setValue end
end
\end{Interface}
\ClassOperation{Root::Env::Env}{add}
No Documentation Specified
\ClassOperation{Root::Env::Env}{binding}

        Returns the most recently defined binding for the key or null.
\ClassOperation{Root::Env::Env}{bind}

         Adds an association between the key and the value. Returns
         a new environment which is a copy of the receiver exten-ded with
         the association.
\ClassOperation{Root::Env::Env}{binds}

        Returns true when the key is associated in the 
        environment otherwise returns false.
\ClassOperation{Root::Env::Env}{dom}

        Returns the set of elements bound in the environment.
\ClassOperation{Root::Env::Env}{lookup}
No Documentation Specified
\ClassOperation{Root::Env::Env}{setValue}

        Set will update the current value of a key by side effect.
\Class{Root::Env}{NullEnv}

      Represents the empty environment. Create an instance of this
      class then add associations using 'binds'.
\begin{Interface}
@Class NullEnv extends Env
  @Operation binds end
  @Operation binding end
  @Operation dom end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Env::NullEnv}{binds}
No Documentation Specified
\ClassOperation{Root::Env::NullEnv}{binding}
No Documentation Specified
\ClassOperation{Root::Env::NullEnv}{dom}
No Documentation Specified
\ClassOperation{Root::Env::NullEnv}{toString}
No Documentation Specified
\Class{Root::Env}{Pair}

      Constructs the concatenation of environments e1 and e2.
      Associations in e1 shadow those from e2.
      Used to represent the concatenation of two environments.
\begin{Interface}
@Class Pair extends Env
  @Attribute left : Env end
  @Attribute right : Env end
  @Operation binds end
  @Operation binding end
  @Operation dom end
  @Operation lookup end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Env::Pair}{binds}
No Documentation Specified
\ClassOperation{Root::Env::Pair}{binding}
No Documentation Specified
\ClassOperation{Root::Env::Pair}{dom}
No Documentation Specified
\ClassOperation{Root::Env::Pair}{lookup}
No Documentation Specified
\ClassOperation{Root::Env::Pair}{toString}
No Documentation Specified
\Package{Root}{Exceptions}

      This package defines a collection of exception classes. Instances
      of these classes are created when an exception occurs in XMF code.
      The exception is raised by throwing it to the most recently established
      catch.
\Class{Root::Exceptions}{ArityError}

      This exception is thrown when an operator is
      applied to an incorrect number of arguments.
\begin{Interface}
@Class ArityError extends Exception
  @Attribute args : Seq(Element) end
  @Attribute operator : Operation end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::ArityError}{toString}
No Documentation Specified
\Class{Root::Exceptions}{Error}

      A general error exception. Use this when other exception classes
      are not provided for the specific exception you want to raise.
      Constructor: Error(message)
\begin{Interface}
@Class Error extends Exception
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::Error}{toString}
No Documentation Specified
\Class{Root::Exceptions}{FileNotFound}

      This exception is raised when a file cannot be found.
\begin{Interface}
@Class FileNotFound extends Exception
  @Attribute path : String end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::FileNotFound}{toString}
No Documentation Specified
\Class{Root::Exceptions}{NoSlot}

      This exception is raised when a slot reference is performed on an
      object which does not define a slot of that name.
\begin{Interface}
@Class NoSlot extends Exception
  @Attribute name : String end
  @Attribute object : Object end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::NoSlot}{toString}
No Documentation Specified
\Class{Root::Exceptions}{NameSpaceRef}

      This exception is raisd when a name space does not contain an element with
      a given name.
      Constructor: NameSpaceRef(nameSpace,name)
\begin{Interface}
@Class NameSpaceRef extends Exception
  @Attribute name : String end
  @Attribute nameSpace : NameSpace end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::NameSpaceRef}{toString}
No Documentation Specified
\Class{Root::Exceptions}{PathNotFound}

      This exception is raisd when a path cannot be de-referenced with respect to
      the currently imported name spaces.
      Constructor: PathNotFound(path,imports)
\begin{Interface}
@Class PathNotFound extends Exception
  @Attribute imports : Seq(NameSpace) end
  @Attribute path : Element end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::PathNotFound}{toString}
No Documentation Specified
\Class{Root::Exceptions}{PatternFailed}

      This exception is raised when a pattern fails to bind.
\begin{Interface}
@Class PatternFailed extends Exception
  @Attribute pattern : Pattern end
  @Attribute value : Element end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::PatternFailed}{toString}
No Documentation Specified
\Class{Root::Exceptions}{TypeError}

      This exception is thrown when a value is expected to be of a
      particular type and is not.
      
        Constructor: TypeError(value,type)
\begin{Interface}
@Class TypeError extends Exception
  @Attribute type : Classifier end
  @Attribute value : Element end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::TypeError}{toString}
No Documentation Specified
\Class{Root::Exceptions}{UnboundVar}
No Documentation Specified
\begin{Interface}
@Class UnboundVar extends Exception
  @Attribute name : String end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Exceptions::UnboundVar}{toString}
No Documentation Specified
\Package{Root}{EMOF}
No Documentation Specified
\Class{Root::EMOF}{Attribute}

     An attribute is a structural feature of a class. It defines the
     name and type of a slot of the instances of the class. When the
     class is instantiated, a new object is created and a slot is added 
     for each attribute defined and inherited by the class. Each slot
     is initialised to contain the default value for the type of the
     corresponding attribute.
     Constructor: Attribute(name,type)
     The name is a string and the type is a classifier.
\begin{Interface}
@Class Attribute extends DocumentedElement,StructuralFeature
  @Attribute init : Operation end
  @Operation init end
  @Operation init end
  @Operation toString end
  @Operation underlyingType end
end
\end{Interface}
\ClassOperation{Root::EMOF::Attribute}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Attribute}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Attribute}{toString}
No Documentation Specified
\ClassOperation{Root::EMOF::Attribute}{underlyingType}

      The underlying type of an attribute is the type as
      would appear at the target of a directed association on
      a class diagram. All occurrences of Set(..) and Seq(..) 
      are stripped off.
\Class{Root::EMOF}{Array}
No Documentation Specified
\begin{Interface}
@Class Array extends Class
  @Attribute elementType : Classifier end
  @Operation defaultParents end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::EMOF::Array}{defaultParents}
No Documentation Specified
\ClassOperation{Root::EMOF::Array}{toString}
No Documentation Specified
\Class{Root::EMOF}{BasicArray}
No Documentation Specified
\begin{Interface}
@Class BasicArray extends Object
  @Attribute size : Integer end
  @Attribute storage : Element end
  @Operation addDaemon end
  @Operation daemonNamed end
  @Operation daemonsActive end
  @Operation daemons end
  @Operation elementType end
  @Operation fire end
  @Operation hasDaemonNamed end
  @Operation inRange end
  @Operation init end
  @Operation put end
  @Operation removeDaemonNamed end
  @Operation removeDaemon end
  @Operation ref end
  @Operation rangeError end
  @Operation setDaemons end
  @Operation typeError end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::EMOF::BasicArray}{addDaemon}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{daemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{daemonsActive}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{daemons}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{elementType}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{fire}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{hasDaemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{inRange}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{put}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{removeDaemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{removeDaemon}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{ref}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{rangeError}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{setDaemons}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{typeError}
No Documentation Specified
\ClassOperation{Root::EMOF::BasicArray}{toString}
No Documentation Specified
\DataType{Boolean}

       The data type for boolean values. A boolean value is either
       true or false. The default value is false.
\begin{Interface}
@DataType Boolean extends Element
  @Operation boolor end
  @Operation booland end
  @Operation toString end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Boolean}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Boolean}{booland}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Boolean}{boolor}
No Documentation Specified
\Class{Root::EMOF}{Bind}

      A binding is a named value.
      Constructor: Bind(name,value)
        Constructs a binding, the name is a string and the value is
        any element.
\begin{Interface}
@Class Bind extends NamedElement
  @Attribute value : Element end
  @Operation init end
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::EMOF::Bind}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Bind}{init}
No Documentation Specified
\Class{Root::EMOF}{BehaviouralFeature}

      A behavioural feature is a typed element that can be invoked.
      Typically a behavioural feature is an operation.
\begin{Interface}
@Class BehaviouralFeature isabstract extends DocumentedElement,TypedElement
end
\end{Interface}
\Class{Root::EMOF}{Constraint}

      A constraint is a named boolean expression owned by a classifier. Constraints
      are defined by classifiers to be performed with respect to their instances and
      as such any occurrences of 'self' in a constraint will refer to the instance
      that is being checked.
\begin{Interface}
@Class Constraint extends NamedElement
  @Attribute body : Operation end
  @Attribute reason : Operation end
  @Operation invoke end
end
\end{Interface}
\ClassOperation{Root::EMOF::Constraint}{invoke}
No Documentation Specified
\Class{Root::EMOF}{ConstraintReport}
No Documentation Specified
\begin{Interface}
@Class ConstraintReport extends Object
  @Attribute constraint : Constraint end
  @Attribute candidate : Element end
  @Attribute reason : String end
  @Attribute satisfied : Boolean end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::EMOF::ConstraintReport}{toString}
No Documentation Specified
\Class{Root::EMOF}{Constructor}
No Documentation Specified
\begin{Interface}
@Class Constructor extends DocumentedElement
  @Attribute body : Element end
  @Attribute names : 'Seq'('String') end
  @Operation invoke end
  @Operation init end
  @Operation ref end
  @Operation setOwner end
end
\end{Interface}
\ClassOperation{Root::EMOF::Constructor}{invoke}
No Documentation Specified
\ClassOperation{Root::EMOF::Constructor}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Constructor}{ref}
No Documentation Specified
\ClassOperation{Root::EMOF::Constructor}{setOwner}
No Documentation Specified
\Class{Root::EMOF}{Classifier}

      A classifier is a name space for operations and constraints. A classifier 
      is generalizable and has parents from which it inherits operations and 
      constraints. A classifier can be instantiated via 'new/0' and 'new/1'. In
      both cases the default behaviour is to return a default value as an instance.
      If the classifier is a datatype then the basic value for the datatype is
      returned otherwise 'null' is returned as the default value. A classifier can
      also be applied to arguments (0 or more) in order to instantiate it. Typically
      you will not create a Classifier directly, but create a class or an instance 
      of a sub-class of Class.
\begin{Interface}
@Class Classifier extends NameSpace
  @Attribute constraints : 'Set'('Constraint') end
  @Attribute default : Element end
  @Attribute grammar : Grammar end
  @Attribute operations : 'Set'('Operation') end
  @Attribute parents : 'Set'('Classifier') end
  @Operation addGrammar end
  @Operation add end
  @Operation allParents end
  @Operation allOperations end
  @Operation allConstraints end
  @Operation addParent end
  @Operation addOperation end
  @Operation addConstraint end
  @Operation add end
  @Operation add end
  @Operation addOperation end
  @Operation classify end
  @Operation defaultParents end
  @Operation default end
  @Operation default end
  @Operation grammar end
  @Operation getOperation end
  @Operation getConstraint end
  @Operation getOperation end
  @Operation hasOperation end
  @Operation invoke end
  @Operation initParents end
  @Operation initOperations end
  @Operation init end
  @Operation inheritsFrom end
  @Operation inheritsFrom end
  @Operation new end
  @Operation new end
  @Operation removeParent end
  @Operation removeOperation end
  @Operation removeConstraint end
  @Operation remove end
  @Operation removeOperation end
  @Operation shadowOperation end
  @Operation target end
end
\end{Interface}
\ClassOperation{Root::EMOF::Classifier}{addGrammar}
No Documentation Specified
\Operation{}{add}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{allParents}

      The set of all parents of a  classifier.
\ClassOperation{Root::EMOF::Classifier}{allOperations}

      Get All the operations defined and inherited by the
      receiver. The order of the operations is very important
      because this is the order in which message lookup occurs.
      To calculate allOperations/0 we use an Operator
      Precedence Ordering. This is a depth first left to right
      traversal of the classification type lattice up to a join.
      Stopping at join points means that operations that would
      otherwise appear multiple times in the OPO are promoted to 
      their last occurrence.
\ClassOperation{Root::EMOF::Classifier}{allConstraints}

      Get all the constraints defined and inherited by 
      the receiver.
\ClassOperation{Root::EMOF::Classifier}{addParent}

      Add the parent to the receiver.
      Only make the modification if the parent is
      legal and not already present. Otherwise dont
      change the receiver.
\ClassOperation{Root::EMOF::Classifier}{addOperation}

      Adds an operation to a classifier. Ise 'add/1' in preference
      to this operation.
\ClassOperation{Root::EMOF::Classifier}{addConstraint}

      Adds a constraint to a classifier. Use 'add/1' in preference
      to this operation.
\ClassOperation{Root::EMOF::Classifier}{add}

      Adds a named element to a classifier. If the named element
      is an operation or constraint then it is added to the
      appropriate attributes of the classifier. Sub-classes of
      Classifier can exte-nd this as appropriate but should also call
      thi via 'super'.
\ClassOperation{Root::EMOF::Classifier}{add}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{addOperation}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{classify}

      A classifier classifies its instances by running constraints
      against them. The result of classification is a set of
      constraint reports that describe whether the classification
      succeeded and why the classification fails. To classify a
      candidate supply it to 'classify/1' to produce the set of
      reports.
\ClassOperation{Root::EMOF::Classifier}{defaultParents}

      When creating a classifier it is possible to state the
      default parents so that if no parents are specified when
      creating an instance of the classifier the set returned by
      this operation is used. The default parent for a classifier
      is Element.
\ClassOperation{Root::EMOF::Classifier}{default}

      When a classifier is used as an attribute type the corresponding
      slot values are initialised to the default value returned by
      this operation.
\ClassOperation{Root::EMOF::Classifier}{default}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{grammar}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{getOperation}

      Index an operation by name.
\ClassOperation{Root::EMOF::Classifier}{getConstraint}

       ndex a constraint by name.
\ClassOperation{Root::EMOF::Classifier}{getOperation}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{hasOperation}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{invoke}

      A classifier is invoked to (by default) initialise itself
      with respect to some arguments. This is the preferred way 
      for classifiers to be instantiated.
\ClassOperation{Root::EMOF::Classifier}{initParents}

      Initialise the parents of a classifier. When the compiler encounters
      a package of definitions it turns references into operations that
      return the references when they are called with no arguments. This is
      the mechanism by which mutual recursion is implemented. The dereferencing
      occurs by delaying the mutual recursion in the body of the operations;
      the compiler will have compiled the references in the body of the operation
      as an appropriate lookup in the containing namespace. It is therefore
      important that namespaces such as classifiers and classes, and elements
      that reference things in namespaces such as attributes and operations 
      are initialised. The initialisation is fairly simple since the compiler 
      has done all the work: initialisation just calls the operation which then
      performs the delayed reference.
\ClassOperation{Root::EMOF::Classifier}{initOperations}

     Initialise all the operations.
\ClassOperation{Root::EMOF::Classifier}{init}

      To initialise a classifier, initialise the operations, the parents
      and run super.
\ClassOperation{Root::EMOF::Classifier}{inheritsFrom}

      A classifier inherits from another if they are the same or
      we can ue the 'parents' relation transitively to link the
      two. Supply the super-classifier to this operation which
      will return true when the receiver inherits from the argument.
\ClassOperation{Root::EMOF::Classifier}{inheritsFrom}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{new}

      'new/1' takes a sequence of initialisation arguments.
      It calls 'new/0' to create the new instance and then calls
      'init/1' with the initialisation arguments.
\ClassOperation{Root::EMOF::Classifier}{new}

      'new/0' is defined by classifiers to create  a new instance.
      The default behaviour returns the default value.
\ClassOperation{Root::EMOF::Classifier}{removeParent}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{removeOperation}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{removeConstraint}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{remove}

      'remove/1' removes a named element from a classifier.
      This is the preferred way of removing an element. It causes
      the named element to be removed from the namespace of the element (i.e.
      the contents table) and also removes operations and constraints from
      the appropriate slots. Sub-classes of Classifier should exte-nd this as 
      appropriate, but should call this via 'super'.
\ClassOperation{Root::EMOF::Classifier}{removeOperation}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{shadowOperation}
No Documentation Specified
\ClassOperation{Root::EMOF::Classifier}{target}

      Returns the target to be used when a classifier is
      invoked.
\Class{Root::EMOF}{Class}

      A class is a classifier with structural features (i.e. attributes).
      Instances of classes are always objects with slots for the attributes
      of the class. A class is instantiated using the 'new/0' and 'new/1'
      operations (inherited from Classifier). The former takes no initialization
      arguments whereas the latter takes a sequence of initialization arguments.
      The preferred way of instantiating a class is by applying it as an 
      operator to the initialization arguments, as in C() or C(1,2,3). This
      instantiates the class and calls 'init/1' on the resulting instance.
      Typically classes will redefine 'init/1' to initialize new instances
      on a class-by-class basis. Typically you will create a class using the 
      @Class ... en-d notation.
\begin{Interface}
@Class Class extends Classifier
  @Attribute attributes : 'Set'('Attribute') end
  @Attribute constructors : 'Seq'('Constructor') end
  @Attribute isAbstract : Boolean end
  @Operation allConstructors end
  @Operation allAttributes end
  @Operation addOperation end
  @Operation addConstructor end
  @Operation addAttribute end
  @Operation add end
  @Operation constraintsToLatex end
  @Operation defaultParents end
  @Operation getConstructor end
  @Operation getAttribute end
  @Operation hasAttribute end
  @Operation inspectDialog end
  @Operation interface end
  @Operation init end
  @Operation new end
  @Operation operationsToLatex end
  @Operation removeAttribute end
  @Operation remove end
  @Operation toLatex end
  @Operation toHTMLDoc end
end
\end{Interface}
\ClassOperation{Root::EMOF::Class}{allConstructors}

      Calculate a sequence of constructors in most specific 
      to least specific order.
\ClassOperation{Root::EMOF::Class}{allAttributes}

      Get all the attributes that are defined and inherited by the
      class. Refer to the 'attributes' attribute of a class to
      get the locally defined attributes of a class.
\ClassOperation{Root::EMOF::Class}{addOperation}

       Obsolete.
\ClassOperation{Root::EMOF::Class}{addConstructor}

      Add a constructor to a class. Use Class::add in
      preference to this.
\ClassOperation{Root::EMOF::Class}{addAttribute}

       Adds an attribute to a class and sets the owner
       of the attribute to be the class. Use Class::add
       in preference to this since that will also add
       the attribute to the contents table of the class.
\ClassOperation{Root::EMOF::Class}{add}

      Exte-nd the behaviour for 'add' inherited from
      Classifier by taking attributes and constructors
      into account.
\ClassOperation{Root::EMOF::Class}{constraintsToLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::Class}{defaultParents}

      When a class is created its parents may not be specified
      as part of the definition. The meta-class that is instantiated
      can specify the default super-classes of the new class using
      this operation. It is automatically called when the new
      class is initialised. It is a useful way of stating that all
      classes of a given type must inherit from a collection of
      super-classes. The default is Object.
\ClassOperation{Root::EMOF::Class}{getConstructor}

      Return the most specific constructor with the given arity
      or null if no constructor exists.
\ClassOperation{Root::EMOF::Class}{getAttribute}

      Get an attribute using its name. Be aware that atttibutes, like
      all instances of NamedElement use symbols for names. The name
      argument supplied to 'getAttribute' can be a string or a symbol.
\ClassOperation{Root::EMOF::Class}{hasAttribute}
No Documentation Specified
\ClassOperation{Root::EMOF::Class}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::EMOF::Class}{interface}
No Documentation Specified
\ClassOperation{Root::EMOF::Class}{init}

      Initialise a class by initialising the attributes and then 
      initialising as a classifier.
\ClassOperation{Root::EMOF::Class}{new}

      Create a new instance of a class. Each attribute becomes a slot
      in the new instance and the values of the slots are the default
      values of the corresponding attributes. Once the new object has 
      been created, it is sent an 'init/0' message. Therefore, objects
      are initialised on a type-by-type basis. Note that there are two
      versions of 'new': this one 'new/0' that takes no arguments and
      uses 'init/0' to initialise the object; 'new/1' that takes
      initialisation arguments. In general, avoid using 'new' to
      instantiate classes and apply the class to initialisation arguments
      instead.
\ClassOperation{Root::EMOF::Class}{operationsToLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::Class}{removeAttribute}

      Remove an attribute supplied as an argument. Use 'remove/1'
      in preference to this operation.
\ClassOperation{Root::EMOF::Class}{remove}

      Exte-nd the behaviour inherited from Classifier by
      taking attributes into account. The argument is a named
      element to be removed from the receiver.
\ClassOperation{Root::EMOF::Class}{toLatex}

  
        A class is flattened into a sequence of latex definitions

        for the class interface, the class operations and the class

        constraints. The class interface is complete. The detailed

        descriptions that follow occur only if the definition has a

        documentation string. The argument is an output channel to 
        receive the latex.
\ClassOperation{Root::EMOF::Class}{toHTMLDoc}
No Documentation Specified
\Class{Root::EMOF}{Container}

      A container has a slot 'contents' that is a table. The table maintains the
      contained elements indexed by keys. By default the leys for the elements in
      the table are the elements themselves, but sub-classes of container will
      modify this feature accordingly. Container provides operations for accessing
      and managing its contents.
\begin{Interface}
@Class Container extends Object
  @Attribute contents : Table end
  @Operation allContentsThat end
  @Operation allContentsOf end
  @Operation allContents end
  @Operation add end
  @Operation contentsThat end
  @Operation contentsOf end
  @Operation contents end
  @Operation getChildren end
  @Operation initContents end
  @Operation init end
  @Operation remove end
  @Operation traceAll end
  @Operation untraceAll end
end
\end{Interface}
\ClassOperation{Root::EMOF::Container}{allContentsThat}

      Returns all the contents of the receiver and all the contents of all
      containers that it contains. The elements are filtered using the
      supplied predicate.
\ClassOperation{Root::EMOF::Container}{allContentsOf}

      Returns all the contents of the receiver and all the contents of all
      containers that it contains. The elements are filtered by the classifier
      suppplied as an argument.
\ClassOperation{Root::EMOF::Container}{allContents}

      Returns all the contents of the receiver and all the contents of all
      containers that it contains.
\ClassOperation{Root::EMOF::Container}{add}
No Documentation Specified
\ClassOperation{Root::EMOF::Container}{contentsThat}

      Returns a set of contained elements that satisfy the
      supplied predicate.
\ClassOperation{Root::EMOF::Container}{contentsOf}

      Returns a set of contained elements of the
      supplied type.
\ClassOperation{Root::EMOF::Container}{contents}
No Documentation Specified
\ClassOperation{Root::EMOF::Container}{getChildren}
No Documentation Specified
\ClassOperation{Root::EMOF::Container}{initContents}
No Documentation Specified
\ClassOperation{Root::EMOF::Container}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Container}{remove}
No Documentation Specified
\ClassOperation{Root::EMOF::Container}{traceAll}

      Causes all the operations transitively contained in the
      receiver to be traced.
\ClassOperation{Root::EMOF::Container}{untraceAll}

      Causes all the operations transitively contained in the
      receiver to be untraced.
\Class{Root::EMOF}{Contained}

      A contained element has an owner. The owner is set when the contained element is
      added to a container. Removing an owned element from a container and adding
      it to another container will change the value of 'owner' in the contained element.
\begin{Interface}
@Class Contained isabstract extends Object
  @Attribute owner : Container end
  @Operation owner end
  @Operation removeFromOwner end
  @Operation setOwner end
end
\end{Interface}
\ClassOperation{Root::EMOF::Contained}{owner}
No Documentation Specified
\ClassOperation{Root::EMOF::Contained}{removeFromOwner}
No Documentation Specified
\ClassOperation{Root::EMOF::Contained}{setOwner}
No Documentation Specified
\Class{Root::EMOF}{CompiledOperation}

      CompiledOperation is the type of all XMF compiled operations. A compiled
      operation can be invoked using 'invoke/2' or by applying it to its arguments.
      A compiled operation consists of machine code instructions. A compiled
      operation may be associated with its source code to aid debugging.
\begin{Interface}
@Class CompiledOperation extends Operation
  @Operation addNameChangedDaemon end
  @Operation arity end
  @Operation addDaemon end
  @Operation codeBox end
  @Operation disassemble end
  @Operation disassemble end
  @Operation dynamics end
  @Operation doc end
  @Operation daemons end
  @Operation fire end
  @Operation globals end
  @Operation getStructuralFeatureNames end
  @Operation hasProperty end
  @Operation isVarArgs end
  @Operation name end
  @Operation owner end
  @Operation property end
  @Operation properties end
  @Operation paramNames end
  @Operation removeDaemon end
  @Operation supers end
  @Operation source end
  @Operation setTarget end
  @Operation setSupers end
  @Operation setProperty end
  @Operation setProperties end
  @Operation setOwner end
  @Operation setName end
  @Operation setGlobals end
  @Operation setDynamics end
  @Operation setDoc end
  @Operation setDaemons end
  @Operation setCodeBox end
  @Operation setArity end
  @Operation toLatex end
  @Operation traced end
  @Operation trace end
  @Operation target end
  @Operation untrace end
end
\end{Interface}
\ClassOperation{Root::EMOF::CompiledOperation}{addNameChangedDaemon}

      Use this operation to add a daemon that monitors the name of
      a compiled operation for changes. The args for the daemon are
      the new name and the old name.
\ClassOperation{Root::EMOF::CompiledOperation}{arity}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{addDaemon}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{codeBox}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{disassemble}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{disassemble}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{dynamics}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{doc}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{daemons}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{fire}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{globals}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{getStructuralFeatureNames}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{hasProperty}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{isVarArgs}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{name}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{owner}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{property}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{properties}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{paramNames}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{removeDaemon}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{supers}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{source}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setTarget}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setSupers}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setProperty}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setProperties}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setOwner}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setName}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setGlobals}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setDynamics}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setDoc}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setDaemons}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setCodeBox}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{setArity}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{toLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{traced}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{trace}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{target}
No Documentation Specified
\ClassOperation{Root::EMOF::CompiledOperation}{untrace}
No Documentation Specified
\Class{Root::EMOF}{CodeBox}
No Documentation Specified
\begin{Interface}
@Class CodeBox extends Element
  @Operation constants end
  @Operation codeSize end
  @Operation disassemble end
  @Operation instrAt end
  @Operation locals end
  @Operation name end
  @Operation operandsAt end
  @Operation source end
  @Operation setSource end
  @Operation setInstrAt end
  @Operation setName end
  @Operation setConstants end
end
\end{Interface}
\ClassOperation{Root::EMOF::CodeBox}{constants}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{codeSize}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{disassemble}

      Prints the assembler source code to the supplied output channel.
\ClassOperation{Root::EMOF::CodeBox}{instrAt}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{locals}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{name}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{operandsAt}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{source}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{setSource}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{setInstrAt}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{setName}
No Documentation Specified
\ClassOperation{Root::EMOF::CodeBox}{setConstants}
No Documentation Specified
\Class{Root::EMOF}{DocumentedElement}
No Documentation Specified
\begin{Interface}
@Class DocumentedElement extends Object
  @Attribute documentation : Doc end
  @Operation doc end
  @Operation ensureDoc end
  @Operation setDoc end
end
\end{Interface}
\ClassOperation{Root::EMOF::DocumentedElement}{doc}
No Documentation Specified
\ClassOperation{Root::EMOF::DocumentedElement}{ensureDoc}
No Documentation Specified
\ClassOperation{Root::EMOF::DocumentedElement}{setDoc}
No Documentation Specified
\Class{Root::EMOF}{Doc}
No Documentation Specified
\begin{Interface}
@Class Doc extends Contained
  @Attribute doc : String end
  @Operation addTo end
  @Operation docString end
  @Operation init end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::EMOF::Doc}{addTo}
No Documentation Specified
\ClassOperation{Root::EMOF::Doc}{docString}
No Documentation Specified
\ClassOperation{Root::EMOF::Doc}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Doc}{pprint}

      Pretty prints the documentation to the supplied channel.
      Indentation after newlines are forced to be the supplied
      number of columns.
\Class{Root::EMOF}{DataType}

      DataType is a sub-class of Classifier that designates the non-object
      classifiers that are basic to the XMF system. An instance of DataType is
      a classifier for values (the instances of the data type). For example
      Boolean is an instance of DataType - it classifies the values 'true' and
      'false'. For example Integer is an instance of DataType - it classifies
      the values 1, 2, etc.
\begin{Interface}
@Class DataType isabstract extends Classifier
  @Operation interface end
  @Operation toLatex end
  @Operation toHTML end
  @Operation toHTMLDoc end
end
\end{Interface}
\ClassOperation{Root::EMOF::DataType}{interface}
No Documentation Specified
\ClassOperation{Root::EMOF::DataType}{toLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::DataType}{toHTML}
No Documentation Specified
\ClassOperation{Root::EMOF::DataType}{toHTMLDoc}
No Documentation Specified
\Class{Root::EMOF}{Element}

      Element is the root class of the XMF type hierarchy. It has no super-classes.
      Everything is an instance of Element. Operations defined on Element are
      available to every data value in XMF. Use this as a type when you want to
      use heterogeneous values (for example as the type of an attribute). An element
      always has a classifier which is the value of the 'of/0' message. An element
      can always be sent messages using 'sen-d/2' where the first argument is the
      name of the message and the second argument is a sequence of message arguments.
\begin{Interface}
@Class Element isabstract extends 
  @Operation allHTMLPackages end
  @Operation allHTMLEntries end
  @Operation addTo end
  @Operation copy end
  @Operation die end
  @Operation error end
  @Operation hashCode end
  @Operation inspect end
  @Operation inspectDialog end
  @Operation init end
  @Operation init end
  @Operation isKindOf end
  @Operation init end
  @Operation labelString end
  @Operation of end
  @Operation println end
  @Operation print end
  @Operation setOf end
  @Operation send end
  @Operation save2 end
  @Operation save end
  @Operation toLatex end
  @Operation toHTML end
  @Operation toString end
  @Operation writeHTML end
  @Operation writeHTML end
  @Operation writeHTMLAllEntries end
  @Operation writeHTMLAllPackages end
  @Operation writeHTMLIndex end
  @Operation writeHTMLOverview end
  @Operation yield end
end
\end{Interface}
\ClassOperation{Root::EMOF::Element}{allHTMLPackages}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{allHTMLEntries}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{addTo}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{copy}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{die}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{error}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{hashCode}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{inspect}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{isKindOf}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{labelString}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{of}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{println}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{print}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{setOf}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{send}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{save2}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{save}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{toLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{toHTML}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{toString}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{writeHTML}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{writeHTML}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{writeHTMLAllEntries}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{writeHTMLAllPackages}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{writeHTMLIndex}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{writeHTMLOverview}
No Documentation Specified
\ClassOperation{Root::EMOF::Element}{yield}
No Documentation Specified
\Class{Root::EMOF}{Enum}
No Documentation Specified
\begin{Interface}
@Class Enum extends DataType
  @Attribute values : Seq(String) end
end
\end{Interface}
\Class{Root::EMOF}{Exception}

      An exception is raised when something goes wrong. An exception contains a
      message that reports what went wrong. An exception also contains a sequence
      of stack frames that defines the history of computation at the point the
      exception was raised. An exception may optionally contain information 
      about where in the source file the error occurred. This is encoded as the
      lineCount and charCount.
\begin{Interface}
@Class Exception extends Object
  @Attribute backtrace : 'Seq'('Element') end
  @Attribute charCount : Integer end
  @Attribute lineCount : Integer end
  @Attribute message : String end
  @Attribute resourceName : String end
  @Operation printFrame end
  @Operation printBacktrace end
  @Operation setBacktrace end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::EMOF::Exception}{printFrame}
No Documentation Specified
\ClassOperation{Root::EMOF::Exception}{printBacktrace}
No Documentation Specified
\ClassOperation{Root::EMOF::Exception}{setBacktrace}
No Documentation Specified
\ClassOperation{Root::EMOF::Exception}{toString}
No Documentation Specified
\Class{Root::EMOF}{ForeignOperation}
No Documentation Specified
\begin{Interface}
@Class ForeignOperation extends Operation
  @Operation getStructuralFeatureNames end
  @Operation isVarArgs end
  @Operation invoke end
  @Operation name end
  @Operation owner end
  @Operation setTarget end
  @Operation toLatex end
  @Operation target end
end
\end{Interface}
\ClassOperation{Root::EMOF::ForeignOperation}{getStructuralFeatureNames}
No Documentation Specified
\ClassOperation{Root::EMOF::ForeignOperation}{isVarArgs}
No Documentation Specified
\ClassOperation{Root::EMOF::ForeignOperation}{invoke}
No Documentation Specified
\ClassOperation{Root::EMOF::ForeignOperation}{name}
No Documentation Specified
\ClassOperation{Root::EMOF::ForeignOperation}{owner}
No Documentation Specified
\ClassOperation{Root::EMOF::ForeignOperation}{setTarget}
No Documentation Specified
\ClassOperation{Root::EMOF::ForeignOperation}{toLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::ForeignOperation}{target}
No Documentation Specified
\DataType{Float}
No Documentation Specified
\begin{Interface}
@DataType Float extends Element
  @Operation add end
  @Operation abs end
  @Operation cos end
  @Operation div end
  @Operation floor end
  @Operation greater end
  @Operation init end
  @Operation less end
  @Operation mul end
  @Operation mod end
  @Operation min end
  @Operation max end
  @Operation round end
  @Operation sub end
  @Operation sqrt end
  @Operation slash end
  @Operation sin end
  @Operation toString end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Float}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{abs}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{sub}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{add}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{sqrt}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{cos}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{slash}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{div}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{sin}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{floor}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{round}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{greater}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{mul}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{init}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{mod}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{less}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{min}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Float}{max}
No Documentation Specified
\Class{Root::EMOF}{InterpretedOperation}

      An interpreted operation is created when we evaluate an operation definition.
\begin{Interface}
@Class InterpretedOperation extends Operation
  @Attribute body : Performable end
  @Attribute env : Seq(Element) end
  @Attribute imports : Seq(NameSpace) end
  @Attribute isVarArgs : Boolean end
  @Attribute parameters : Seq(Pattern) end
  @Attribute target : Element end
  @Operation arity end
  @Operation bindParams end
  @Operation invoke end
  @Operation name end
  @Operation setSupers end
  @Operation target end
end
\end{Interface}
\ClassOperation{Root::EMOF::InterpretedOperation}{arity}
No Documentation Specified
\ClassOperation{Root::EMOF::InterpretedOperation}{bindParams}
No Documentation Specified
\ClassOperation{Root::EMOF::InterpretedOperation}{invoke}
No Documentation Specified
\ClassOperation{Root::EMOF::InterpretedOperation}{name}
No Documentation Specified
\ClassOperation{Root::EMOF::InterpretedOperation}{setSupers}
No Documentation Specified
\ClassOperation{Root::EMOF::InterpretedOperation}{target}
No Documentation Specified
\Class{Root::EMOF}{InitialisedAttribute}
No Documentation Specified
\begin{Interface}
@Class InitialisedAttribute extends Attribute
  @Attribute value : Performable end
end
\end{Interface}
\DataType{Integer}

      The data type for integer values The default value is 0.
\begin{Interface}
@DataType Integer extends Element
  @Operation add end
  @Operation abs end
  @Operation byte end
  @Operation div end
  @Operation floor end
  @Operation greater end
  @Operation isWhiteSpaceChar end
  @Operation isUpperCaseChar end
  @Operation isNumericChar end
  @Operation isNewLineChar end
  @Operation isLowerCaseChar end
  @Operation lsh end
  @Operation less end
  @Operation mul end
  @Operation mod end
  @Operation min end
  @Operation max end
  @Operation rsh end
  @Operation round end
  @Operation sub end
  @Operation sqrt end
  @Operation slash end
  @Operation toString end
  @Operation to end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Integer}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{to}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{sub}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{abs}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{sqrt}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{add}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{slash}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{byte}

      Returns the byte of the receiver indexed by the

      the argument. Bytes are indexed from 1 (low) to

      4 (high).
\DataTypeOperation{Root::EMOF::Integer}{rsh}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{div}

      Integer division returns the number of times the receiver

      can be divided by the integer argument a whole number of

      times.
\DataTypeOperation{Root::EMOF::Integer}{round}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{greater}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{mul}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{floor}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{mod}

      Returns the remainder when the receiver is divided by the

      single integer argument.
\DataTypeOperation{Root::EMOF::Integer}{isLowerCaseChar}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{min}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{isNewLineChar}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{max}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{isNumericChar}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{lsh}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{isUpperCaseChar}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{less}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Integer}{isWhiteSpaceChar}
No Documentation Specified
\Class{Root::EMOF}{LazySeq}
No Documentation Specified
\begin{Interface}
@Class LazySeq extends Object
  @Attribute head : Element end
  @Attribute tail : Element end
  @Operation expand end
  @Operation head end
  @Operation isExpanded end
  @Operation isEmpty end
  @Operation init end
  @Operation tail end
end
\end{Interface}
\ClassOperation{Root::EMOF::LazySeq}{expand}
No Documentation Specified
\ClassOperation{Root::EMOF::LazySeq}{head}
No Documentation Specified
\ClassOperation{Root::EMOF::LazySeq}{isExpanded}
No Documentation Specified
\ClassOperation{Root::EMOF::LazySeq}{isEmpty}
No Documentation Specified
\ClassOperation{Root::EMOF::LazySeq}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::LazySeq}{tail}
No Documentation Specified
\Class{Root::EMOF}{MachineException}
No Documentation Specified
\begin{Interface}
@Class MachineException extends Exception
  @Attribute id : Integer end
end
\end{Interface}
\DataType{Null}

       Null is the data type for the special value 'null'. The special value
       'null' is an instance of all classifiers. It is the default value for all
       instances of Class.
\begin{Interface}
@DataType Null extends Element
  @Operation toString end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Null}{toString}
No Documentation Specified
\Class{Root::EMOF}{NamedElement}

      A named element is an owned element with a name. The name may be a 
      string or a symbol. typically we use symbols where the lookup of the name
      needs to be efficient.
\begin{Interface}
@Class NamedElement isabstract extends Contained
  @Attribute name : String end
  @Operation getNamedElement end
  @Operation href end
  @Operation labelString end
  @Operation name end
  @Operation pathSeq end
  @Operation path end
  @Operation setName end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::EMOF::NamedElement}{getNamedElement}
No Documentation Specified
\ClassOperation{Root::EMOF::NamedElement}{href}

        Returns the path used in an href to the receiver. It assumes
        that we are relative to a root that contains the root name space.
\ClassOperation{Root::EMOF::NamedElement}{labelString}
No Documentation Specified
\ClassOperation{Root::EMOF::NamedElement}{name}
No Documentation Specified
\ClassOperation{Root::EMOF::NamedElement}{pathSeq}
No Documentation Specified
\ClassOperation{Root::EMOF::NamedElement}{path}
No Documentation Specified
\ClassOperation{Root::EMOF::NamedElement}{setName}
No Documentation Specified
\ClassOperation{Root::EMOF::NamedElement}{toString}
No Documentation Specified
\Class{Root::EMOF}{NameSpace}

      A name space is a container of named elenents. A name space defines two
      operations 'getElement/1' and 'hasElement/1' that are used to get an element
      by name and check for an element by name. Typically a name space will contain
      different categories of elements in which case the name space will place
      the contained elements in its contents table and in a type specific collection.
      For example, a class is a container for operations, attributes and constraints.
      Each of these elements are placed in the contents table for the class and in
      a slot containing a collection with the names 'operations', 'attributes';
      and 'constraints' respectively. The special syntax '::' is used to invoke the
      'getElement/1' operation on a name space.
\begin{Interface}
@Class NameSpace extends NamedElement,DocumentedElement,Container
  @Attribute bindings : 'Set'('Bind') end
  @Attribute imports : 'Seq'('NameSpace') end
  @Operation allHTMLPackages end
  @Operation allHTMLEntries end
  @Operation addBinding end
  @Operation add end
  @Operation add end
  @Operation getContents end
  @Operation getElement end
  @Operation hasElement end
  @Operation inspectDialog end
  @Operation initBindings end
  @Operation init end
  @Operation init end
  @Operation names end
  @Operation nameChanged end
  @Operation putElement end
  @Operation remove end
  @Operation toLatex end
  @Operation toHTML end
  @Operation toHTMLDoc end
end
\end{Interface}
\ClassOperation{Root::EMOF::NameSpace}{allHTMLPackages}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{allHTMLEntries}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{addBinding}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{add}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{add}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{getContents}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{getElement}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{hasElement}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{initBindings}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{names}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{nameChanged}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{putElement}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{remove}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{toLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{toHTML}
No Documentation Specified
\ClassOperation{Root::EMOF::NameSpace}{toHTMLDoc}
No Documentation Specified
\Class{Root::EMOF}{Object}

      Object is the super-class of all classes with structural features oin XMF.
      Object provides access to slots via the 'get/1' and 'set/2' operations.
      Object is the default super-class for a class definition - if you do not specify
      a super-class then Object is assumed.
\begin{Interface}
@Class Object extends Element
  @Operation addStructuralFeature end
  @Operation addDaemon end
  @Operation daemonNamed end
  @Operation daemons end
  @Operation edit end
  @Operation fire end
  @Operation getChildren end
  @Operation getIcon end
  @Operation get end
  @Operation getStructuralFeatureNames end
  @Operation hasSlot end
  @Operation hasStructuralFeature end
  @Operation hasDaemonNamed end
  @Operation inspectDialog end
  @Operation initSlots end
  @Operation init end
  @Operation machineInit end
  @Operation removeDaemonNamed end
  @Operation removeDaemon end
  @Operation setDaemons end
  @Operation set end
end
\end{Interface}
\ClassOperation{Root::EMOF::Object}{addStructuralFeature}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{addDaemon}

      All objects have a collection of daemons. A daemon is an operation that is
      invoked whenever a slot of the object is updated. The operation is any
      invokable value (either an operation or an object that implements the
      'invoke/2' operation. The invocation occurs after the slot has been
      updated and is supplied with 3 values as the second argument: the slot
      (symbol) that has been updated, the new value and the old value.
\ClassOperation{Root::EMOF::Object}{daemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{daemons}

      Returns the currently defined daemons for the receiver.
      Daemons are fired when the object changes state and when
      the objects daemons are active.
\ClassOperation{Root::EMOF::Object}{edit}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{fire}

      When the slot of an object is updated, its daemons are fired by calling
      this operation. The operation is supplied with 3 arguments: the name of
      the slot that was changed (a symbol), the new value of the slot and the
      old value of the slot.
\ClassOperation{Root::EMOF::Object}{getChildren}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{getIcon}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{get}

      Returns the value of the named slot of the receiver.
      The name may be a string or a symbol. An exception is
      raised if the receiver has no slot with the given name.
\ClassOperation{Root::EMOF::Object}{getStructuralFeatureNames}

      Returns the slot names of the object.
\ClassOperation{Root::EMOF::Object}{hasSlot}

      Returns true when the receiver has a slot with the given
      name. The name may be a string or a symbol.
\ClassOperation{Root::EMOF::Object}{hasStructuralFeature}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{hasDaemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{initSlots}

      Attributes have a slot 'init' that contains an operation or null.
      If the value is an operation then invoking the operation with an
      object as the target will return an initial value for that slot
      of the object.
\ClassOperation{Root::EMOF::Object}{init}

      When an object is initialised, by default we look for a constructor
      that has the same arity as the supplied arguments. If we find one
      then it is invoked. Note that we always invoke the 'init/0' operation
      after slot initialisation.
\ClassOperation{Root::EMOF::Object}{machineInit}

      Called when the machine has detected initialization values defined
      for one or more attributes. The machine relies on this operation to
      perform the slot initialization and then call the init/1 operation.
\ClassOperation{Root::EMOF::Object}{removeDaemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{removeDaemon}

      Removes the supplied daemon.
\ClassOperation{Root::EMOF::Object}{setDaemons}
No Documentation Specified
\ClassOperation{Root::EMOF::Object}{set}

      Sets the named slot to the supplied value in the receiver.
      Raises an exception if the receiver has no slot with the
      supplied name. The name may be a symbol or a string.
\Class{Root::EMOF}{Operation}

      Operation is the abstract super-class of all operations in XMF. An operation
      can be compiled or interpreted. All operations have parameters, a return type
      and a body. The body must be performable. An operation is invoked using 
      'invoke/2' where the forst argument is the value of 'self' in the operation 
      body and the secon dargument is a sequence of parameter vaolues.
\begin{Interface}
@Class Operation extends BehaviouralFeature
  @Operation arity end
  @Operation dynamics end
  @Operation fork end
  @Operation globals end
  @Operation inspect end
  @Operation inspectDialog end
  @Operation invoke end
  @Operation name end
  @Operation paramNames end
  @Operation supers end
  @Operation source end
  @Operation setTarget end
  @Operation setSupers end
  @Operation setName end
  @Operation setGlobals end
  @Operation setDynamics end
  @Operation toLatex end
  @Operation traceFun end
  @Operation traced end
  @Operation trace end
  @Operation target end
  @Operation untrace end
end
\end{Interface}
\ClassOperation{Root::EMOF::Operation}{arity}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{dynamics}

      The dynamics of an operation are the imported name spaces.
\ClassOperation{Root::EMOF::Operation}{fork}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{globals}

      The environment of freely referenced variables in the body

      of the operation.
\ClassOperation{Root::EMOF::Operation}{inspect}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{invoke}

      An operation is performed by invoking it. The arguments are

      given as the target (the value of self) and the sequence of

      arguments required by the operation. Deal with var args here

      by turning any extra arguments into a single argument that is

      a sequence.
\ClassOperation{Root::EMOF::Operation}{name}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{paramNames}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{supers}

      The supers of an operation define where the search continues

      when the body performs performs 'super'
\ClassOperation{Root::EMOF::Operation}{source}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{setTarget}

      Set the value that will be used as 'self' in the evaluation

      of the body of the operation.
\ClassOperation{Root::EMOF::Operation}{setSupers}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{setName}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{setGlobals}

      Set the environment of freely reference variables.
\ClassOperation{Root::EMOF::Operation}{setDynamics}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{toLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::Operation}{traceFun}

      This operation returns a function that can be invoked to

      trace the operation fun.
\ClassOperation{Root::EMOF::Operation}{traced}

      Returns true when the received is traced.
\ClassOperation{Root::EMOF::Operation}{trace}

      Call this operation to trace an operation. When

      the operation is called it will print out on

      entry and exit.
\ClassOperation{Root::EMOF::Operation}{target}

      Returns the value of 'self' that was current when the operation

      was created (unless the operation has been modified since).
\ClassOperation{Root::EMOF::Operation}{untrace}

      Call this operation to untrace an operation.
\Class{Root::EMOF}{Performable}

     A performable element can be executed on the XMF VM. It must provide a
     collection of operations that support its evaluation or its translation
     into VM machine instructions. In particular it must support 'compile/4',
     'FV/0', 'maxLocals/0' and 'eval/3'. Performable is the root class for
     all extensions to executable XMF. For example OCL is a sub-class of
     Performable. If you inte-nd to define your own languages in XMF then
     they should exte-nd Performable.
\begin{Interface}
@Class Performable isabstract extends Object
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation pprint end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::EMOF::Performable}{FV}

      All performable things contain variables. If the variables are not

      bound then they are free. This returns the set of free variables

      in a performable thing.
\ClassOperation{Root::EMOF::Performable}{compile}

      Every performable thing must be able to be compiled.
      The arguments are as follows: env contains information about the context;
      frame defines how statically nested inside binding contours we are;
      isLast is a boolean determining whether we are the last performable thing;
      saveSource controls whether or not source is dumped to the output.
\ClassOperation{Root::EMOF::Performable}{eval}

      Every performable thing can be evaluated (as opposed to compiled and 
      then performed).Evaluation occurs in a context that includes the value

      of 'self' (i.e. the target of the evaluating message), an

      environment of local variables and a sequence of imported name spaces.
\ClassOperation{Root::EMOF::Performable}{lift}

      Any performable thing can be turned into a performable thing

      that recreates it.
\ClassOperation{Root::EMOF::Performable}{maxLocals}

      Any performable thing requires some local storage. This will

      occur in the machine stack frame. It is possible to statically 
      determine how much storage is required and this operation returns

      the amount of storage needed.
\ClassOperation{Root::EMOF::Performable}{pprint}

      Pretty prints the receiver to a string.
\ClassOperation{Root::EMOF::Performable}{pprint}

      Pretty prints the receiver to a string.
\ClassOperation{Root::EMOF::Performable}{pprint}

      Any performable thing can be turned into code. The default

      behaviour is to produce a comment. All performable subclasses

      should redefined this operation as appropriate.
\Class{Root::EMOF}{Parameter}

      A parameter is a typed element that occurs in operations.
\begin{Interface}
@Class Parameter extends TypedElement
  @Operation init end
  @Operation lift end
end
\end{Interface}
\ClassOperation{Root::EMOF::Parameter}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Parameter}{lift}
No Documentation Specified
\Class{Root::EMOF}{Package}

     A package is a classifier that has instances. Currently we dont support
     instantiating packages therefore you should view a package as a name space.
\begin{Interface}
@Class Package extends Resource,Classifier
  @Attribute classes : 'Set'('Class') end
  @Attribute metaPackage : Package end
  @Attribute packages : 'Set'('Package') end
  @Operation addPackage end
  @Operation addClass end
  @Operation add end
  @Operation contentsToLatex end
  @Operation defaultParents end
  @Operation inspectDialog end
  @Operation init end
  @Operation removePackage end
  @Operation removeClass end
  @Operation remove end
  @Operation showDiagram end
  @Operation toLatex end
  @Operation toHTMLDoc end
end
\end{Interface}
\ClassOperation{Root::EMOF::Package}{addPackage}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{addClass}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{add}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{contentsToLatex}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{defaultParents}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{removePackage}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{removeClass}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{remove}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{showDiagram}
No Documentation Specified
\ClassOperation{Root::EMOF::Package}{toLatex}

    
        A package is flattened into a sequence of latex definitions

        A simple package definition and a sequence of content 
        definitions. The argument is an output channel to receive

        the latex.
\ClassOperation{Root::EMOF::Package}{toHTMLDoc}
No Documentation Specified
\Class{Root::EMOF}{Resource}

      A resource records where the resource originated via a resource name.
      For example a definition is a resource that records the file where it
      was loaded from.
\begin{Interface}
@Class Resource isabstract extends Object
  @Attribute resourceName : String end
end
\end{Interface}
\DataType{Seq(Element)}

      An instance of Seq where the element type is Element. This is the super-type
      of all sequence data types.
\begin{Interface}
@DataType Seq(Element) extends Element
  @Operation at end
  @Operation asString end
  @Operation asSeq end
  @Operation asSet end
  @Operation append end
  @Operation butLast end
  @Operation binds end
  @Operation bind end
  @Operation contains end
  @Operation collect end
  @Operation drop end
  @Operation dot end
  @Operation default end
  @Operation drop end
  @Operation exists end
  @Operation excluding end
  @Operation forAll end
  @Operation flatten end
  @Operation headTailDialog end
  @Operation head end
  @Operation hasSuffix end
  @Operation hasPrefix end
  @Operation inspectDialog end
  @Operation iter end
  @Operation isProperSequence end
  @Operation isEmpty end
  @Operation includes end
  @Operation isKindOf end
  @Operation insertAt end
  @Operation indexOf end
  @Operation including end
  @Operation lookup end
  @Operation lookup end
  @Operation last end
  @Operation max end
  @Operation prepend end
  @Operation reverse end
  @Operation reject end
  @Operation sortNamedElements_CaseIndependent end
  @Operation subSequence end
  @Operation sortNames end
  @Operation sortNamedElements end
  @Operation sort end
  @Operation set end
  @Operation separateWith end
  @Operation select end
  @Operation sel end
  @Operation size end
  @Operation toString end
  @Operation tail end
  @Operation take end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Seq(Element)}{inspectDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{size}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{headTailDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{reject}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sortNamedElements_CaseIndependent}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{excluding}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{drop}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{tail}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{collect}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{take}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{append}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{subSequence}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{asSet}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sortNames}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{asSeq}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sortNamedElements}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{asString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sort}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{at}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{set}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{bind}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{separateWith}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{binds}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{select}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{butLast}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sel}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{contains}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{reverse}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{default}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{prepend}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{dot}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{max}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{drop}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{lookup}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{exists}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{iter}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{flatten}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{isProperSequence}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{including}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{isEmpty}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{indexOf}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{includes}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{insertAt}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{head}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{isKindOf}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{hasSuffix}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{last}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{hasPrefix}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{lookup}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{forAll}
No Documentation Specified
\DataType{Set(Element)}

      An instance of Set where the element type is Element. This is the super-type 
      of all set data types
\begin{Interface}
@DataType Set(Element) extends Element
  @Operation asSet end
  @Operation asSeq end
  @Operation contains end
  @Operation collect end
  @Operation dot end
  @Operation default end
  @Operation elementsDialog end
  @Operation exists end
  @Operation excluding end
  @Operation exists end
  @Operation flatten end
  @Operation inspectDialog end
  @Operation iter end
  @Operation isKindOf end
  @Operation isEmpty end
  @Operation intersection end
  @Operation includes end
  @Operation including end
  @Operation max end
  @Operation reject end
  @Operation select end
  @Operation sel end
  @Operation select end
  @Operation size end
  @Operation toString end
  @Operation union end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Set(Element)}{inspectDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{size}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{elementsDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{select}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{union}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{sel}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{reject}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{select}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{including}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{max}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{exists}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{iter}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{excluding}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{isKindOf}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{collect}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{isEmpty}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{asSeq}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{intersection}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{asSet}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{includes}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{contains}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{flatten}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{default}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{exists}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{dot}
No Documentation Specified
\DataType{Seq(Element)}

      An instance of Seq where the element type is Element. This is the super-type
      of all sequence data types.
\begin{Interface}
@DataType Seq(Element) extends Element
  @Operation at end
  @Operation asString end
  @Operation asSeq end
  @Operation asSet end
  @Operation append end
  @Operation butLast end
  @Operation binds end
  @Operation bind end
  @Operation contains end
  @Operation collect end
  @Operation drop end
  @Operation dot end
  @Operation default end
  @Operation drop end
  @Operation exists end
  @Operation excluding end
  @Operation forAll end
  @Operation flatten end
  @Operation headTailDialog end
  @Operation head end
  @Operation hasSuffix end
  @Operation hasPrefix end
  @Operation inspectDialog end
  @Operation iter end
  @Operation isProperSequence end
  @Operation isEmpty end
  @Operation includes end
  @Operation isKindOf end
  @Operation insertAt end
  @Operation indexOf end
  @Operation including end
  @Operation lookup end
  @Operation lookup end
  @Operation last end
  @Operation max end
  @Operation prepend end
  @Operation reverse end
  @Operation reject end
  @Operation sortNamedElements_CaseIndependent end
  @Operation subSequence end
  @Operation sortNames end
  @Operation sortNamedElements end
  @Operation sort end
  @Operation set end
  @Operation separateWith end
  @Operation select end
  @Operation sel end
  @Operation size end
  @Operation toString end
  @Operation tail end
  @Operation take end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Seq(Element)}{inspectDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{size}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{headTailDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{reject}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sortNamedElements_CaseIndependent}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{excluding}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{drop}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{tail}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{collect}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{take}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{append}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{subSequence}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{asSet}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sortNames}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{asSeq}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sortNamedElements}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{asString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sort}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{at}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{set}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{bind}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{separateWith}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{binds}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{select}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{butLast}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{sel}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{contains}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{reverse}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{default}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{prepend}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{dot}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{max}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{drop}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{lookup}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{exists}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{iter}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{flatten}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{isProperSequence}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{including}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{isEmpty}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{indexOf}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{includes}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{insertAt}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{head}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{isKindOf}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{hasSuffix}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{last}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{hasPrefix}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{lookup}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Seq(Element)}{forAll}
No Documentation Specified
\DataType{Set(Element)}

      An instance of Set where the element type is Element. This is the super-type 
      of all set data types
\begin{Interface}
@DataType Set(Element) extends Element
  @Operation asSet end
  @Operation asSeq end
  @Operation contains end
  @Operation collect end
  @Operation dot end
  @Operation default end
  @Operation elementsDialog end
  @Operation exists end
  @Operation excluding end
  @Operation exists end
  @Operation flatten end
  @Operation inspectDialog end
  @Operation iter end
  @Operation isKindOf end
  @Operation isEmpty end
  @Operation intersection end
  @Operation includes end
  @Operation including end
  @Operation max end
  @Operation reject end
  @Operation select end
  @Operation sel end
  @Operation select end
  @Operation size end
  @Operation toString end
  @Operation union end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Set(Element)}{inspectDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{size}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{elementsDialog}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{select}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{union}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{sel}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{reject}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{select}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{including}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{max}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{exists}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{iter}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{excluding}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{isKindOf}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{collect}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{isEmpty}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{asSeq}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{intersection}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{asSet}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{includes}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{contains}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{flatten}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{default}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{exists}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Set(Element)}{dot}
No Documentation Specified
\DataType{String}

      The data type for strings. The defualt value is the empty string.
\begin{Interface}
@DataType String extends Element
  @Operation asSet end
  @Operation asSeq end
  @Operation asInt end
  @Operation asBool end
  @Operation default end
  @Operation exec end
  @Operation fileExists end
  @Operation hasSuffix end
  @Operation hasPrefix end
  @Operation isOlder end
  @Operation lookup end
  @Operation loadBin end
  @Operation mkDir end
  @Operation newlinesToEscapeChars end
  @Operation padFrom end
  @Operation padTo end
  @Operation repeat end
  @Operation subString end
  @Operation stripWhiteSpace end
  @Operation splitBy end
  @Operation size end
  @Operation truncate end
  @Operation toUpper end
  @Operation toLower end
  @Operation toString end
  @Operation upperCaseInitialLetter end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::String}{newlinesToEscapeChars}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{asBool}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{upperCaseInitialLetter}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{asInt}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{truncate}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{asSeq}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{toUpper}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{asSet}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{toLower}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{default}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{exec}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{subString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{fileExists}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{stripWhiteSpace}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{hasPrefix}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{splitBy}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{hasSuffix}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{size}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{isOlder}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{repeat}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{loadBin}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{padFrom}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{lookup}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{padTo}
No Documentation Specified
\DataTypeOperation{Root::EMOF::String}{mkDir}
No Documentation Specified
\Class{Root::EMOF}{Seq}

      Seq is a sub-class of DataType. All sequence data types are an instance of
      Seq. Seq defines an attribute 'elementType' that is used to record the
       type of the elements in a sequence data type.
\begin{Interface}
@Class Seq extends DataType
  @Attribute elementType : Classifier end
  @Operation init end
  @Operation seqType end
  @Operation setElementType end
end
\end{Interface}
\ClassOperation{Root::EMOF::Seq}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Seq}{seqType}
No Documentation Specified
\ClassOperation{Root::EMOF::Seq}{setElementType}
No Documentation Specified
\Class{Root::EMOF}{Set}

      Set is a sub-class of DataType. All set data types are an instance of
      Set. Set defines an attribute 'elementType' that is used to record the
      type of the elements in a set data type.
\begin{Interface}
@Class Set extends DataType
  @Attribute elementType : Classifier end
  @Operation init end
  @Operation setType end
  @Operation setElementType end
end
\end{Interface}
\ClassOperation{Root::EMOF::Set}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Set}{setType}
No Documentation Specified
\ClassOperation{Root::EMOF::Set}{setElementType}
No Documentation Specified
\DataType{Symbol}

      Symbol is a sub-class of String. Whereas there may be two different strings 
      with the same sequence of characters, there can only be one symbol with the 
      same sequence of characters. This is useful when using names as the basis for
      lookup (in tables). For example XMF ensures that classes, packages, operations,
      slots are named using symbols so that the lookup of these features by name is
      as efficient as possible. If strings were used the lookup would necessarily
      involve a character by character comparison. Using symbols the lookup can use 
      the symbols identity as the comparison operator. You can reference a symbol
      by constructing an instance: Symbol(name).
\begin{Interface}
@DataType Symbol extends String
  @Operation init end
  @Operation toString end
end
\end{Interface}
\DataTypeOperation{Root::EMOF::Symbol}{toString}
No Documentation Specified
\DataTypeOperation{Root::EMOF::Symbol}{init}
No Documentation Specified
\Class{Root::EMOF}{StructuralFeature}

      This is an abstract class that is the super-class of all classes that
      describe structural features. For example Attribute is a sub-class of
      StructuralFeature. Other types of structural feature are possible by 
      managing the internal structure of objects via a MOP.
\begin{Interface}
@Class StructuralFeature isabstract extends TypedElement
end
\end{Interface}
\Class{Root::EMOF}{TypedElement}

      A typed element is a named element with an associated type. The type is
      a classifier. This is an abstract class and is used (for example) to define
      Attribute.
\begin{Interface}
@Class TypedElement isabstract extends NamedElement
  @Attribute type : Classifier end
end
\end{Interface}
\Class{Root::EMOF}{Table}

      A table associates keys with values. Any element can be used as a key.
      A table has an initial size and can support any number of values. Use 'hasKey/1'
      to determine whether a table contains a key. Use 'get/1' to access a table
      via a key and 'put/2' to update a table given a key and a value. Use 'keys/0'
      to access the set of keys for a table.
\begin{Interface}
@Class Table isabstract extends Element
  @Attribute swappingKeys : Boolean end
  @Operation addKeyValueChangedDaemon end
  @Operation addNewKeyDaemon end
  @Operation addKeyRemovedDaemon end
  @Operation addKeyValueChangedDaemon end
  @Operation addNewKeyDaemon end
  @Operation addKeyRemovedDaemon end
  @Operation addDaemon end
  @Operation clear end
  @Operation daemonNamed end
  @Operation daemons end
  @Operation fire end
  @Operation get end
  @Operation get end
  @Operation hasKey end
  @Operation hasDaemonNamed end
  @Operation hasKey end
  @Operation init end
  @Operation keys end
  @Operation put end
  @Operation pprint end
  @Operation put end
  @Operation ref end
  @Operation removeDaemonNamed end
  @Operation removeDaemon end
  @Operation remove end
  @Operation remove end
  @Operation swapKeys end
  @Operation size end
  @Operation setDaemons end
  @Operation set end
  @Operation toString end
  @Operation values end
end
\end{Interface}
\ClassOperation{Root::EMOF::Table}{addKeyValueChangedDaemon}

      Use this operation to add a daemon that monitors changes in key

      values. This will not fire when the key is added or when the

      key is removed. The args for the daemon are the key, the new value

      and the old value.
\ClassOperation{Root::EMOF::Table}{addNewKeyDaemon}

      Use this operation to add a daemon that monitors the addition of

      new keys to a table. The args for the daemon are the new key

      and its value.
\ClassOperation{Root::EMOF::Table}{addKeyRemovedDaemon}

      Use this operation to add a daemon that monitors the removal of

      keys from a table. The args of the daemon are the key that is removed

      and its value in the table.
\ClassOperation{Root::EMOF::Table}{addKeyValueChangedDaemon}

      Use this operation to add a daemon that monitors changes in key

      values. This will not fire when the key is added or when the

      key is removed. The args for the daemon are the key, the new value

      and the old value.
\ClassOperation{Root::EMOF::Table}{addNewKeyDaemon}

      Use this operation to add a daemon that monitors the addition of

      new keys to a table. The args for the daemon are the new key

      and its value.
\ClassOperation{Root::EMOF::Table}{addKeyRemovedDaemon}

      Use this operation to add a daemon that monitors the removal of

      keys from a table. The args of the daemon are the key that is removed

      and its value in the table.
\ClassOperation{Root::EMOF::Table}{addDaemon}

      All tables have a collection of daemons. A daemon is an operation that is

      invoked whenever a table is updated. The operation is any invokable value 
      (either an operation or an object that implements the 'invoke/2' operation. 
      The invocation occurs after the table has been updated and is supplied with 
      the index, the new bucket and the old bucket that has changed.
\ClassOperation{Root::EMOF::Table}{clear}

      Clears the table. Fires any daemons defined for the table.
\ClassOperation{Root::EMOF::Table}{daemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{daemons}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{fire}

      When a table is updated, its daemons are fired by calling this operation. 
      The operation is supplied with the bucket index, the old state of the changed 
      bucket and the new state of the changed bucket. The index is supplied to make

      the daemon mechanism compatible with that for arrays. In most cases the index

      will be of no value. The table specific daemon definition operations

      hide away the index.
\ClassOperation{Root::EMOF::Table}{get}

      Return the valueof the supplied key in the table.
      If the key does not exist then an exception is

      raised. Use 'hasKey/1' to check if the key exists.
\ClassOperation{Root::EMOF::Table}{get}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{hasKey}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{hasDaemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{hasKey}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{keys}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{put}

      Add an association between the supplied key and value.
      Any existing association for the key is removed.
\ClassOperation{Root::EMOF::Table}{pprint}

      This operation prints out all the entries in a table.
\ClassOperation{Root::EMOF::Table}{put}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{ref}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{removeDaemonNamed}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{removeDaemon}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{remove}

     Remove the supplied key from the table. This succeeds whether

     the key exists in the tabel or not. Any daemons defined for the

     table are performed. The table is returned.
\ClassOperation{Root::EMOF::Table}{remove}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{swapKeys}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{size}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{setDaemons}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{set}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{toString}
No Documentation Specified
\ClassOperation{Root::EMOF::Table}{values}
No Documentation Specified
\Class{Root::EMOF}{Vector}
No Documentation Specified
\begin{Interface}
@Class Vector isabstract extends Element
  @Operation copyInto end
  @Operation daemonsActive end
  @Operation daemons end
  @Operation init end
  @Operation put end
  @Operation ref end
  @Operation size end
  @Operation setDaemonsActive end
  @Operation setDaemons end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::EMOF::Vector}{copyInto}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{daemonsActive}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{daemons}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{init}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{put}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{ref}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{size}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{setDaemonsActive}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{setDaemons}
No Documentation Specified
\ClassOperation{Root::EMOF::Vector}{toString}
No Documentation Specified
\Operation{Root::EMOF}{noDoc}
No Documentation Specified
\Package{Root}{Grammars}
No Documentation Specified
\Class{Root::Grammars}{PathRef}
No Documentation Specified
\begin{Interface}
@Class PathRef extends Object
  @Attribute path : Seq(String) end
end
\end{Interface}
\Package{Root}{IO}

      The IO package provides classes and operations that support

      input and output. XMF uses input and output channels that

      can be used as the sources and sinks of characters. The channel

      stdout is used to write to the standard output. The operation

      'format' is provided to control formatted output.
\Class{Root::IO}{ElementOutputChannel}

      An element output channel encodes an element in the XMF

      save data format and writes the load instructions to the

      underlying output channel. When the instructions are

      subsequently read by an element input channel the saved

      element will be reconstructed including any sharing that

      it contains. Be careful to call reset before using the

      channel in order to reset the underlying save and load 
      machinery.
\begin{Interface}
@Class ElementOutputChannel extends OutputChannel
  @Attribute out : OutputChannel end
  @Operation close end
  @Operation channel end
  @Operation flush end
  @Operation reset end
  @Operation setChannel end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::IO::ElementOutputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::ElementOutputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::ElementOutputChannel}{flush}
No Documentation Specified
\ClassOperation{Root::IO::ElementOutputChannel}{reset}
No Documentation Specified
\ClassOperation{Root::IO::ElementOutputChannel}{setChannel}
No Documentation Specified
\ClassOperation{Root::IO::ElementOutputChannel}{toString}
No Documentation Specified
\ClassOperation{Root::IO::ElementOutputChannel}{write}

        Encodes the supplied element as load instructions and

        writes them to the underlying output channel. The nameSpaces

        argument is a sequence of name spaces that are assumed to be

        present when the instructions are performed. Values in these

        name spaces are saved as REF instructions, i.e. when the

        instructions are performed the XMF machine looks up references

        to the values rather than constructing new values.
\Class{Root::IO}{ElementInputChannel}

      An element input channel reads a saved XMF element from an

      underlying input channel and reconstructs an element. The 
      reconstruction is performed by interpreting the XMF data

      language read from the underlying input channel. Typically

      the value will have been written using an element output

      channel. You should be careful to reset the input channel

      before reading.
\begin{Interface}
@Class ElementInputChannel extends InputChannel
  @Attribute input : InputChannel end
  @Operation close end
  @Operation channel end
  @Operation peek end
  @Operation read end
  @Operation reset end
  @Operation setChannel end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::IO::ElementInputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::ElementInputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::ElementInputChannel}{peek}
No Documentation Specified
\ClassOperation{Root::IO::ElementInputChannel}{read}

        Read a saved element from the underlying input channel.
        The reconstructed element is returned.
\ClassOperation{Root::IO::ElementInputChannel}{reset}

        Resets the underlying save and load mechanism ready for

        reading.
\ClassOperation{Root::IO::ElementInputChannel}{setChannel}
No Documentation Specified
\ClassOperation{Root::IO::ElementInputChannel}{toString}
No Documentation Specified
\Class{Root::IO}{EvalInputChannel}

      This channel is initialised with a grammar, an input channel and a sequence
      of imports. When requested for a value via 'readValue', the channel will parse the
      next input from the channel and evaluate it.
      
      Constructor: EvalInputChannel(grammar,start,channel,imports)
\begin{Interface}
@Class EvalInputChannel extends InputChannel
  @Attribute channel : InputChannel end
  @Attribute env : Element end
  @Attribute grammar : Element end
  @Attribute imports : Seq(NameSpace) end
  @Attribute state : Element end
  @Attribute start : String end
  @Operation asString end
  @Operation close end
  @Operation channel end
  @Operation eof end
  @Operation peek end
  @Operation readValue end
  @Operation read end
  @Operation setChannel end
end
\end{Interface}
\ClassOperation{Root::IO::EvalInputChannel}{asString}
No Documentation Specified
\ClassOperation{Root::IO::EvalInputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::EvalInputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::EvalInputChannel}{eof}
No Documentation Specified
\ClassOperation{Root::IO::EvalInputChannel}{peek}
No Documentation Specified
\ClassOperation{Root::IO::EvalInputChannel}{readValue}
No Documentation Specified
\ClassOperation{Root::IO::EvalInputChannel}{read}
No Documentation Specified
\ClassOperation{Root::IO::EvalInputChannel}{setChannel}
No Documentation Specified
\Class{Root::IO}{FileOutputChannel}

      A file output channel is used to write chars to a file.
      Constructor: FileOutputStream(fileName:String)
        Creates and returns a file output stream to the named file.
        The file should be passed as a pathname to the file. The file will

        be created if it does not already exist.
\begin{Interface}
@Class FileOutputChannel extends OutputChannel
  @Attribute channel : Element end
  @Operation close end
  @Operation channel end
  @Operation flush end
  @Operation init end
  @Operation setChannel end
  @Operation writeChar end
end
\end{Interface}
\ClassOperation{Root::IO::FileOutputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::FileOutputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::FileOutputChannel}{flush}
No Documentation Specified
\ClassOperation{Root::IO::FileOutputChannel}{init}
No Documentation Specified
\ClassOperation{Root::IO::FileOutputChannel}{setChannel}
No Documentation Specified
\ClassOperation{Root::IO::FileOutputChannel}{writeChar}
No Documentation Specified
\Class{Root::IO}{FileInputChannel}

       A FileInputChannel generates a sequence of characters from a file.
       Constructor: FileInputChannel(path)
         Creates and returns a file input channel from the given file.
         The path should be string.
\begin{Interface}
@Class FileInputChannel extends InputChannel
  @Attribute channel : Element end
  @Operation asString end
  @Operation close end
  @Operation channel end
  @Operation eof end
  @Operation init end
  @Operation peek end
  @Operation read end
  @Operation setChannel end
end
\end{Interface}
\ClassOperation{Root::IO::FileInputChannel}{asString}
No Documentation Specified
\ClassOperation{Root::IO::FileInputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::FileInputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::FileInputChannel}{eof}
No Documentation Specified
\ClassOperation{Root::IO::FileInputChannel}{init}
No Documentation Specified
\ClassOperation{Root::IO::FileInputChannel}{peek}
No Documentation Specified
\ClassOperation{Root::IO::FileInputChannel}{read}
No Documentation Specified
\ClassOperation{Root::IO::FileInputChannel}{setChannel}
No Documentation Specified
\Class{Root::IO}{Format}

      This cass implements a formatter. A formatter is applied to an
      output channel, a control string and an optional sequence of
      argments. The formatter prints out the chars of the control
      string with respect to the arguments. Control chars are 
      introduced via '~' and invoke the appropriate control char handler.
\begin{Interface}
@Class Format extends Object
  @Attribute handlers : Table end
  @Operation dispatch end
  @Operation defineHandler end
  @Operation format end
  @Operation invoke end
  @Operation init end
  @Operation target end
end
\end{Interface}
\ClassOperation{Root::IO::Format}{dispatch}
No Documentation Specified
\ClassOperation{Root::IO::Format}{defineHandler}
No Documentation Specified
\ClassOperation{Root::IO::Format}{format}

        This is the formatting loop. While there are control chars:
        if the char is '~' then jump to the handler otherwise just
         print the char and go round again.
\ClassOperation{Root::IO::Format}{invoke}
No Documentation Specified
\ClassOperation{Root::IO::Format}{init}
No Documentation Specified
\ClassOperation{Root::IO::Format}{target}
No Documentation Specified
\Class{Root::IO}{FormatContext}

      A formatter uses a context to control formatting.
      The context is created on each call to a formatter
      and is updated during formatting. The format context
      is supplied to format handlers so that thay can consume
      arbitrary values and control string characters.
      Constructor: FormatContext(control,values,index)
        The control is a control string, the values area sequence of
        values controlled by the control string and the index is an
        integer index into the control string.
\begin{Interface}
@Class FormatContext extends Object
  @Attribute args : Seq(Element) end
  @Attribute control : String end
  @Attribute index : Integer end
  @Attribute values : Seq(Element) end
  @Operation at end
  @Operation appendValues end
  @Operation appendControl end
  @Operation complete end
  @Operation controlTo end
  @Operation init end
  @Operation lift end
  @Operation nextValue end
  @Operation nextChar end
  @Operation peekChar end
  @Operation parseNumeric end
  @Operation parseArgs end
  @Operation parseArg end
end
\end{Interface}
\ClassOperation{Root::IO::FormatContext}{at}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{appendValues}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{appendControl}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{complete}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{controlTo}

        Returns the string up to and including the supplied control
        char. Removes the control chars from the head of the control 
        string. Note that this does not take into account nested
        control strings.
\ClassOperation{Root::IO::FormatContext}{init}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{lift}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{nextValue}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{nextChar}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{peekChar}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{parseNumeric}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{parseArgs}
No Documentation Specified
\ClassOperation{Root::IO::FormatContext}{parseArg}
No Documentation Specified
\Class{Root::IO}{InputChannel}

       An input channel is a character source. Use 'read/1' to get the

       next character code from the channel and use 'eof/0' to test whether

       the channel is exhausted.
\begin{Interface}
@Class InputChannel isabstract extends Object
  @Operation close end
  @Operation channel end
  @Operation eof end
  @Operation peek end
  @Operation read end
  @Operation readNonWhiteSpace end
  @Operation setChannel end
end
\end{Interface}
\ClassOperation{Root::IO::InputChannel}{close}

          Used when the input channel is no longer required.
\ClassOperation{Root::IO::InputChannel}{channel}

           Returns a machine-level input channel.
\ClassOperation{Root::IO::InputChannel}{eof}

          Returns true when the channel has no more input.
\ClassOperation{Root::IO::InputChannel}{peek}

          Looks at the next input without consuming it.
\ClassOperation{Root::IO::InputChannel}{read}

          Returns the character code for the next input or null if no

          input is available.
\ClassOperation{Root::IO::InputChannel}{readNonWhiteSpace}

          Returns the next non-whitespace character on the input channel.
\ClassOperation{Root::IO::InputChannel}{setChannel}

          Sets the underlying channel (if supported).
\Class{Root::IO}{OutputChannel}

      An output channel is a sink of characters for output. 
      Use output channels with an output formatter such as

      'format'.
\begin{Interface}
@Class OutputChannel isabstract extends Object
  @Operation close end
  @Operation channel end
  @Operation flush end
  @Operation setChannel end
  @Operation writeChar end
  @Operation writeString end
end
\end{Interface}
\ClassOperation{Root::IO::OutputChannel}{close}

        Call this operation when use of the channel is complete.
\ClassOperation{Root::IO::OutputChannel}{channel}

        Returns the machine output channel.
\ClassOperation{Root::IO::OutputChannel}{flush}
No Documentation Specified
\ClassOperation{Root::IO::OutputChannel}{setChannel}
No Documentation Specified
\ClassOperation{Root::IO::OutputChannel}{writeChar}

        Use the writeChar operation to write characters to an

        output channel.
        Parameter: char:Integer

          Write character codes to the channel.
\ClassOperation{Root::IO::OutputChannel}{writeString}
No Documentation Specified
\Class{Root::IO}{StringInputChannel}

      A string input channel reads characters from a string.
\begin{Interface}
@Class StringInputChannel extends InputChannel
  @Attribute channel : Element end
  @Operation asString end
  @Operation close end
  @Operation channel end
  @Operation eof end
  @Operation init end
  @Operation peek end
  @Operation read end
  @Operation setChannel end
end
\end{Interface}
\ClassOperation{Root::IO::StringInputChannel}{asString}
No Documentation Specified
\ClassOperation{Root::IO::StringInputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::StringInputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::StringInputChannel}{eof}
No Documentation Specified
\ClassOperation{Root::IO::StringInputChannel}{init}
No Documentation Specified
\ClassOperation{Root::IO::StringInputChannel}{peek}
No Documentation Specified
\ClassOperation{Root::IO::StringInputChannel}{read}
No Documentation Specified
\ClassOperation{Root::IO::StringInputChannel}{setChannel}
No Documentation Specified
\Class{Root::IO}{StandardOutputChannel}
No Documentation Specified
\begin{Interface}
@Class StandardOutputChannel extends OutputChannel
  @Attribute channel : Element end
  @Operation close end
  @Operation channel end
  @Operation flush end
  @Operation setChannel end
  @Operation writeChar end
end
\end{Interface}
\ClassOperation{Root::IO::StandardOutputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::StandardOutputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::StandardOutputChannel}{flush}
No Documentation Specified
\ClassOperation{Root::IO::StandardOutputChannel}{setChannel}
No Documentation Specified
\ClassOperation{Root::IO::StandardOutputChannel}{writeChar}
No Documentation Specified
\Class{Root::IO}{StandardInputChannel}
No Documentation Specified
\begin{Interface}
@Class StandardInputChannel extends InputChannel
  @Attribute channel : Element end
  @Operation asString end
  @Operation close end
  @Operation channel end
  @Operation eof end
  @Operation peek end
  @Operation read end
  @Operation setChannel end
end
\end{Interface}
\ClassOperation{Root::IO::StandardInputChannel}{asString}
No Documentation Specified
\ClassOperation{Root::IO::StandardInputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::StandardInputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::StandardInputChannel}{eof}
No Documentation Specified
\ClassOperation{Root::IO::StandardInputChannel}{peek}
No Documentation Specified
\ClassOperation{Root::IO::StandardInputChannel}{read}
No Documentation Specified
\ClassOperation{Root::IO::StandardInputChannel}{setChannel}
No Documentation Specified
\Class{Root::IO}{StringOutputChannel}

      An output channel that buffers its chars up in a string.
      Use 'getString/0' to get the string from the channel.
      
      Constructor: StringOutputChannel()
\begin{Interface}
@Class StringOutputChannel extends OutputChannel
  @Attribute chars : Seq(Integer) end
  @Operation close end
  @Operation flush end
  @Operation getString end
  @Operation writeChar end
end
\end{Interface}
\ClassOperation{Root::IO::StringOutputChannel}{close}

         Call this operation when use of the channel is complete.
\ClassOperation{Root::IO::StringOutputChannel}{flush}
No Documentation Specified
\ClassOperation{Root::IO::StringOutputChannel}{getString}

        Get the string managed by a string output channel.
\ClassOperation{Root::IO::StringOutputChannel}{writeChar}
No Documentation Specified
\Class{Root::IO}{TokenInputChannel}
No Documentation Specified
\begin{Interface}
@Class TokenInputChannel extends InputChannel
  @Attribute input : InputChannel end
  @Operation close end
  @Operation channel end
  @Operation eof end
  @Operation peek end
  @Operation readToken end
  @Operation readSymbol end
  @Operation readString end
  @Operation readNumber end
  @Operation read end
  @Operation setChannel end
end
\end{Interface}
\ClassOperation{Root::IO::TokenInputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{channel}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{eof}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{peek}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{readToken}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{readSymbol}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{readString}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{readNumber}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{read}
No Documentation Specified
\ClassOperation{Root::IO::TokenInputChannel}{setChannel}
No Documentation Specified
\Class{Root::IO}{XMLOutputChannel}

      An XML output channel writes an XML encoding of any element to a supplied

      base output channel. The translation of sharing in the XMF element is

      taken care of using id ref elements in the XML. In general the first

      occurrence of an element is translated to the XML equivalent and then

      subsequent occurrences will appear in the XML as id refs; all elements

      that can be shared are allocated a unique id as part of the translation

      process. The encoding conforms to XMF.dtd.
\begin{Interface}
@Class XMLOutputChannel extends OutputChannel
  @Attribute out : OutputChannel end
  @Attribute walker : XML end
  @Operation close end
  @Operation toString end
  @Operation writeChar end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::IO::XMLOutputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::XMLOutputChannel}{toString}
No Documentation Specified
\ClassOperation{Root::IO::XMLOutputChannel}{writeChar}
No Documentation Specified
\ClassOperation{Root::IO::XMLOutputChannel}{write}

        Encodes the supplied element as an XML element and writes it

        to the underlying output channel.
\Class{Root::IO}{XMLInputChannel}

      An XML input channel reads characters from an input channel and translates

      them to XML elements. The model of XML is defined in Root::XML.
\begin{Interface}
@Class XMLInputChannel extends InputChannel
  @Attribute input : InputChannel end
  @Operation close end
  @Operation read end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::IO::XMLInputChannel}{close}
No Documentation Specified
\ClassOperation{Root::IO::XMLInputChannel}{read}

        Parses characters from the underlying input channel and constructs

        XML elements. Returns an XML document if the parse is successful.
\ClassOperation{Root::IO::XMLInputChannel}{toString}
No Documentation Specified
\Package{Root}{Instrs}

    The package Instrs contains the definition of all XMF machine

    instructions. Each machine instruction has an 8-bit code used by 
    the XMF machine. The codes are defined in the operation Instr::code/0.
    Each instruction defines a collection of operations that are used by 
    the compiler and assembler.
\Class{Root::Instrs}{And}

      A machine instruction. Expects two elements at the head

      of the stack. Pops the elements and performs an 'and' operation.
      The machine knows how to perform 'and' for boolean operands.
      If the machine does not understand the operand types then 'and/1' 
      is sent to the left hand operand. The result is left at the head 
      of the stack.
\begin{Interface}
@Class And extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::And}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::And}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::And}{write}
No Documentation Specified
\Class{Root::Instrs}{Accept}

     A machine instruction that performs an non blocking connect on the
     server found at the head of the stack.
\begin{Interface}
@Class Accept extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::Accept}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Accept}{toString}
No Documentation Specified
\Class{Root::Instrs}{AsSeq}
No Documentation Specified
\begin{Interface}
@Class AsSeq extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::AsSeq}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::AsSeq}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::AsSeq}{write}
No Documentation Specified
\Class{Root::Instrs}{ArraySet}

      Expects an array above an index and a value on the stack. 
      Pops the values and sets the array at the given index to

      be the value. Returns the array. Causes any daemons defined

      for the array to be fired.
\begin{Interface}
@Class ArraySet extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::ArraySet}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::ArraySet}{toString}
No Documentation Specified
\Class{Root::Instrs}{At}
No Documentation Specified
\begin{Interface}
@Class At extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::At}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::At}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::At}{write}
No Documentation Specified
\Class{Root::Instrs}{ArrayRef}

      Expects an array above an index on the stack and pushes the

      value of the array at the index onto the stack after popping 
      operands.
\begin{Interface}
@Class ArrayRef extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::ArrayRef}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::ArrayRef}{toString}
No Documentation Specified
\Class{Root::Instrs}{Add}

      A machine instruction. Expects two elements at the head

      of the stack. Pops the elements and performs an + operation.
      Many + operations are builtin to the machine. If the machine

      does not understand the operand types then 'add/1' is sent

      to the left hand operand. The result is left at the head of the

      stack.
\begin{Interface}
@Class Add extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Add}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Add}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Add}{write}
No Documentation Specified
\Class{Root::Instrs}{Cons}

      A machine instruction. Expects two operands at the head of the stack.
      Both operands are popped. The top element is a sequence 't' and the

      element below is 'h'. The instruction pushes the sequence Seq{h | t}
      back on the stack.
\begin{Interface}
@Class Cons extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Cons}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Cons}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Cons}{write}
No Documentation Specified
\Class{Root::Instrs}{Dot}

      A machine instruction that performs object navigation.
      The instruction has an operand in the machine word that 
      is the offset in the constants array of the current

      code box indexing a symbol. The instruction expects a

      value at the head of the stack. The value is popped. If

      the type of the element is known by the machine (typically

      an object) then the slot value indexed by the symbol is

      pushed onto the stack. Otherwise the instruction causes a

      'dot/1' message to be sent to the element. A value is left 
      at the head of the stack.
\begin{Interface}
@Class Dot extends Instr
  @Attribute constOffset : Integer end
  @Attribute name : String end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Dot}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Dot}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::Dot}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::Dot}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Dot}{write}
No Documentation Specified
\Class{Root::Instrs}{Drop}
No Documentation Specified
\begin{Interface}
@Class Drop extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Drop}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Drop}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Drop}{write}
No Documentation Specified
\Class{Root::Instrs}{Dynamic}

      A machine instruction that looks up the value of a dynamic

      variable. The offset into the constants array in the currently

      executing code box is in the instruction word. This indexes a

      symbol that is used to lookup a value in the current dynamics

      list starting in the current machine stack frame. This will 
      lookup the symbol name in all currently imported name spaces 
      (actually hash tables in the dynamics list). The instruction

      leaves the value of the dyanamic on the stack. An error will

      occur of a dynamic with the appropriate name cannot be found.
\begin{Interface}
@Class Dynamic extends Instr
  @Attribute nameOffset : Integer end
  @Attribute name : Symbol end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Dynamic}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Dynamic}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::Dynamic}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::Dynamic}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Dynamic}{write}
No Documentation Specified
\Class{Root::Instrs}{Div}

      A machine instruction. Expects two elements at the head

      of the stack. Pops the elements and performs a / operation.
      Many / operations are builtin to the machine. If the machine

      does not understand the operand types then 'div/1' is sent

      to the left hand operand. The result is left at the head of the

      stack.
\begin{Interface}
@Class Div extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Div}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Div}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Div}{write}
No Documentation Specified
\Class{Root::Instrs}{Excluding}
No Documentation Specified
\begin{Interface}
@Class Excluding extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Excluding}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Excluding}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Excluding}{write}
No Documentation Specified
\Class{Root::Instrs}{Eql}

      A machine instruction. Expects two elements at the head

      of the stack. Pops the elements and performs a = operation.
      The '=' operation is implemented by the machine. Objects

      are compared by identity, sequences are compared by identity

      (since they can be updated by side effect), sets are compared

      by structure (recursively applying '=' to elements), symbols

      are copared by identity, strings are compared by structure and

      all atomic data items are compared by value.
      The boolean result is left at the head of the stack.
\begin{Interface}
@Class Eql extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Eql}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Eql}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Eql}{write}
No Documentation Specified
\Class{Root::Instrs}{Enter}

      A machine instruction that closes a currently open call

      frame and switches machine context to start to execute the

      instructions in the new call frame in the context of the 
      locals in that frame. When an operation is called, a new frame

      is opened, the arguments are pushed, the operation is pushed and

      then the frame is entered. Entering the frame switches context

      by updating the machine registers such as CurrentFrame to point

      to the newly constructed frame. When the operation returns

      the frame is discarded and control passes to the previously

      open frame.
\begin{Interface}
@Class Enter extends Instr
  @Attribute arity : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Enter}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Enter}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::Enter}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::Enter}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Enter}{write}
No Documentation Specified
\Class{Root::Instrs}{Greater}

      A machine instruction. Expects two elements at the head

      of the stack. Pops the elements and performs a > operation.
      If the elements are numbers then > will push the appropriate

      boolean value. If the machine does not understand the operand 
      types then 'gre/1' is sent to the left hand operand. The result 
      is left at the head of the stack.
\begin{Interface}
@Class Greater extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Greater}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Greater}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Greater}{write}
No Documentation Specified
\Class{Root::Instrs}{GlobalRef}

      A global ref occurs when a local variable is referenced by

      an operation where the variable is declared outside the

      operation. When the operation is created, all local variables

      from the enclosing scope are added to the dynamics array of the

      new operation. Dynamics arrays are linked, so that a newly 
      created dynamics array is linked to the dynamics array of the

      enclosing scope. When a dynamic variable is referenced in the body

      of an operation, the value is found by chaining back through the

      dynamic array linked list that is in the current stack frame and

      then indexing into the resulting array. This instruction has

      machine word operands that statically determine the 'frame'
      (i.e. how many links to traverse) and the 'offset' (i.e. the

      index into the resulting array). The instruction leaves a value 
      on the stack.
\begin{Interface}
@Class GlobalRef extends Instr
  @Attribute frame : Integer end
  @Attribute name : String end
  @Attribute offset : Integer end
  @Operation assemble end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::GlobalRef}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::GlobalRef}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::GlobalRef}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::GlobalRef}{write}
No Documentation Specified
\Class{Root::Instrs}{GetElement}
No Documentation Specified
\begin{Interface}
@Class GetElement extends Instr
  @Attribute nameOffset : Integer end
  @Attribute name : Symbol end
  @Operation assemble end
  @Operation operands end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::GetElement}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::GetElement}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::GetElement}{toString}
No Documentation Specified
\Class{Root::Instrs}{Head}

      This machine instruction expects a sequence at the head of the stack.
      It pops the sequence and pushes the head of the sequence back on the

      stack. If the value is not a sequence then the instruction sen-ds a

      'head/0' message to the value.
\begin{Interface}
@Class Head extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Head}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Head}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Head}{write}
No Documentation Specified
\Class{Root::Instrs}{Includes}
No Documentation Specified
\begin{Interface}
@Class Includes extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Includes}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Includes}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Includes}{write}
No Documentation Specified
\Class{Root::Instrs}{Including}
No Documentation Specified
\begin{Interface}
@Class Including extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Including}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Including}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Including}{write}
No Documentation Specified
\Class{Root::Instrs}{Instr}

      A machine instruction is an instance of the abstract class Instr.
      Each machine instruction has a code in the range 1 - 255. Machine

      instructions are of the form:

      LABEL CODE DATA1 DATA2 DATA3

      where each element is an 8 bit value. The high byte is the machine

      byte code. The rest of the machine instruction word may contain up to

      3 operands encoded as bytes. Typically these may be constants or

      indices into parts of the current machine stack frame. The class Instr

      allocates the instruction byte codes. These should correspond to the

      byte codes used by the underlying machine implementation. The optional

      labal is a string that can be used as the target of a SKIP instruction.
\begin{Interface}
@Class Instr isabstract extends Object
  @Attribute label : String end
  @Operation assemble end
  @Operation code end
  @Operation label end
  @Operation operands end
  @Operation setLabel end
end
\end{Interface}
\ClassOperation{Root::Instrs::Instr}{assemble}

        The target adds itself to the code box. The operands of the instruction

        may require calculation in the context of the code box. This operation

        performs calculations such as working out offsets into the code box

        constant area.
\ClassOperation{Root::Instrs::Instr}{code}
No Documentation Specified
\ClassOperation{Root::Instrs::Instr}{label}
No Documentation Specified
\ClassOperation{Root::Instrs::Instr}{operands}

        Return the operands of the instruction encoded as a 24 bit integer.
        The assembler uses this operation to translate an instruction object

        to a 32 bit integer.
\ClassOperation{Root::Instrs::Instr}{setLabel}
No Documentation Specified
\Class{Root::Instrs}{Implies}

      A machine instruction. Expects two elements at the head

      of the stack. Pops the elements and performs an implies operation.
      If the operands are boolean then the machine performs the

      operation directly, pushing the value on the stack. If the machine

      does not understand the operand types then 'implies/1' is sent

      to the left hand operand. The result is left at the head of the

      stack.
\begin{Interface}
@Class Implies extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Implies}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Implies}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Implies}{write}
No Documentation Specified
\Class{Root::Instrs}{IsKindOf}
No Documentation Specified
\begin{Interface}
@Class IsKindOf extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::IsKindOf}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::IsKindOf}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::IsKindOf}{write}
No Documentation Specified
\Class{Root::Instrs}{IsEmpty}
No Documentation Specified
\begin{Interface}
@Class IsEmpty extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::IsEmpty}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::IsEmpty}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::IsEmpty}{write}
No Documentation Specified
\Class{Root::Instrs}{LocalRef}

      This machine instruction references a local variable location

      in the current stack frame. The index of the local variab;e

      location is in the machine instruction word. The instruction

      leaves the local value on the top of the stack.
\begin{Interface}
@Class LocalRef extends Instr
  @Attribute name : String end
  @Attribute offset : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::LocalRef}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::LocalRef}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::LocalRef}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::LocalRef}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::LocalRef}{write}
No Documentation Specified
\Class{Root::Instrs}{Less}

       A machine instruction. Expects two elements at the head

       of the stack. Pops the elements and performs a < operation.
       If the elements are numbers then < will push the appropriate

       boolean value. If the machine does not understand the operand 
       types then 'less/1' is sent to the left hand operand. The result 
       is left at the head of the stack.
\begin{Interface}
@Class Less extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Less}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Less}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Less}{write}
No Documentation Specified
\Class{Root::Instrs}{Mul}

       A machine instruction. Expects two elements at the head

       of the stack. Pops the elements and performs a * operation.
       Many * operations are builtin to the machine. If the machine

       does not understand the operand types then 'mul/1' is sent

       to the left hand operand. The result is left at the head of the

       stack.
\begin{Interface}
@Class Mul extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Mul}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Mul}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Mul}{write}
No Documentation Specified
\Class{Root::Instrs}{MkSet}

      A machine instruction that expects a collection of values

      on the stack. The machine instruction word has a single

      operand that is the number of elements to pop off the stack.
      the values are formed into a set which is then pushed onto 
      the stack.
\begin{Interface}
@Class MkSet extends Instr
  @Attribute size : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::MkSet}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSet}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSet}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSet}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSet}{write}
No Documentation Specified
\Class{Root::Instrs}{MkSeq}

      A machine instruction that expects a collection of values

      on the stack. The machine instruction word has a single

      operand that is the number of elements to pop off the stack.
      the values are formed into a sequence which is then pushed onto 
      the stack.
\begin{Interface}
@Class MkSeq extends Instr
  @Attribute size : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::MkSeq}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSeq}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSeq}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSeq}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::MkSeq}{write}
No Documentation Specified
\Class{Root::Instrs}{MkOp}

      This machine instruction constructs an operation. The

      machine instruction word has two operands being the

      indices in the constants array of the current machine

      stack frame for the name of the operation and the code

      box of the function. The instruction expects a number of

      values on the stack corresponding to the globals that are

      popped into a freshly allocated array. The array is linked to

      the globals array in the current stack frame and becomes the

      globals array for the new operation. The new operation is

      pushed onto the stack.
\begin{Interface}
@Class MkOp extends Instr
  @Attribute arity : Integer end
  @Attribute codeBoxOffset : Integer end
  @Attribute code : Seq(Element) end
  @Attribute free : Integer end
  @Attribute isMultiArgs : Boolean end
  @Attribute locals : Integer end
  @Attribute nameOffset : Integer end
  @Attribute name : String end
  @Attribute source : String end
  @Operation assemble end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::MkOp}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::MkOp}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::MkOp}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::MkOp}{write}
No Documentation Specified
\Class{Root::Instrs}{MkOpE}

      This machine instruction is an exten-ded version of MKOP.
      The instruction expects the code box offset to be pushed

      on the stack before the instruction is performed.
\begin{Interface}
@Class MkOpE extends Instr
  @Attribute arity : Integer end
  @Attribute codeBoxOffset : Integer end
  @Attribute code : Seq(Element) end
  @Attribute free : Integer end
  @Attribute isMultiArgs : Boolean end
  @Attribute locals : Integer end
  @Attribute nameOffset : Integer end
  @Attribute name : String end
  @Attribute source : String end
  @Operation assemble end
  @Operation operands end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::MkOpE}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::MkOpE}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::MkOpE}{toString}
No Documentation Specified
\Class{Root::Instrs}{NameSpaceRef}

       A name space contains definitions. When a name space and its definitions

       are statically defined, it is possible for the definitions to be mutually

       recursive. Each name is scoped over all the other definitions in the name

       space. Since name spaces can contain nested name spaces, names are scoped over 
       nested definitions. This machine instruction is used to index a name that

       is statically declared in an enclosing name space. Name space contents are

       linked to their enclosing name space using their 'owner' slot. The instruction

       contains two operands in the instruction word. The contour defines how many

       'owner' slots must be traversed to get to the appropriate name space. The name 
       to reference is given by the second operand which is an offset into the current

       constants array in the stack frame. The instruction either signals an error

       if the name is not found or pushes the value of the name space reference 
       onto the stack.
\begin{Interface}
@Class NameSpaceRef extends Instr
  @Attribute contour : Integer end
  @Attribute nameOffset : Integer end
  @Attribute name : String end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::NameSpaceRef}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::NameSpaceRef}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::NameSpaceRef}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::NameSpaceRef}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::NameSpaceRef}{write}
No Documentation Specified
\Class{Root::Instrs}{NoOp}

      A NOOP instruction is a placeholder instruction. It has no effect when
      performed. It is typically used to generate an instruction address via
      a label.
\begin{Interface}
@Class NoOp extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::NoOp}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::NoOp}{toString}
No Documentation Specified
\Class{Root::Instrs}{Null}
No Documentation Specified
\begin{Interface}
@Class Null extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Null}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Null}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Null}{write}
No Documentation Specified
\Class{Root::Instrs}{Negate}
No Documentation Specified
\begin{Interface}
@Class Negate extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Negate}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Negate}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Negate}{write}
No Documentation Specified
\Class{Root::Instrs}{Of}
No Documentation Specified
\begin{Interface}
@Class Of extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Of}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Of}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Of}{write}
No Documentation Specified
\Class{Root::Instrs}{Or}
No Documentation Specified
\begin{Interface}
@Class Or extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Or}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Or}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Or}{write}
No Documentation Specified
\Class{Root::Instrs}{PushTrue}

      A machine instruction that pushes 'true' onto the stack.
\begin{Interface}
@Class PushTrue extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::PushTrue}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::PushTrue}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::PushTrue}{write}
No Documentation Specified
\Class{Root::Instrs}{PushString}

      A machine instruction that pushes a string onto the stack.
      The string is indexed by the instruction word operand in the

      currentstack frame constants array.
\begin{Interface}
@Class PushString extends Instr
  @Attribute valueOffset : Integer end
  @Attribute value : String end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::PushString}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::PushString}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::PushString}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::PushString}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::PushString}{write}
No Documentation Specified
\Class{Root::Instrs}{PushFalse}

      A machine instruction that pushes 'false' onto the stack.
\begin{Interface}
@Class PushFalse extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::PushFalse}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::PushFalse}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::PushFalse}{write}
No Documentation Specified
\Class{Root::Instrs}{Pop}

      A machine instruction that pops the stack.
\begin{Interface}
@Class Pop extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Pop}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Pop}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Pop}{write}
No Documentation Specified
\Class{Root::Instrs}{PushInteger}

      A machine instruction that pushes an integer value onto the

      stack. The integer is encoded in the machine word as an

      instruction operand.
\begin{Interface}
@Class PushInteger extends Instr
  @Attribute value : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::PushInteger}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::PushInteger}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::PushInteger}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::PushInteger}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::PushInteger}{write}
No Documentation Specified
\Class{Root::Instrs}{Return}

      A machine instruction that returns from the current operation call.
      The value at the top of the stack is popped and the current stack

      frame is discarded (returning to the most recently pushed stack

      frame). The value is then pushed onto the top of the stack. This must be

      the last instruction executed in the body of an operation.
\begin{Interface}
@Class Return extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Return}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Return}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Return}{write}
No Documentation Specified
\Class{Root::Instrs}{Read}

      A machine instruction that performs an non blocking read on the

      input channel found at the head of the stack.
\begin{Interface}
@Class Read extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::Read}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Read}{toString}
No Documentation Specified
\Class{Root::Instrs}{Self}

      References the current value of self. This is held in the current

      stack frame. The value is pushed onto the stack.
\begin{Interface}
@Class Self extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Self}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Self}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Self}{write}
No Documentation Specified
\Class{Root::Instrs}{Super}
No Documentation Specified
\begin{Interface}
@Class Super extends Instr
  @Attribute arity : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::Super}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Super}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::Super}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::Super}{toString}
No Documentation Specified
\Class{Root::Instrs}{Sub}
No Documentation Specified
\begin{Interface}
@Class Sub extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Sub}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Sub}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Sub}{write}
No Documentation Specified
\Class{Root::Instrs}{SourcePos}
No Documentation Specified
\begin{Interface}
@Class SourcePos extends Instr
  @Attribute charCount : Integer end
  @Attribute lineCount : Integer end
  @Operation assemble end
  @Operation operands end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::SourcePos}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SourcePos}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::SourcePos}{toString}
No Documentation Specified
\Class{Root::Instrs}{SkipFalse}
No Documentation Specified
\begin{Interface}
@Class SkipFalse extends Instr
  @Attribute offset : Integer end
  @Attribute targetLabel : String end
  @Operation assemble end
  @Operation offset end
  @Operation operands end
  @Operation setTargetLabel end
  @Operation setOffset end
  @Operation targetLabel end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::SkipFalse}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipFalse}{offset}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipFalse}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipFalse}{setTargetLabel}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipFalse}{setOffset}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipFalse}{targetLabel}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipFalse}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipFalse}{write}
No Documentation Specified
\Class{Root::Instrs}{SkipBack}
No Documentation Specified
\begin{Interface}
@Class SkipBack extends Instr
  @Attribute offset : Integer end
  @Attribute targetLabel : String end
  @Operation assemble end
  @Operation offset end
  @Operation operands end
  @Operation setTargetLabel end
  @Operation setOffset end
  @Operation targetLabel end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::SkipBack}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipBack}{offset}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipBack}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipBack}{setTargetLabel}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipBack}{setOffset}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipBack}{targetLabel}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipBack}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::SkipBack}{write}
No Documentation Specified
\Class{Root::Instrs}{Skip}
No Documentation Specified
\begin{Interface}
@Class Skip extends Instr
  @Attribute offset : Integer end
  @Attribute targetLabel : String end
  @Operation assemble end
  @Operation offset end
  @Operation operands end
  @Operation setTargetLabel end
  @Operation setOffset end
  @Operation targetLabel end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Skip}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Skip}{offset}
No Documentation Specified
\ClassOperation{Root::Instrs::Skip}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::Skip}{setTargetLabel}
No Documentation Specified
\ClassOperation{Root::Instrs::Skip}{setOffset}
No Documentation Specified
\ClassOperation{Root::Instrs::Skip}{targetLabel}
No Documentation Specified
\ClassOperation{Root::Instrs::Skip}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Skip}{write}
No Documentation Specified
\Class{Root::Instrs}{Send}

      This machine instruction sen-ds a message to a target. The message

      has a name and some arguments. The target is at the top of the stack

      above the arguments. The instruction word contains the arity and the

      offset of the message in the current constants array. The message

      name must be a symbol. The instruction is performed after a new stack

      frame has been opened and the arguments and target have been pushed. 
      The instruction then enters the stack frame after finding the operation

      appropriate to the target. If no operation is defined then an error is

      signaled.
\begin{Interface}
@Class Send extends Instr
  @Attribute arity : Integer end
  @Attribute messageOffset : Integer end
  @Attribute message : Symbol end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Send}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Send}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::Send}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::Send}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Send}{write}
No Documentation Specified
\Class{Root::Instrs}{Size}
No Documentation Specified
\begin{Interface}
@Class Size extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Size}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Size}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Size}{write}
No Documentation Specified
\Class{Root::Instrs}{SetTail}
No Documentation Specified
\begin{Interface}
@Class SetTail extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::SetTail}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SetTail}{toString}
No Documentation Specified
\Class{Root::Instrs}{SetSlot}
No Documentation Specified
\begin{Interface}
@Class SetSlot extends Instr
  @Attribute nameOffset : Integer end
  @Attribute name : String end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::SetSlot}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SetSlot}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::SetSlot}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::SetSlot}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::SetSlot}{write}
No Documentation Specified
\Class{Root::Instrs}{SetHead}
No Documentation Specified
\begin{Interface}
@Class SetHead extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::SetHead}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SetHead}{toString}
No Documentation Specified
\Class{Root::Instrs}{SetGlobal}
No Documentation Specified
\begin{Interface}
@Class SetGlobal extends Instr
  @Attribute frame : Integer end
  @Attribute name : String end
  @Attribute offset : Integer end
  @Operation assemble end
  @Operation operands end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::SetGlobal}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SetGlobal}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::SetGlobal}{toString}
No Documentation Specified
\Class{Root::Instrs}{SetLocal}
No Documentation Specified
\begin{Interface}
@Class SetLocal extends Instr
  @Attribute name : String end
  @Attribute offset : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::SetLocal}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::SetLocal}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::SetLocal}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::SetLocal}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::SetLocal}{write}
No Documentation Specified
\Class{Root::Instrs}{Sel}
No Documentation Specified
\begin{Interface}
@Class Sel extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Sel}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Sel}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Sel}{write}
No Documentation Specified
\Class{Root::Instrs}{StartCall}
No Documentation Specified
\begin{Interface}
@Class StartCall extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::StartCall}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::StartCall}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::StartCall}{write}
No Documentation Specified
\Class{Root::Instrs}{TablePut}

      Expects a table above a key and a velu on the stack. Pops these

      values and sets the value of the key to be the value in the table.
      Causes any daemons to fire.
\begin{Interface}
@Class TablePut extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::TablePut}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::TablePut}{toString}
No Documentation Specified
\Class{Root::Instrs}{TableGet}

      Expects a table above a key on the stack. Pops these and pushes

      the value of the key in the table on the stack. Raises an exception

      if the key is not defined.
\begin{Interface}
@Class TableGet extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::TableGet}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::TableGet}{toString}
No Documentation Specified
\Class{Root::Instrs}{TailEnter}
No Documentation Specified
\begin{Interface}
@Class TailEnter extends Instr
  @Attribute arity : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::TailEnter}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::TailEnter}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::TailEnter}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::TailEnter}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::TailEnter}{write}
No Documentation Specified
\Class{Root::Instrs}{Try}
No Documentation Specified
\begin{Interface}
@Class Try extends Instr
  @Attribute body : Seq(Instr) end
  @Attribute codeBoxOffset : Integer end
  @Attribute freeVars : Integer end
  @Attribute locals : Integer end
  @Attribute source : String end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::Try}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Try}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::Try}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::Try}{toString}
No Documentation Specified
\Class{Root::Instrs}{TailSuper}
No Documentation Specified
\begin{Interface}
@Class TailSuper extends Instr
  @Attribute arity : Integer end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::TailSuper}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSuper}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSuper}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSuper}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSuper}{write}
No Documentation Specified
\Class{Root::Instrs}{Throw}
No Documentation Specified
\begin{Interface}
@Class Throw extends Instr
  @Operation assemble end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Instrs::Throw}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Throw}{toString}
No Documentation Specified
\Class{Root::Instrs}{TailSend}
No Documentation Specified
\begin{Interface}
@Class TailSend extends Instr
  @Attribute arity : Integer end
  @Attribute messageOffset : Integer end
  @Attribute message : String end
  @Operation assemble end
  @Operation init end
  @Operation operands end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::TailSend}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSend}{init}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSend}{operands}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSend}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::TailSend}{write}
No Documentation Specified
\Class{Root::Instrs}{Tail}
No Documentation Specified
\begin{Interface}
@Class Tail extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Tail}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Tail}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Tail}{write}
No Documentation Specified
\Class{Root::Instrs}{Union}
No Documentation Specified
\begin{Interface}
@Class Union extends Instr
  @Operation assemble end
  @Operation toString end
  @Operation write end
end
\end{Interface}
\ClassOperation{Root::Instrs::Union}{assemble}
No Documentation Specified
\ClassOperation{Root::Instrs::Union}{toString}
No Documentation Specified
\ClassOperation{Root::Instrs::Union}{write}
No Documentation Specified
\Operation{Root::Instrs}{disassemble}
No Documentation Specified
\Operation{Root}{Kernel\_addAtt}
\Operation{Root}{Kernel\_stringInputChannel}
\Operation{Root}{Kernel\_funSetArity}
\Operation{Root}{Kernel\_daemonsOff}
\Operation{Root}{Kernel\_mkString}
\Operation{Root}{Kernel\_setOf}
\Operation{Root}{Kernel\_letVar}
\Operation{Root}{Kernel\_invoke}
\Operation{Root}{Kernel\_asSeq}
\Operation{Root}{Kernel\_funIsVarArgs}
\Operation{Root}{Kernel\_funSupers}
\Operation{Root}{Kernel\_read}
\Operation{Root}{Kernel\_yield}
\Operation{Root}{Kernel\_codeBoxCodeSize}
\Operation{Root}{Kernel\_codeBoxSetResourceName}
\Operation{Root}{Kernel\_funSetArgs}
\Operation{Root}{Kernel\_daemons}
\Operation{Root}{Kernel\_stackFrames}
\Operation{Root}{Kernel\_mkFloat}
\Operation{Root}{Kernel\_setDaemons}
\Operation{Root}{Kernel\_flush}
\Operation{Root}{Kernel\_imports}
\Operation{Root}{Kernel\_arraySetDaemonsActive}
\Operation{Root}{Kernel\_peek}
\Operation{Root}{Kernel\_funGlobals}
\Operation{Root}{Kernel\_writeChar}
\Operation{Root}{Kernel\_funSetSupers}
\Operation{Root}{Kernel\_codeBoxSetCode}
\Operation{Root}{Kernel\_cos}
\Operation{Root}{Kernel\_funSetDoc}
\Operation{Root}{Kernel\_mkDir}
\Operation{Root}{Kernel\_stats}
\Operation{Root}{Kernel\_codeBoxSetInstrAt}
\Operation{Root}{Kernel\_server\_bind}
\Operation{Root}{Kernel\_fork}
\Operation{Root}{Kernel\_import}
\Operation{Root}{Kernel\_operatorPrecedenceList}
\Operation{Root}{Kernel\_funCodeBox}
\Operation{Root}{Kernel\_valueToString}
\Operation{Root}{Kernel\_copy}
\Operation{Root}{Kernel\_funSetSelf}
\Operation{Root}{Kernel\_arraySetDaemons}
\Operation{Root}{Kernel\_funSetCodeBox}
\Operation{Root}{Kernel\_mkCodeBox}
\Operation{Root}{Kernel\_sqrt}
\Operation{Root}{Kernel\_close}
\Operation{Root}{Kernel\_floor}
\Operation{Root}{Kernel\_server\_accept}
\Operation{Root}{Kernel\_hashCode}
\Operation{Root}{Kernel\_codeBoxSetConstants}
\Operation{Root}{Kernel\_codeSet}
\Operation{Root}{Kernel\_funArgs}
\Operation{Root}{Kernel\_operationCodeBox}
\Operation{Root}{Kernel\_funSetProperties}
\Operation{Root}{Kernel\_slotNames}
\Operation{Root}{Kernel\_traceFrames}
\Operation{Root}{Kernel\_arraySet}
\Operation{Root}{Kernel\_client\_connect}
\Operation{Root}{Kernel\_loadbin}
\Operation{Root}{Kernel\_mkCode}
\Operation{Root}{Kernel\_exit}
\Operation{Root}{Kernel\_funSelf}
\Operation{Root}{Kernel\_hasVar}
\Operation{Root}{Kernel\_save2}
\Operation{Root}{Kernel\_codeBoxOperandsAt}
\Operation{Root}{Kernel\_codeBoxToFun}
\Operation{Root}{Kernel\_funArity}
\Operation{Root}{Kernel\_of}
\Operation{Root}{Kernel\_sin}
\Operation{Root}{Kernel\_tokenChannelTextTo}
\Operation{Root}{Kernel\_arrayRef}
\Operation{Root}{Kernel\_exec}
\Operation{Root}{Kernel\_funSetOwner}
\Operation{Root}{Kernel\_mkBasicTokenChannel}
\Operation{Root}{Kernel\_funProperties}
\Operation{Root}{Kernel\_callcc}
\Operation{Root}{Kernel\_hasSlot}
\Operation{Root}{Kernel\_save}
\Operation{Root}{Kernel\_codeBoxSource}
\Operation{Root}{Kernel\_fileOutputChannel}
\Operation{Root}{Kernel\_nextToken}
\Operation{Root}{Kernel\_size}
\Operation{Root}{Kernel\_codeBoxName}
\Operation{Root}{Kernel\_eof}
\Operation{Root}{Kernel\_arrayLength}
\Operation{Root}{Kernel\_funSetName}
\Operation{Root}{Kernel\_backtrace}
\Operation{Root}{Kernel\_getVar}
\Operation{Root}{Kernel\_round}
\Operation{Root}{Kernel\_tableHasKey}
\Operation{Root}{Kernel\_funOwner}
\Operation{Root}{Kernel\_mkArray}
\Operation{Root}{Kernel\_setTypes}
\Operation{Root}{Kernel\_die}
\Operation{Root}{Kernel\_codeBoxSetSource}
\Operation{Root}{Kernel\_mkSymbol}
\Operation{Root}{Kernel\_codeBoxLocals}
\Operation{Root}{Kernel\_fileInputChannel}
\Operation{Root}{Kernel\_arrayDaemonsActive}
\Operation{Root}{Kernel\_funSetGlobals}
\Operation{Root}{Kernel\_getSlotValue}
\Operation{Root}{Kernel\_resetSaveLoad}
\Operation{Root}{Kernel\_available}
\Operation{Root}{Kernel\_funName}
\Operation{Root}{Kernel\_mk24bit}
\Operation{Root}{Kernel\_tableRemove}
\Operation{Root}{Kernel\_date}
\Operation{Root}{Kernel\_setSlotValue}
\Operation{Root}{Kernel\_mkObj}
\Operation{Root}{Kernel\_codeBoxSetName}
\Operation{Root}{Kernel\_codeBoxInstrAt}
\Operation{Root}{Kernel\_fileExists}
\Operation{Root}{Kernel\_funDynamics}
\Operation{Root}{Kernel\_funSetTraced}
\Operation{Root}{Kernel\_load}
\Operation{Root}{Kernel\_arrayDaemons}
\Operation{Root}{Kernel\_asString}
\Operation{Root}{Kernel\_funSetDynamics}
\Operation{Root}{Kernel\_readXML}
\Operation{Root}{Kernel\_tableKeys}
\Operation{Root}{Kernel\_daemonsOn}
\Operation{Root}{Kernel\_setCharAt}
\Operation{Root}{Kernel\_mkTable}
\Operation{Root}{Kernel\_isOlder}
\Operation{Root}{Kernel\_codeBoxResourceName}
\Operation{Root}{Kernel\_asSet}
\Operation{Root}{Kernel\_codeBoxConstants}
\Operation{Root}{Kernel\_funDoc}
\Operation{Root}{Kernel\_funTraced}
\Operation{Root}{Kernel\_readString}
\Package{Root}{Languages}
No Documentation Specified
\Package{Root::Languages}{Automata}
No Documentation Specified
\Class{Root::Languages::Automata}{Automaton}
No Documentation Specified
\begin{Interface}
@Class Automaton extends Object
  @Attribute states : Set(State) end
  @Attribute startName : String end
  @Attribute transitions : Set(Transition) end
  @Operation addToTransitions end
  @Operation addToStates end
  @Operation addTransition end
  @Operation addState end
  @Operation add end
  @Operation inspectDialog end
  @Operation run end
  @Operation stateNamed end
  @Operation startingState end
  @Operation toString end
  @Operation transitionsFrom end
end
\end{Interface}
\ClassOperation{Root::Languages::Automata::Automaton}{addToTransitions}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{addToStates}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{addTransition}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{addState}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{add}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{run}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{stateNamed}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{startingState}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{toString}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Automaton}{transitionsFrom}
No Documentation Specified
\Class{Root::Languages::Automata}{State}
No Documentation Specified
\begin{Interface}
@Class State extends NamedElement
  @Attribute action : Operation end
  @Operation activate end
end
\end{Interface}
\ClassOperation{Root::Languages::Automata::State}{activate}
No Documentation Specified
\Class{Root::Languages::Automata}{Transition}
No Documentation Specified
\begin{Interface}
@Class Transition extends Contained
  @Attribute action : Operation end
  @Attribute guard : Operation end
  @Attribute sourceName : String end
  @Attribute targetName : String end
  @Operation activate end
  @Operation isEnabled end
  @Operation source end
  @Operation toString end
  @Operation target end
end
\end{Interface}
\ClassOperation{Root::Languages::Automata::Transition}{activate}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Transition}{isEnabled}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Transition}{source}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Transition}{toString}
No Documentation Specified
\ClassOperation{Root::Languages::Automata::Transition}{target}
No Documentation Specified
\Package{Root::Languages}{MicroJava}
No Documentation Specified
\Package{Root::Languages::MicroJava}{Expressions}
No Documentation Specified
\Class{Root::Languages::MicroJava}{Java}
No Documentation Specified
\begin{Interface}
@Class Java extends Object
end
\end{Interface}
\Package{Root::Languages::MicroJava}{Structure}
No Documentation Specified
\Class{Root::Languages::MicroJava::Structure}{Class}
No Documentation Specified
\begin{Interface}
@Class Class extends Sugar
  @Attribute features : Seq(Feature) end
  @Attribute name : String end
  @Attribute parent : Path end
  @Operation desugar end
  @Operation parentExps end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Structure::Class}{desugar}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Class}{parentExps}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Class}{toString}
No Documentation Specified
\Class{Root::Languages::MicroJava::Structure}{Formal}
No Documentation Specified
\begin{Interface}
@Class Formal extends Object
  @Attribute name : String end
  @Attribute type : Type end
  @Operation desugar end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Structure::Formal}{desugar}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Formal}{toString}
No Documentation Specified
\Class{Root::Languages::MicroJava::Structure}{Field}
No Documentation Specified
\begin{Interface}
@Class Field extends Feature
  @Attribute name : String end
  @Attribute type : Type end
  @Operation desugar end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Structure::Field}{desugar}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Field}{toString}
No Documentation Specified
\Class{Root::Languages::MicroJava::Structure}{Feature}
No Documentation Specified
\begin{Interface}
@Class Feature isabstract extends Sugar
end
\end{Interface}
\Class{Root::Languages::MicroJava::Structure}{Method}
No Documentation Specified
\begin{Interface}
@Class Method extends Feature
  @Attribute body : Block end
  @Attribute formals : Seq(Formal) end
  @Attribute name : String end
  @Attribute type : Type end
  @Operation desugarVoid end
  @Operation desugarReturn end
  @Operation desugar end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Structure::Method}{desugarVoid}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Method}{desugarReturn}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Method}{desugar}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Method}{toString}
No Documentation Specified
\Class{Root::Languages::MicroJava::Structure}{NamedType}
No Documentation Specified
\begin{Interface}
@Class NamedType extends Type
  @Attribute path : Seq(String) end
  @Operation desugar end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Structure::NamedType}{desugar}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::NamedType}{toString}
No Documentation Specified
\Class{Root::Languages::MicroJava::Structure}{Path}
No Documentation Specified
\begin{Interface}
@Class Path extends Sugar
  @Attribute names : Seq(String) end
  @Operation desugar end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Structure::Path}{desugar}
No Documentation Specified
\ClassOperation{Root::Languages::MicroJava::Structure::Path}{toString}
No Documentation Specified
\Class{Root::Languages::MicroJava::Structure}{Type}
No Documentation Specified
\begin{Interface}
@Class Type extends Sugar
end
\end{Interface}
\Class{Root::Languages::MicroJava::Structure}{Void}
No Documentation Specified
\begin{Interface}
@Class Void extends Type
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Structure::Void}{desugar}
No Documentation Specified
\Package{Root::Languages::MicroJava}{Statements}
No Documentation Specified
\Class{Root::Languages::MicroJava::Statements}{Block}
No Documentation Specified
\begin{Interface}
@Class Block extends Statement
  @Attribute statements : Seq(Statement) end
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Statements::Block}{desugar}
No Documentation Specified
\Class{Root::Languages::MicroJava::Statements}{Return}
No Documentation Specified
\begin{Interface}
@Class Return extends Statement
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::Languages::MicroJava::Statements::Return}{desugar}
No Documentation Specified
\Class{Root::Languages::MicroJava::Statements}{Statement}

      A Java statement can be one of the following:
      
        o A block.
        o A method call.
        o A while loop.
        o A do loop.
        o A conditional.
        o A side effect.
        o A return.
        o A declaration.
        
      In order to support declarations (within the current block)
      use 'desugarBlock/1' which passes the rest of the statements
      in the block so that 'let' expressions can be introduced.
      
      In order to support return statements we use continuation
      passing to implement the non-local returns. To continue with
      the next statement, call the continuation to return dont
      call the current continuation.
\begin{Interface}
@Class Statement isabstract extends Sugar
end
\end{Interface}
\Package{Root::Languages}{Wizard}
No Documentation Specified
\Class{Root::Languages::Wizard}{Button}
No Documentation Specified
\begin{Interface}
@Class Button extends Layout
  @Attribute givesReport : Boolean end
  @Attribute isReadOnly : Boolean end
  @Attribute iconAlignment : String end
  @Attribute iconFilePath : String end
  @Attribute id : String end
  @Attribute text : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::Button}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Button}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{CheckBox}
No Documentation Specified
\begin{Interface}
@Class CheckBox extends Layout
  @Attribute givesReport : Boolean end
  @Attribute isReadOnly : Boolean end
  @Attribute id : String end
  @Attribute tooltip : String end
  @Attribute text : String end
  @Attribute value : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::CheckBox}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::CheckBox}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{Client}
No Documentation Specified
\begin{Interface}
@Class Client extends Object
  @Attribute commandsOutput : OutputChannel end
  @Attribute commandsInput : InputChannel end
  @Attribute commandsPort : Integer end
  @Attribute dir : String end
  @Attribute guiPort : Integer end
  @Attribute input : InputChannel end
  @Attribute output : OutputChannel end
  @Operation XMLHeader end
  @Operation report end
  @Operation readXML end
  @Operation readArg end
  @Operation read end
  @Operation read end
  @Operation setDir end
  @Operation sendData end
  @Operation send end
  @Operation startGUI end
  @Operation startCommands end
  @Operation toString end
  @Operation valueOf end
  @Operation writeXML end
  @Operation wait end
  @Operation waitForDataSent end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::Client}{XMLHeader}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{report}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{readXML}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{readArg}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{read}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{read}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{setDir}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{sendData}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{send}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{startGUI}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{startCommands}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{toString}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{valueOf}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{writeXML}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{wait}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Client}{waitForDataSent}
No Documentation Specified
\Class{Root::Languages::Wizard}{ChoiceForm}
No Documentation Specified
\begin{Interface}
@Class ChoiceForm extends Form
  @Attribute choices : Seq(Element) end
  @Attribute label : String end
  @Attribute x : Integer end
  @Attribute y : Integer end
end
\end{Interface}
\Class{Root::Languages::Wizard}{DropDownOption}
No Documentation Specified
\begin{Interface}
@Class DropDownOption extends Option
  @Attribute id : String end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::DropDownOption}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{DropDown}
No Documentation Specified
\begin{Interface}
@Class DropDown extends Layout
  @Attribute givesReport : Boolean end
  @Attribute isReadOnly : Boolean end
  @Attribute id : String end
  @Attribute options : Seq(DropDownOption) end
  @Attribute tooltip : String end
  @Attribute value : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::DropDown}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::DropDown}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{Form}
No Documentation Specified
\begin{Interface}
@Class Form extends Object
  @Attribute buttons : Seq(Button) end
  @Attribute checkBoxes : Seq(CheckBox) end
  @Attribute dropDowns : Seq(DropDown) end
  @Attribute id : String end
  @Attribute labels : Seq(Label) end
  @Attribute name : String end
  @Attribute radioButtons : Seq(RadioButton) end
  @Attribute textBoxes : Seq(TextBox) end
  @Attribute tables : Seq(Table) end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::Form}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Form}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{GenericGUISchema}
No Documentation Specified
\begin{Interface}
@Class GenericGUISchema extends Object
  @Attribute GUI : GUI end
  @Attribute xmlns : String end
  @Operation find end
  @Operation toString end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::GenericGUISchema}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::GenericGUISchema}{toString}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::GenericGUISchema}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{GUI}
No Documentation Specified
\begin{Interface}
@Class GUI extends Object
  @Attribute formName : String end
  @Attribute forms : Seq(Form) end
  @Attribute iconFilePath : String end
  @Attribute id : String end
  @Attribute menus : Seq(PullDownMenu) end
  @Attribute name : String end
  @Attribute toolBars : Seq(ToolBar) end
  @Attribute trees : Seq(Tree) end
  @Attribute xmlns : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::GUI}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::GUI}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{InfoForm}
No Documentation Specified
\begin{Interface}
@Class InfoForm extends Form
  @Attribute label : String end
  @Attribute x : Integer end
  @Attribute y : Integer end
end
\end{Interface}
\Class{Root::Languages::Wizard}{Layout}
No Documentation Specified
\begin{Interface}
@Class Layout isabstract extends Object
  @Attribute height : Integer end
  @Attribute width : Integer end
  @Attribute x : Integer end
  @Attribute y : Integer end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::Layout}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{Label}
No Documentation Specified
\begin{Interface}
@Class Label extends Layout
  @Attribute iconAlignment : String end
  @Attribute iconFilePath : String end
  @Attribute id : String end
  @Attribute text : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::Label}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Label}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{Option}
No Documentation Specified
\begin{Interface}
@Class Option isabstract extends Object
  @Attribute display : String end
  @Attribute value : String end
end
\end{Interface}
\Class{Root::Languages::Wizard}{PullDownMenu}
No Documentation Specified
\begin{Interface}
@Class PullDownMenu extends Object
  @Attribute dividers : Seq(PullDownMenuDivider) end
  @Attribute items : Seq(PullDownMenuItem) end
  @Attribute id : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::PullDownMenu}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::PullDownMenu}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{PullDownMenuItem}
No Documentation Specified
\begin{Interface}
@Class PullDownMenuItem extends Object
  @Attribute givesReport : Boolean end
  @Attribute isReadonly : Boolean end
  @Attribute id : String end
  @Attribute parent : String end
  @Attribute text : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::PullDownMenuItem}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::PullDownMenuItem}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{PullDownMenuDivider}
No Documentation Specified
\begin{Interface}
@Class PullDownMenuDivider extends Object
  @Attribute id : String end
  @Attribute parent : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::PullDownMenuDivider}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::PullDownMenuDivider}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{Row}
No Documentation Specified
\begin{Interface}
@Class Row extends Object
  @Attribute value : String end
end
\end{Interface}
\Class{Root::Languages::Wizard}{RadioButton}
No Documentation Specified
\begin{Interface}
@Class RadioButton extends Layout
  @Attribute givesReport : Boolean end
  @Attribute isReadOnly : Boolean end
  @Attribute id : String end
  @Attribute tooltip : String end
  @Attribute text : String end
  @Attribute value : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::RadioButton}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::RadioButton}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TableTextBoxRows}
No Documentation Specified
\begin{Interface}
@Class TableTextBoxRows extends Row
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableTextBoxRows}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TableDropDown}
No Documentation Specified
\begin{Interface}
@Class TableDropDown extends Object
  @Attribute columnOrder : Integer end
  @Attribute columnWidth : Integer end
  @Attribute columnName : String end
  @Attribute isReadOnly : Boolean end
  @Attribute options : Seq(TableDropDownOption) end
  @Attribute rows : Seq(TableDropDownRows) end
  @Attribute reportString : String end
  @Attribute tooltip : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableDropDown}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableDropDown}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TableDropDownRows}
No Documentation Specified
\begin{Interface}
@Class TableDropDownRows extends Row
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableDropDownRows}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{Tree}
No Documentation Specified
\begin{Interface}
@Class Tree extends Object
  @Attribute id : String end
  @Attribute treeNodes : Set(TreeNode) end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::Tree}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Tree}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TableColumn}
No Documentation Specified
\begin{Interface}
@Class TableColumn extends Object
  @Attribute cells : Seq(TableColumnCell) end
  @Attribute givesReport : Boolean end
  @Attribute isReadOnly : Boolean end
  @Attribute id : String end
  @Attribute name : String end
  @Attribute options : Seq(TableDropDownOption) end
  @Attribute width : Integer end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableColumn}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableColumn}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TreeNode}
No Documentation Specified
\begin{Interface}
@Class TreeNode extends Object
  @Attribute givesReport : Boolean end
  @Attribute isExpanded : Boolean end
  @Attribute iconFilePath : String end
  @Attribute id : String end
  @Attribute parent : String end
  @Attribute text : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TreeNode}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TreeNode}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{ToolBar}
No Documentation Specified
\begin{Interface}
@Class ToolBar extends Object
  @Attribute dividers : Seq(ToolBarDivider) end
  @Attribute items : Seq(ToolBarItem) end
  @Attribute id : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::ToolBar}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::ToolBar}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TableColumnCell}
No Documentation Specified
\begin{Interface}
@Class TableColumnCell extends Object
  @Attribute id : String end
  @Attribute value : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableColumnCell}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableColumnCell}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TextForm}
No Documentation Specified
\begin{Interface}
@Class TextForm extends Form
  @Attribute label : String end
  @Attribute x : Integer end
  @Attribute y : Integer end
end
\end{Interface}
\Class{Root::Languages::Wizard}{TableForm}
No Documentation Specified
\begin{Interface}
@Class TableForm extends Form
  @Attribute cols : Seq(String) end
  @Attribute label : String end
  @Attribute rows : Seq(String) end
  @Attribute x : Integer end
  @Attribute y : Integer end
  @Operation columns end
  @Operation colIndex end
  @Operation getCell end
  @Operation initCells end
  @Operation indexTable end
  @Operation rowIndex end
  @Operation rowColumn end
  @Operation setCell end
  @Operation valueColumn end
  @Operation valueColumns end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableForm}{columns}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{colIndex}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{getCell}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{initCells}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{indexTable}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{rowIndex}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{rowColumn}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{setCell}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{valueColumn}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableForm}{valueColumns}
No Documentation Specified
\Class{Root::Languages::Wizard}{ToolBarItem}
No Documentation Specified
\begin{Interface}
@Class ToolBarItem extends Object
  @Attribute givesReport : Boolean end
  @Attribute isReadOnly : Boolean end
  @Attribute iconFilePath : String end
  @Attribute id : String end
  @Attribute tooltip : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::ToolBarItem}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::ToolBarItem}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{ToolBarDivider}
No Documentation Specified
\begin{Interface}
@Class ToolBarDivider extends Object
  @Attribute id : String end
  @Attribute parent : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::ToolBarDivider}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::ToolBarDivider}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TextBox}
No Documentation Specified
\begin{Interface}
@Class TextBox extends Layout
  @Attribute givesReport : Boolean end
  @Attribute isReadOnly : Boolean end
  @Attribute id : String end
  @Attribute style : String end
  @Attribute tooltip : String end
  @Attribute value : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TextBox}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TextBox}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TableTextBox}
No Documentation Specified
\begin{Interface}
@Class TableTextBox extends Object
  @Attribute columnOrder : Integer end
  @Attribute columnWidth : Integer end
  @Attribute columnName : String end
  @Attribute format : Integer end
  @Attribute isReadOnly : Boolean end
  @Attribute reportString : String end
  @Attribute rows : Seq(TableTextBoxRows) end
  @Attribute style : Integer end
  @Attribute tooltip : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableTextBox}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableTextBox}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{Table}
No Documentation Specified
\begin{Interface}
@Class Table extends Layout
  @Attribute columns : Seq(TableColumn) end
  @Attribute isReadOnly : Boolean end
  @Attribute id : String end
  @Attribute name : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::Table}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::Table}{toXML}
No Documentation Specified
\Class{Root::Languages::Wizard}{TableDropDownOption}
No Documentation Specified
\begin{Interface}
@Class TableDropDownOption extends Option
  @Attribute id : String end
  @Operation find end
  @Operation toXML end
end
\end{Interface}
\ClassOperation{Root::Languages::Wizard::TableDropDownOption}{find}
No Documentation Specified
\ClassOperation{Root::Languages::Wizard::TableDropDownOption}{toXML}
No Documentation Specified
\Operation{Root::Languages::Wizard}{XMLToWizard}

      Translates an XML element to a Wizard model element.
      Also handles sequences of XML elements. Sequences are
      translated element by element.
\Operation{Root::Languages::Wizard}{mapGUI}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapForm}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapDropDownOption}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapDropDown}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapCheckBox}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapButton}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapTextBox}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapTableDropDownOption}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapTableColumnCell}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapTableColumn}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapTable}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapRadioButton}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapPullDownMenuItem}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapPullDownMenu}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapLabel}
No Documentation Specified
\Operation{Root::Languages::Wizard}{mapTreeNode}
No Documentation Specified
\Operation{Root::Languages::Wizard}{readXML}
No Documentation Specified
\Package{Root}{OCL}

      The OCL package contains the concrete and abstract syntax definitions for

      the OCL language as supplied by XMF. The OCL package is inten-ded to be consistent

      with the OCL standard where this is practical. OCL is not the only language supported

      by XMF but it is used as the basis for the implementation of XMF. As such it has a

      number of differences from and extensions to standard OCL. Each of the classes in OCL 
      define how they are compiled and interpreted on the XMF VM. The OCL package provides

      many of the features that are useful for a wide variety of domain specific languages.
      It is recommen-ded that you base new languages on OCL either as extensions or as

      the target of a desugaring.
\Class{Root::OCL}{Apply}

       An application expression consists of an operator and some operands, all of

       which are expressions. Each expression is performed and the operator expression

       should result in a value that supports the operation 'invoke/2'. Typically,
       the operator will be an instance of the class EMOF::Operation whose invoke

       operation is supported natively by the XMF machine. The effect of the application

       is to invoke the operator on the operands by supplying them as arguments.
       
     Constructor: Apply(operator,operands)
     
       The operator is an expression and the operands are a sequence of expressions.
\begin{Interface}
@Class Apply extends OCL
  @Attribute args : Seq(OCL) end
  @Attribute operator : OCL end
  @Operation FV end
  @Operation FV end
  @Operation compileSuper end
  @Operation compileCall end
  @Operation compileBuiltin end
  @Operation compile end
  @Operation compileSuper end
  @Operation compileCall end
  @Operation compileBuiltin end
  @Operation compile end
  @Operation eval end
  @Operation isSuper end
  @Operation isBuiltin end
  @Operation isSuper end
  @Operation isBuiltin end
  @Operation lift end
  @Operation lift end
  @Operation maxLocals end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Apply}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compileSuper}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compileCall}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compileBuiltin}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compileSuper}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compileCall}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compileBuiltin}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{isSuper}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{isBuiltin}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{isSuper}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{isBuiltin}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Apply}{toString}
No Documentation Specified
\Class{Root::OCL}{BoolExp}

      A boolean constant expression: either {\tt true} or {\tt false}.
     
      Constructor: BoolExp(boolValue)
        The operand is the boolean constant.
\begin{Interface}
@Class BoolExp extends OCL
  @Attribute value : Boolean end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::BoolExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::BoolExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::BoolExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::BoolExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::BoolExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::BoolExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::BoolExp}{toString}
No Documentation Specified
\Class{Root::OCL}{BinExp}

      A binary expression consists of two sub-expressions and a binary operator.
      XMT support extensible operators. For example if '+' is supplied with

      integer operands then the XMT machine handles this natively. Otherwise, 
      if the machine does not understand the operand types, the left handl operand

      is se-nd a message including the right operand. This allows the user to 
      overload the binary operators for their own types.
    
      Constructor: BinExp(left,binOp,right)
        The left and right operands are expressions. The binary operator is a string

        that names the operator.
\begin{Interface}
@Class BinExp extends OCL
  @Attribute binOp : String end
  @Attribute left : OCL end
  @Attribute right : OCL end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::BinExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::BinExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::BinExp}{desugar}
No Documentation Specified
\ClassOperation{Root::OCL::BinExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::BinExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::BinExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::BinExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::BinExp}{toString}
No Documentation Specified
\Class{Root::OCL}{Binding}

      Binding is an abstract class that represents an association

      between a name and a value. Bindings occur in syntax expressions

      such as let.
\begin{Interface}
@Class Binding extends OCL
  @Attribute name : String end
end
\end{Interface}
\Class{Root::OCL}{CmpBinding}
No Documentation Specified
\begin{Interface}
@Class CmpBinding extends CmpEntry
  @Attribute name : String end
  @Attribute value : OCL end
end
\end{Interface}
\Class{Root::OCL}{ContextDef}

      Definitions are evaluated and (typically) added to a container. The 'context'
      construct is a declarative way of specifying that a given definition should be

      added to a particular container. The context construct should occur at the top

      level in files. If the context is a name space then the context expression

      does not cause the name space to be imported.
      
      Constructor: ContextDef(path,def)
        The path is an expression that results in a name space and the def is an expression

        denoting a named element.
\begin{Interface}
@Class ContextDef extends OCL
  @Attribute element : OCL end
  @Attribute path : OCL end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation init end
  @Operation maxLocals end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::OCL::ContextDef}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::ContextDef}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::ContextDef}{desugar}
No Documentation Specified
\ClassOperation{Root::OCL::ContextDef}{init}
No Documentation Specified
\ClassOperation{Root::OCL::ContextDef}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::ContextDef}{pprint}
No Documentation Specified
\Class{Root::OCL}{CmpEntry}
No Documentation Specified
\begin{Interface}
@Class CmpEntry extends Object
end
\end{Interface}
\Class{Root::OCL}{Case}
No Documentation Specified
\begin{Interface}
@Class Case extends OCL
  @Attribute clauses : Seq(Element) end
  @Attribute value : OCL end
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::OCL::Case}{init}
No Documentation Specified
\Class{Root::OCL}{Constp}

      A constant pattern is either an integer, a string a boolean or an empty collection.
      Constructor: Constp(const)
        The expression defines the constant.
\begin{Interface}
@Class Constp extends Pattern
  @Attribute const : Performable end
  @Operation bind end
  @Operation lift end
  @Operation matchCode end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Constp}{bind}
No Documentation Specified
\ClassOperation{Root::OCL::Constp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Constp}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Constp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Constp}{toString}
No Documentation Specified
\Class{Root::OCL}{Consp}

      A cons pattern consists of a head and a tail pattern. A value matches a cons

      pattern when the value is a cons pair and the head of the pair matches the

      head of the pattern and the tail of the pair matches the tail of the pattern.
      Cons patterns can be sugared so that they look like conventional sequences.
      Constructor: Consp(head,tail)
        The head and tail are patterns.
\begin{Interface}
@Class Consp extends Pattern
  @Attribute head : Pattern end
  @Attribute tail : Pattern end
  @Operation bind end
  @Operation lift end
  @Operation matchCode end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::OCL::Consp}{bind}
No Documentation Specified
\ClassOperation{Root::OCL::Consp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Consp}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Consp}{pprint}
No Documentation Specified
\Class{Root::OCL}{Const}
No Documentation Specified
\begin{Interface}
@Class Const extends OCL
  @Attribute value : Element end
  @Operation FV end
  @Operation compile end
  @Operation init end
  @Operation maxLocals end
end
\end{Interface}
\ClassOperation{Root::OCL::Const}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Const}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Const}{init}
No Documentation Specified
\ClassOperation{Root::OCL::Const}{maxLocals}
No Documentation Specified
\Class{Root::OCL}{ConsExp}

      A cons expression constructs a sequence from a head and tail.
      Constructor: ConExp(head,tail)
        The head and tail arguments are expressions. The head expression denotes

        an arbitrary value and the tail expression denotes a sequence (possibly

        the empty sequence).
\begin{Interface}
@Class ConsExp extends OCL
  @Attribute head : OCL end
  @Attribute tail : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::ConsExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::ConsExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::ConsExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::ConsExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::ConsExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::ConsExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::ConsExp}{toString}
No Documentation Specified
\Class{Root::OCL}{Condp}

     A conditional pattern involves a sub-pattern and a predicate expression.
     for the conditional pattern to succeed, the sub-pattern must succeed and

     the condition must be satisfied. The sub-pattern may bind variables and

     the condition is performed in the scope of any pattern bound variables.
\begin{Interface}
@Class Condp extends Pattern
  @Attribute condition : Performable end
  @Attribute pattern : Pattern end
  @Operation bind end
  @Operation lift end
  @Operation matchCode end
  @Operation newVar end
  @Operation newParam end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Condp}{bind}
No Documentation Specified
\ClassOperation{Root::OCL::Condp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Condp}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Condp}{newVar}
No Documentation Specified
\ClassOperation{Root::OCL::Condp}{newParam}
No Documentation Specified
\ClassOperation{Root::OCL::Condp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Condp}{toString}
No Documentation Specified
\Class{Root::OCL}{Comprehension}
No Documentation Specified
\begin{Interface}
@Class Comprehension extends Object
  @Attribute body : OCL end
  @Attribute entries : Seq(CmpEntry) end
  @Attribute name : String end
end
\end{Interface}
\Class{Root::OCL}{CollExp}

      A collection expression represents sen-ding a message to a

      collection. The compiler knows about certain collection

      operations that get compiled to machine instructions. Otherwise

      a collection expression just sen-ds a message to the collection.
      Note that when the message has no arguments, the parentheses can

      be omitted.
      Constructor: CollExp(coll,collOp,operands)
        The coll argument is an expression whose value is a collection. the

        collOp is a string naming the message to se-nd, and the operands is

        a sequence of expressions.
\begin{Interface}
@Class CollExp extends OCL
  @Attribute args : Seq(OCL) end
  @Attribute collOp : String end
  @Attribute collection : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::CollExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::CollExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::CollExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::CollExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::CollExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::CollExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::CollExp}{toString}
No Documentation Specified
\Class{Root::OCL}{CmpCondition}
No Documentation Specified
\begin{Interface}
@Class CmpCondition extends CmpEntry
  @Attribute condition : OCL end
end
\end{Interface}
\Class{Root::OCL}{Dot}

      A dot expression is a slot navigation. The target of the dot can be any value.
      If the value is a collection then the dot operator is applied to each element

      of the collection and the resulting values are flattened if necessary. If the

      value is an object then the corresponding slot value is returned or an 
      error is signaled. If the value is not an object then either the machine knows

      how to resolve the slot reference or the message 'slot/1' is sent to the 
      value.
      
      Constructor: Dot(target,name)
        The target is an expression and the name is a symbol.
\begin{Interface}
@Class Dot extends OCL
  @Attribute name : String end
  @Attribute target : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Dot}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Dot}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Dot}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Dot}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Dot}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Dot}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Dot}{toString}
No Documentation Specified
\Class{Root::OCL}{Drop}

        A drop expression may occur within a lift expression [| ... |]. A lift

        expression is shorthand for the construction of an expression that will

        build the AST for the expression contained in the [| ... |]. Drop 
        expressions occur between < ... > in lift expressions, the syntax is not

        constructed for a drop expression, the expression is evaluated to produce a

        syntax value that is used at that point in the lift expression value being 
        constructed.
        
        Constructor: Drop(exp)
\begin{Interface}
@Class Drop extends OCL
  @Attribute exp : OCL end
  @Operation lift end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Drop}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Drop}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Drop}{toString}
No Documentation Specified
\Class{Root::OCL}{DropCollection}
No Documentation Specified
\begin{Interface}
@Class DropCollection extends OCL
  @Attribute exp : OCL end
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::OCL::DropCollection}{init}
No Documentation Specified
\Class{Root::OCL}{FunBinding}
No Documentation Specified
\begin{Interface}
@Class FunBinding extends Binding
  @Attribute args : Seq(Parameter) end
  @Attribute body : Performable end
  @Attribute type : Classifier end
end
\end{Interface}
\Class{Root::OCL}{ForSeq}
No Documentation Specified
\begin{Interface}
@Class ForSeq extends Object
end
\end{Interface}
\Class{Root::OCL}{For}
No Documentation Specified
\begin{Interface}
@Class For extends Object
end
\end{Interface}
\Class{Root::OCL}{FloatExp}

       A floating point constant.
\begin{Interface}
@Class FloatExp extends OCL
  @Attribute postPoint : Integer end
  @Attribute prePoint : Integer end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::FloatExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::FloatExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::FloatExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::FloatExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::FloatExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::FloatExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::FloatExp}{toString}
No Documentation Specified
\Class{Root::OCL}{HeadUpdate}
No Documentation Specified
\begin{Interface}
@Class HeadUpdate extends OCL
  @Attribute seq : Performable end
  @Attribute value : Performable end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::HeadUpdate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::HeadUpdate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::HeadUpdate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::HeadUpdate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::HeadUpdate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::HeadUpdate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::HeadUpdate}{toString}
No Documentation Specified
\Class{Root::OCL}{Iterate}

       An iteration expression is used to accumulate a value while

       processing each individual element from a collection in turn.
       Iteration expressions capture the common pattern that occurs where 
       we wish to incrementally build a value up, for example adding all

       the elements of a set. An iteration expression is the basis for all

       expressions such as 'collect', and 'forAll'. Iteration expressions

       are part of OCl and are slightly limited in the sense that there

       can only be one collection and one accumulation value. In general,
       XMF provides recursive operations to deal with more complex cases.
     
       Constructor: Iterate(coll,name,acc,value,body)
         Constructs an iterate expression from a collection valued expression,
         two strings naming the element variable and the accumulation variable,
         an initial value expression and a body expression.
\begin{Interface}
@Class Iterate extends OCL
  @Attribute accumulator : String end
  @Attribute body : OCL end
  @Attribute collection : OCL end
  @Attribute name : String end
  @Attribute value : OCL end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Iterate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Iterate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Iterate}{desugar}
No Documentation Specified
\ClassOperation{Root::OCL::Iterate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Iterate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Iterate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Iterate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Iterate}{toString}
No Documentation Specified
\Class{Root::OCL}{IterExp}

      An iter-exp selects values from a collection and performs a task.
      Tasks include mappings a collection to another collection by applying

      a function to each element or filtering a collection by applying a

      predicate to each element in turn.
      Iteration expressions have a general form:

        C->i(x | e)
      where C is a collection, i is the name of the iteration expression,
      x is a variable bound to elements of C and e is an expression. The variable

      x is scoped over e. XMF knows about the following iteration names:

        collect transforms a collection; each element is transformed to a new

          element produced by the corresponding evaluation of the body e. The resulting

          collection is of the same type as C.
        select filters a collection; the body of the iter-exp is a boolean

          values expression that controls whether or not the value is added to the 
          resulting collection. The resulting collection is of the same type as C.
        reject is the opposite of select.
        forAll returns true when the boolean valued expression e is true for all

          if the items in the collection. Otherwise returns false.
        exists returns true when the boolean valued expreession e is true for at

          least one of the items in the collection. Otherwise returns false.
        
     Constructor: IterExp(C,i,x,e)
       Returns a collection expression where C and e are expressions, i are x are strings.
\begin{Interface}
@Class IterExp extends OCL
  @Attribute body : OCL end
  @Attribute collection : OCL end
  @Attribute iterOp : String end
  @Attribute name : String end
  @Operation FV end
  @Operation compile end
  @Operation desugarSelect end
  @Operation desugar end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::IterExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{desugarSelect}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{desugar}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::IterExp}{toString}
No Documentation Specified
\Class{Root::OCL}{IntExp}

      An integer constant.
      Constructor: IntExp(value)
\begin{Interface}
@Class IntExp extends OCL
  @Attribute value : Integer end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::IntExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::IntExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::IntExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::IntExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::IntExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::IntExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::IntExp}{toString}
No Documentation Specified
\Class{Root::OCL}{Instantiate}

      An instantiation expression of the form C[x=M,y=N,...] creates an
      instance of C and sets the values of the slots named x, y, ... to 
      the values of the expressions N, M, ...
\begin{Interface}
@Class Instantiate extends OCL
  @Attribute args : Seq(KeyArg) end
  @Attribute class : Performable end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Instantiate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Instantiate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Instantiate}{desugar}
No Documentation Specified
\ClassOperation{Root::OCL::Instantiate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Instantiate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Instantiate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Instantiate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Instantiate}{toString}
No Documentation Specified
\Class{Root::OCL}{ImportIn}

      A namespace can be imported for the scope of an expression. The names in

      the name space are available in the expression. Note that if the names 
      are the same as lexically bound names currently in scope then the 
      lexically bound names take precedence.
      Constructor: ImportIn(nameSpace,body)
        The name space is an expression whose value is a name space and the

        body is an arbitrary expression.
\begin{Interface}
@Class ImportIn extends OCL
  @Attribute body : Performable end
  @Attribute nameSpace : Performable end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::ImportIn}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::ImportIn}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::ImportIn}{desugar}
No Documentation Specified
\ClassOperation{Root::OCL::ImportIn}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::ImportIn}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::ImportIn}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::ImportIn}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::ImportIn}{toString}
No Documentation Specified
\Class{Root::OCL}{If}

      A conditional expression evaluates a test expression and then performs one

      of two possible expressions depen-ding on whether the test produces 'true' or

      'false'.
      Constructor: If(test,then,else)
        Constructs a conditional expression.
\begin{Interface}
@Class If extends OCL
  @Attribute else : OCL end
  @Attribute then : OCL end
  @Attribute test : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation init end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::If}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::If}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::If}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::If}{init}
No Documentation Specified
\ClassOperation{Root::OCL::If}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::If}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::If}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::If}{toString}
No Documentation Specified
\Class{Root::OCL}{Keyp}

      A key pattern occurs in a keyword instantiation of the form C[x = M,...].
\begin{Interface}
@Class Keyp extends Object
  @Attribute name : String end
  @Attribute pattern : Pattern end
  @Operation bind end
  @Operation lift end
  @Operation matchCode end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Keyp}{bind}
No Documentation Specified
\ClassOperation{Root::OCL::Keyp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Keyp}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Keyp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Keyp}{toString}
No Documentation Specified
\Class{Root::OCL}{KeyArg}

      A key arg occurs in a keyword instantiation of the form C[x = M,...].
\begin{Interface}
@Class KeyArg extends Object
  @Attribute name : String end
  @Attribute value : Performable end
  @Operation lift end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::KeyArg}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::KeyArg}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::KeyArg}{toString}
No Documentation Specified
\Class{Root::OCL}{Keywordp}

      A keyword pattern consists of a class C and a sequence of key patterns:

      C[n1 = p1, n2 = p2, ...]. A value matches a keyword pattern when the value

      is an instance of the class and the value has slots for each name and when

      the values of the slots match the corresponding patterns.
\begin{Interface}
@Class Keywordp extends Pattern
  @Attribute class : String end
  @Attribute keys : Seq(Keyp) end
  @Attribute names : Seq(String) end
  @Operation bind end
  @Operation lift end
  @Operation matchKeys end
  @Operation matchCode end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Keywordp}{bind}
No Documentation Specified
\ClassOperation{Root::OCL::Keywordp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Keywordp}{matchKeys}
No Documentation Specified
\ClassOperation{Root::OCL::Keywordp}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Keywordp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Keywordp}{toString}
No Documentation Specified
\Class{Root::OCL}{Let}

      A 'let' expression allows local variables to be defined. The scope of any 
      'let' introduced variables is the body of the 'let' expression. Once thay

      are introduced, the variable sare local to the body and may be referenced 
      or updated. Let allows more than one 'binding' before the body in which

      case the bindings are separated using ';' or 'then'. Bindings separated with

      ';' established in parallel (i.e. the values cannot refer to the names in other 
      bindings) and bindings separated with 'then' are established in sequence.
      
      Constructor: Let(bindings,body)
        Constructs a 'let' expression. The bindings are a sequence of value bindings.
        The body is an expression.
\begin{Interface}
@Class Let extends OCL
  @Attribute body : OCL end
  @Attribute bindings : Seq(ValueBinding) end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Let}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Let}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Let}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Let}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Let}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Let}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Let}{toString}
No Documentation Specified
\Class{Root::OCL}{Lift}
No Documentation Specified
\begin{Interface}
@Class Lift extends OCL
  @Attribute exp : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation init end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::OCL::Lift}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Lift}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Lift}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Lift}{init}
No Documentation Specified
\ClassOperation{Root::OCL::Lift}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Lift}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Lift}{pprint}
No Documentation Specified
\Class{Root::OCL}{Letrec}
No Documentation Specified
\begin{Interface}
@Class Letrec extends OCL
  @Attribute body : Performable end
  @Attribute bindings : Seq(FunBinding) end
end
\end{Interface}
\Class{Root::OCL}{Negate}
No Documentation Specified
\begin{Interface}
@Class Negate extends OCL
  @Attribute exp : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Negate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Negate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Negate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Negate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Negate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Negate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Negate}{toString}
No Documentation Specified
\Class{Root::OCL}{Order}
No Documentation Specified
\begin{Interface}
@Class Order extends OCL
  @Attribute first : OCL end
  @Attribute second : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Order}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Order}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Order}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Order}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Order}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Order}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Order}{toString}
No Documentation Specified
\Class{Root::OCL}{Objectp}

      An object pattern consists of a class path and a sequence of patterns. The

      general form is C(p1,..,pn). A value matches an object pattern when it

      is an instance of C and when its slots match the patterns p1 to pn. In 
      order for the slots to match, the class C must define a constructor of

      arity n. this constructor defines a sequence of attribute names which in

      turn define the mapping from the slots of the value to the patterns. 
      
      Constructor: Objectp(nameSpace,names,slots)
        The name space is a string, the names are a sequence of names and slots

        is a sequence of expressions.
\begin{Interface}
@Class Objectp extends Pattern
  @Attribute class : String end
  @Attribute names : Seq(String) end
  @Attribute slots : Seq(Pattern) end
  @Operation bind end
  @Operation lift end
  @Operation matchSlots end
  @Operation matchCode end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::OCL::Objectp}{bind}
No Documentation Specified
\ClassOperation{Root::OCL::Objectp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Objectp}{matchSlots}
No Documentation Specified
\ClassOperation{Root::OCL::Objectp}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Objectp}{pprint}
No Documentation Specified
\Class{Root::OCL}{OCL}

        The OCL class is the root of the OCL AST class hierarchy. Note

        that this class is not the root of the XMF class hierarchy for

        abstract syntax constructs (i.e. things that can be performed).
        That class is EMOF::Performable; OCL is a sub-class of Performable.
\begin{Interface}
@Class OCL isabstract extends Performable
  @Operation FV end
  @Operation compile end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation pprint end
  @Operation pprint end
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::OCL::OCL}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::OCL}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::OCL}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::OCL}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::OCL}{pprint}

          To pprint an OCL expression produces its concrete source code representation

          in the output channel. The indent argument is used to control the current 
          level of indentation. It is the column to tab to after a newline while

          pprinting the receiver.
\ClassOperation{Root::OCL::OCL}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::OCL}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::OCL}{typeExp}
No Documentation Specified
\Class{Root::OCL}{Operation}

      An operation is a parameterized performable expression. An operation has a name,
      some parameters, a return type, a performable body and a documentation string. The

      class OCL::Operation defines the abstract syntax of an operation. When an instance

      of OCL::Operation is performed it is translated into an instance of EMOF::Operation

      (typically either a CompiledOperation or an InterpretedOperation). Typically you

      will not create an instance of OCL::Operation directly, rather you will use the

      concrete syntax @Operation ... en-d.
       
      Constructor: Operation(name,parameters,type,body)
        The name should be a string. The name 'anonymous' is used when we dont care

        what the name of the operation is. The parameters are supplied as a sequence of

        instances of EMOF::Parameter. The type is an expression that will return a classifier

        when it is performed. The body is a performable expression.
\begin{Interface}
@Class Operation extends OCL
  @Attribute documentation : Performable end
  @Attribute isMultiArgs : Boolean end
  @Attribute name : String end
  @Attribute performable : Performable end
  @Attribute parameters : Seq(Pattern) end
  @Attribute type : Performable end
  @Operation FV end
  @Operation arity end
  @Operation add end
  @Operation compile end
  @Operation doc end
  @Operation eval end
  @Operation liftParameters end
  @Operation lift end
  @Operation matchCode end
  @Operation maxLocals end
  @Operation newParams end
  @Operation paramList end
  @Operation pprint end
  @Operation setIsMultiArgs end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Operation}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{arity}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{add}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{compile}

      Compiles an operation in the supplied environment. The frame argument defines the level

      of lexical nesting scope for the operation where 0 is at the top level. The parameter

      names are added to the environment as local variables. We calculate the free variables

      of the operation and these are pushed onto the stack before the operation is created

      (using the MkOp instruction). The free variables will wind up in the globals list of the

      operation. The globals list of the new operation is linked to the globals list of 
      the lexically surrounding operation.
\ClassOperation{Root::OCL::Operation}{doc}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{liftParameters}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{newParams}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{paramList}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{setIsMultiArgs}
No Documentation Specified
\ClassOperation{Root::OCL::Operation}{toString}
No Documentation Specified
\Class{Root::OCL}{PathUpdate}
No Documentation Specified
\begin{Interface}
@Class PathUpdate extends OCL
  @Attribute path : Path end
  @Attribute value : Performable end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::PathUpdate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::PathUpdate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::PathUpdate}{desugar}
No Documentation Specified
\ClassOperation{Root::OCL::PathUpdate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::PathUpdate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::PathUpdate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::PathUpdate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::PathUpdate}{toString}
No Documentation Specified
\Class{Root::OCL}{Pattern}

      A pattern can occur in a binding position and is used to conditionally

      match values and bind variables to component values. A pattern is replaced

      with a variable, which it can be asked to generate and can be requested

      to translate itself into pattern matching code.
\begin{Interface}
@Class Pattern isabstract extends Object
  @Operation lift end
  @Operation matchCode end
  @Operation newVar end
  @Operation newParam end
  @Operation pprint end
  @Operation pprint end
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::OCL::Pattern}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Pattern}{matchCode}

         Produces executable code that checks whether value matches the

         receiver. The match may cause variables to be bound. If the

         match succeeds then the success code is performed, otherwise

         the fail code is performed.
\ClassOperation{Root::OCL::Pattern}{newVar}
No Documentation Specified
\ClassOperation{Root::OCL::Pattern}{newParam}

         By default a pattern will generate a new paremeter with a new var name.
         The parameter is used to contain the value that is matched against the

         pattern.
\ClassOperation{Root::OCL::Pattern}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Pattern}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Pattern}{typeExp}
No Documentation Specified
\Class{Root::OCL}{Path}
No Documentation Specified
\begin{Interface}
@Class Path extends OCL
  @Attribute names : Seq(Element) end
  @Attribute root : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Path}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Path}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Path}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Path}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Path}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Path}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Path}{toString}
No Documentation Specified
\Class{Root::OCL}{SlotUpdate}
No Documentation Specified
\begin{Interface}
@Class SlotUpdate extends OCL
  @Attribute name : String end
  @Attribute target : OCL end
  @Attribute value : OCL end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::SlotUpdate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::SlotUpdate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::SlotUpdate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::SlotUpdate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::SlotUpdate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::SlotUpdate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::SlotUpdate}{toString}
No Documentation Specified
\Class{Root::OCL}{Self}
No Documentation Specified
\begin{Interface}
@Class Self extends OCL
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::OCL::Self}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Self}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Self}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Self}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Self}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Self}{pprint}
No Documentation Specified
\Class{Root::OCL}{SetExp}
No Documentation Specified
\begin{Interface}
@Class SetExp extends OCL
  @Attribute collType : String end
  @Attribute elements : Seq(OCL) end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::SetExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::SetExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::SetExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::SetExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::SetExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::SetExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::SetExp}{toString}
No Documentation Specified
\Class{Root::OCL}{Send}
No Documentation Specified
\begin{Interface}
@Class Send extends OCL
  @Attribute args : Seq(OCL) end
  @Attribute message : String end
  @Attribute target : OCL end
  @Operation FV end
  @Operation compileSend end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Send}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Send}{compileSend}
No Documentation Specified
\ClassOperation{Root::OCL::Send}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Send}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Send}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Send}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Send}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Send}{toString}
No Documentation Specified
\Class{Root::OCL}{StrExp}
No Documentation Specified
\begin{Interface}
@Class StrExp extends OCL
  @Attribute value : String end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::StrExp}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::StrExp}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::StrExp}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::StrExp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::StrExp}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::StrExp}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::StrExp}{toString}
No Documentation Specified
\Class{Root::OCL}{Try}

       A try expression is used to capture exceptional events that occur during

       evaluation. The body of the try expression is performed and, if no exceptions

       are thrown during its evaluation, the body produces the value of the try.
       Otherwise a value is thrown by the body in which case the value is bound

       to the catch variable and a catch handler is performed. The catch handler

       may attempt to resolve the reason for the exception being raised in 
       which case it evaluates normally and produces tghe value of the try 
       expression. Otherwise the catch handler throws an exception value which is

       passed to the next most recently performed try.
\begin{Interface}
@Class Try extends OCL
  @Attribute body : Performable end
  @Attribute handler : Performable end
  @Attribute name : String end
  @Operation FV end
  @Operation compile end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Try}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Try}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Try}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Try}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Try}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Try}{toString}
No Documentation Specified
\Class{Root::OCL}{Throw}

      A throw expression throws a value to the most recently performed

      try expression. The value is bound to the catch-variable in the 
      try and the body of the catch is performed.
\begin{Interface}
@Class Throw extends OCL
  @Attribute exp : Performable end
  @Operation FV end
  @Operation compile end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Throw}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Throw}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Throw}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Throw}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Throw}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Throw}{toString}
No Documentation Specified
\Class{Root::OCL}{TailUpdate}
No Documentation Specified
\begin{Interface}
@Class TailUpdate extends OCL
  @Attribute seq : Performable end
  @Attribute value : Performable end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::TailUpdate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::TailUpdate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::TailUpdate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::TailUpdate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::TailUpdate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::TailUpdate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::TailUpdate}{toString}
No Documentation Specified
\Class{Root::OCL}{ValueBinding}
No Documentation Specified
\begin{Interface}
@Class ValueBinding extends Binding
  @Attribute value : OCL end
  @Operation lift end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::ValueBinding}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::ValueBinding}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::ValueBinding}{toString}
No Documentation Specified
\Class{Root::OCL}{Varp}

      A variable pattern is just a name and an optional type.
      Constructor: Varp(name,type)
        The name is a string and the type is an expression producing a classifier.
\begin{Interface}
@Class Varp extends Pattern
  @Attribute name : String end
  @Attribute type : Performable end
  @Operation bind end
  @Operation lift end
  @Operation matchCode end
  @Operation newVar end
  @Operation newParam end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::OCL::Varp}{bind}
No Documentation Specified
\ClassOperation{Root::OCL::Varp}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Varp}{matchCode}
No Documentation Specified
\ClassOperation{Root::OCL::Varp}{newVar}
No Documentation Specified
\ClassOperation{Root::OCL::Varp}{newParam}
No Documentation Specified
\ClassOperation{Root::OCL::Varp}{pprint}
No Documentation Specified
\Class{Root::OCL}{Var}
No Documentation Specified
\begin{Interface}
@Class Var extends OCL
  @Attribute charCount : Integer end
  @Attribute lineCount : Integer end
  @Attribute name : String end
  @Attribute sourceSet : Boolean end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::Var}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::Var}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::Var}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::Var}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::Var}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::Var}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::Var}{toString}
No Documentation Specified
\Class{Root::OCL}{VarUpdate}
No Documentation Specified
\begin{Interface}
@Class VarUpdate extends OCL
  @Attribute name : String end
  @Attribute value : Performable end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::OCL::VarUpdate}{FV}
No Documentation Specified
\ClassOperation{Root::OCL::VarUpdate}{compile}
No Documentation Specified
\ClassOperation{Root::OCL::VarUpdate}{eval}
No Documentation Specified
\ClassOperation{Root::OCL::VarUpdate}{lift}
No Documentation Specified
\ClassOperation{Root::OCL::VarUpdate}{maxLocals}
No Documentation Specified
\ClassOperation{Root::OCL::VarUpdate}{pprint}
No Documentation Specified
\ClassOperation{Root::OCL::VarUpdate}{toString}
No Documentation Specified
\Operation{Root::OCL}{update}
No Documentation Specified
\Package{Root}{Parser}
No Documentation Specified
\Package{Root::Parser}{BNF}
No Documentation Specified
\Class{Root::Parser::BNF}{Action}
No Documentation Specified
\begin{Interface}
@Class Action extends Recognizer
  @Attribute action : Element end
  @Attribute source : String end
  @Operation FV end
  @Operation code end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Action}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Action}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Action}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Action}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Action}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Action}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{And}
No Documentation Specified
\begin{Interface}
@Class And extends Recognizer
  @Attribute left : Recognizer end
  @Attribute right : Recognizer end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::And}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::And}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{At}
No Documentation Specified
\begin{Interface}
@Class At extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::At}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::At}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::At}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::At}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::At}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::At}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Bind}
No Documentation Specified
\begin{Interface}
@Class Bind extends Recognizer
  @Attribute name : String end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Bind}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Bind}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Bind}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Bind}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Bind}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Bind}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{BindGlobal}
No Documentation Specified
\begin{Interface}
@Class BindGlobal extends Recognizer
  @Attribute name : String end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::BindGlobal}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::BindGlobal}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::BindGlobal}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::BindGlobal}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::BindGlobal}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::BindGlobal}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Const}
No Documentation Specified
\begin{Interface}
@Class Const extends Recognizer
  @Attribute value : Element end
  @Operation FV end
  @Operation init end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Const}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Const}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Const}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Const}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Const}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Call}
No Documentation Specified
\begin{Interface}
@Class Call extends Recognizer
  @Attribute clause : Clause end
  @Attribute name : String end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Call}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Call}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Call}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Call}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Call}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Call}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Call}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Cut}
No Documentation Specified
\begin{Interface}
@Class Cut extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Cut}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Cut}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Cut}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Cut}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Cut}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Char}
No Documentation Specified
\begin{Interface}
@Class Char extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Char}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Char}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Char}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Char}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Char}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Char}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Clause}
No Documentation Specified
\begin{Interface}
@Class Clause extends NamedElement
  @Attribute body : Recognizer end
  @Operation code end
  @Operation call end
  @Operation init end
  @Operation lift end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Clause}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Clause}{call}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Clause}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Clause}{lift}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Clause}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Clause}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Clause}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Clause}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{EOF}
No Documentation Specified
\begin{Interface}
@Class EOF extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::EOF}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::EOF}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::EOF}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::EOF}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::EOF}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::EOF}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{EndAt}
No Documentation Specified
\begin{Interface}
@Class EndAt extends Recognizer
  @Attribute grammar : Element end
  @Attribute owner : Classifier end
  @Operation init end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::EndAt}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::EndAt}{parse}
No Documentation Specified
\Class{Root::Parser::BNF}{Fail}
No Documentation Specified
\begin{Interface}
@Class Fail extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Fail}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Fail}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Fail}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Fail}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Fail}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Grammar}

     A grammar is an owned element that describes how to recognise a sequence
     of characters and to synthesize values. grammars are extensible elements
     where clauses are inherited from the parents. Clauses with the same name
     are merged using 'or'. A grammar is performable because we want to define
     grammars as part of performable definitions. Therefore a grammar can be
     compiled into an expression that will create the grammar when it is performed.
     
     Constructor: Grammar(parents,clauses,startingSymbol,imports)
\begin{Interface}
@Class Grammar extends NameSpace,Performable
  @Attribute clauses : Set(Clause) end
  @Attribute dynamics : Seq(Element) end
  @Attribute debug : Boolean end
  @Attribute owner : Element end
  @Attribute parents : Set(Grammar) end
  @Attribute startingSymbol : String end
  @Attribute terminals : Set(String) end
  @Operation FV end
  @Operation allClauses end
  @Operation addClause end
  @Operation add end
  @Operation compile end
  @Operation call end
  @Operation cacheTerminals end
  @Operation getClause end
  @Operation init end
  @Operation inheritedTerminals end
  @Operation inheritedClauses end
  @Operation localTerminals end
  @Operation localClauses end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation pprint end
  @Operation transform end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Grammar}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{allClauses}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{addClause}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{add}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{compile}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{call}

          Call the nonterminal with respect to the current machine
          state. The grammar will have a single clause wih the given name
          or 'null' if no clause exists. Calling the clause is like calling
          a procedure. We get a new stack frame, we push a debugging fail
          choice that prints out diagnostics if we ever fail past this point,
          we push a success continuation that prints out diagnostics if we ever 
          succeed in completing the clause, we record the current fail state
          in case we ever invoke '!'. Finally we invoke the parser for the clause.
\ClassOperation{Root::Parser::BNF::Grammar}{cacheTerminals}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{getClause}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{inheritedTerminals}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{inheritedClauses}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{localTerminals}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{localClauses}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{lift}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{maxLocals}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{pprint}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{pprint}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Grammar}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{ImportAt}
No Documentation Specified
\begin{Interface}
@Class ImportAt extends Recognizer
  @Operation code end
  @Operation parse end
  @Operation toExp end
  @Operation transform end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::ImportAt}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::ImportAt}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::ImportAt}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::ImportAt}{transform}
No Documentation Specified
\Class{Root::Parser::BNF}{Int}
No Documentation Specified
\begin{Interface}
@Class Int extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Int}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Int}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Int}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Int}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Int}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Int}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Loop}
No Documentation Specified
\begin{Interface}
@Class Loop extends Recognizer
  @Attribute parser : Recognizer end
  @Attribute values : Seq(Element) end
  @Operation init end
  @Operation parse end
  @Operation setOwner end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Loop}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Loop}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Loop}{setOwner}
No Documentation Specified
\Class{Root::Parser::BNF}{Name}
No Documentation Specified
\begin{Interface}
@Class Name extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation toExp end
  @Operation transform end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Name}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Name}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Name}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Name}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Name}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Name}{transform}
No Documentation Specified
\Class{Root::Parser::BNF}{Not}
No Documentation Specified
\begin{Interface}
@Class Not extends Recognizer
  @Attribute parser : Recognizer end
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Not}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Not}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Not}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Not}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Not}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Not}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Not}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Not}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{NotSuccess}
No Documentation Specified
\begin{Interface}
@Class NotSuccess extends Recognizer
  @Attribute fail : MachineFail end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::NotSuccess}{parse}
No Documentation Specified
\Class{Root::Parser::BNF}{NewStack}
No Documentation Specified
\begin{Interface}
@Class NewStack extends Recognizer
  @Attribute locals : Element end
  @Attribute stack : Seq(Element) end
  @Operation init end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::NewStack}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::NewStack}{parse}
No Documentation Specified
\Class{Root::Parser::BNF}{Opt}
No Documentation Specified
\begin{Interface}
@Class Opt extends Recognizer
  @Attribute parser : Recognizer end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Opt}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Opt}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Opt}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Opt}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Opt}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Opt}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Opt}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Opt}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Or}
No Documentation Specified
\begin{Interface}
@Class Or extends Recognizer
  @Attribute left : Recognizer end
  @Attribute right : Recognizer end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Or}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Or}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{Predicate}

      A predicate is an arbitrary bool exp that
      can be invoked during a parse. The operation
      is supplied with the current state of the parse bindings.
      The predicate must return true or false that is used
      to determine whether the current parse proceeds or fails
      to the most recent backtrack point.
\begin{Interface}
@Class Predicate extends Recognizer
  @Attribute predicate : Element end
  @Attribute source : String end
  @Operation FV end
  @Operation code end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Predicate}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Predicate}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Predicate}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Predicate}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Predicate}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Predicate}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{PlusCons}
No Documentation Specified
\begin{Interface}
@Class PlusCons extends Recognizer
  @Attribute parser : Recognizer end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::PlusCons}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PlusCons}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{Plus}
No Documentation Specified
\begin{Interface}
@Class Plus extends Recognizer
  @Attribute parser : Recognizer end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Plus}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Plus}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{PrePredicate}
No Documentation Specified
\begin{Interface}
@Class PrePredicate extends Recognizer
  @Attribute boolExp : Performable end
  @Operation FV end
  @Operation body end
  @Operation code end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::PrePredicate}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PrePredicate}{body}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PrePredicate}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PrePredicate}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PrePredicate}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PrePredicate}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{PreAction}
No Documentation Specified
\begin{Interface}
@Class PreAction extends Recognizer
  @Attribute action : Element end
  @Operation FV end
  @Operation body end
  @Operation code end
  @Operation init end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::PreAction}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PreAction}{body}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PreAction}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PreAction}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PreAction}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PreAction}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::PreAction}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Recognizer}
No Documentation Specified
\begin{Interface}
@Class Recognizer isabstract extends Object
  @Operation FV end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Recognizer}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Recognizer}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Recognizer}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Recognizer}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Recognizer}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Recognizer}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Recognizer}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{StarCons}
No Documentation Specified
\begin{Interface}
@Class StarCons extends Recognizer
  @Attribute parser : Recognizer end
  @Attribute values : Seq(Element) end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::StarCons}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::StarCons}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::StarCons}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::StarCons}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::StarCons}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::StarCons}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::StarCons}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::StarCons}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Star}
No Documentation Specified
\begin{Interface}
@Class Star extends Recognizer
  @Attribute parser : Recognizer end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parse end
  @Operation setOwner end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Star}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{setOwner}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Star}{terminals}
No Documentation Specified
\Class{Root::Parser::BNF}{Str}
No Documentation Specified
\begin{Interface}
@Class Str extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Str}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Str}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Str}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Str}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Str}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Str}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Terminal}
No Documentation Specified
\begin{Interface}
@Class Terminal extends Recognizer
  @Attribute terminal : String end
  @Operation FV end
  @Operation code end
  @Operation init end
  @Operation nextSet end
  @Operation parseChars end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
  @Operation terminals end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Terminal}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{parseChars}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{terminals}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Terminal}{toString}
No Documentation Specified
\Class{Root::Parser::BNF}{Term}
No Documentation Specified
\begin{Interface}
@Class Term extends Str
  @Operation parse end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Term}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Term}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{TraceSuccess}
No Documentation Specified
\begin{Interface}
@Class TraceSuccess extends Recognizer
  @Attribute name : String end
  @Operation init end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::TraceSuccess}{init}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::TraceSuccess}{parse}
No Documentation Specified
\Class{Root::Parser::BNF}{Tok}
No Documentation Specified
\begin{Interface}
@Class Tok extends Recognizer
  @Operation FV end
  @Operation code end
  @Operation nextSet end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Tok}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Tok}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Tok}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Tok}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Tok}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::Tok}{toExp}
No Documentation Specified
\Class{Root::Parser::BNF}{Token}
No Documentation Specified
\begin{Interface}
@Class Token extends Object
  @Attribute chars : String end
  @Attribute charCount : Integer end
  @Attribute charPos : Integer end
  @Attribute data : Element end
  @Attribute lineCount : Integer end
  @Attribute type : Integer end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::Token}{toString}
No Documentation Specified
\Class{Root::Parser::BNF}{TypeCheck}
No Documentation Specified
\begin{Interface}
@Class TypeCheck extends Recognizer
  @Attribute type : Seq(String) end
  @Operation FV end
  @Operation code end
  @Operation parse end
  @Operation transform end
  @Operation toExp end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Parser::BNF::TypeCheck}{FV}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::TypeCheck}{code}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::TypeCheck}{parse}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::TypeCheck}{transform}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::TypeCheck}{toExp}
No Documentation Specified
\ClassOperation{Root::Parser::BNF::TypeCheck}{toString}
No Documentation Specified
\Package{Root::Parser}{Machine}

      This package defines the elements necessary to run the parsing
      machine. Create an instance of the class State and then invoke
      'run/0' or 'run/1' to parse the chars from an input channel.
\Class{Root::Parser::Machine}{BasicState}

      A basic state defines the essential information contained in a 
      machine state. It is abstract.
      
      Constructor: BasicState(grammar,inputChannel)
        Creates an initial machine state that uses grammar to parse the
        characters from the input stream.
\begin{Interface}
@Class BasicState isabstract extends Object
  @Attribute consumedChars : Integer end
  @Attribute cut : Seq(Fail) end
  @Attribute fail : Fail end
  @Attribute globals : Env end
  @Attribute grammar : Grammar end
  @Attribute imports : Seq(NameSpace) end
  @Attribute indent : Integer end
  @Attribute inputChannel : InputChannel end
  @Attribute locals : Env end
  @Attribute owner : Element end
  @Attribute stack : Seq(Element) end
  @Attribute successes : Seq(Recognizer) end
  @Attribute token : Seq(Element) end
  @Attribute tokenChannel : Element end
  @Attribute tokens : Element end
  @Operation atNameSpace end
  @Operation atClassifier end
  @Operation at end
  @Operation char end
  @Operation init end
  @Operation importAt end
  @Operation resetTokens end
  @Operation resetInputChannel end
  @Operation rawTextToCharChannel end
  @Operation tokenChannelToCharChannel end
  @Operation tokenStream end
  @Operation tokens end
end
\end{Interface}
\ClassOperation{Root::Parser::Machine::BasicState}{atNameSpace}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{atClassifier}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{at}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{char}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{init}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{importAt}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{resetTokens}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{resetInputChannel}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{rawTextToCharChannel}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{tokenChannelToCharChannel}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{tokenStream}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::BasicState}{tokens}
No Documentation Specified
\Class{Root::Parser::Machine}{Fail}
No Documentation Specified
\begin{Interface}
@Class Fail isabstract extends Object
  @Operation fail end
end
\end{Interface}
\ClassOperation{Root::Parser::Machine::Fail}{fail}
No Documentation Specified
\Class{Root::Parser::Machine}{InitialFail}
No Documentation Specified
\begin{Interface}
@Class InitialFail extends Fail
  @Operation fail end
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::Parser::Machine::InitialFail}{fail}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::InitialFail}{init}
No Documentation Specified
\Class{Root::Parser::Machine}{MachineFail}
No Documentation Specified
\begin{Interface}
@Class MachineFail extends Fail,BasicState
  @Operation fail end
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::Parser::Machine::MachineFail}{fail}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::MachineFail}{init}
No Documentation Specified
\Class{Root::Parser::Machine}{State}

       A machine state contains all information to execute a parse. The
       parse proceeds by making machine state transitions.
\begin{Interface}
@Class State extends BasicState
  @Attribute failed : Boolean end
  @Attribute parses : Integer end
  @Operation bindsGlobal end
  @Operation bindGlobal end
  @Operation binds end
  @Operation bind end
  @Operation cut end
  @Operation choice end
  @Operation choice end
  @Operation call end
  @Operation decIndent end
  @Operation debugs end
  @Operation debug end
  @Operation debug end
  @Operation eof end
  @Operation env end
  @Operation fail end
  @Operation getClause end
  @Operation isTerminal end
  @Operation incIndent end
  @Operation lookupGlobal end
  @Operation lookup end
  @Operation nextSet end
  @Operation next end
  @Operation newStack end
  @Operation pushTraceSuccess end
  @Operation pushTraceFail end
  @Operation pushSuccess end
  @Operation pushStack end
  @Operation pushEndAt end
  @Operation popCut end
  @Operation pushCut end
  @Operation printConsumedChars end
  @Operation popSuccess end
  @Operation popStack end
  @Operation parseError end
  @Operation runToCompletion end
  @Operation run end
  @Operation run end
  @Operation reset end
  @Operation startAt end
  @Operation stackTop end
  @Operation terminal end
  @Operation typeCheck end
end
\end{Interface}
\ClassOperation{Root::Parser::Machine::State}{bindsGlobal}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{bindGlobal}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{binds}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{bind}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{cut}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{choice}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{choice}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{call}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{decIndent}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{debugs}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{debug}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{debug}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{eof}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{env}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{fail}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{getClause}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{isTerminal}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{incIndent}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{lookupGlobal}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{lookup}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{nextSet}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{next}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{newStack}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{pushTraceSuccess}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{pushTraceFail}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{pushSuccess}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{pushStack}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{pushEndAt}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{popCut}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{pushCut}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{printConsumedChars}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{popSuccess}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{popStack}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{parseError}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{runToCompletion}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{run}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{run}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{reset}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{startAt}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{stackTop}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{terminal}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::State}{typeCheck}
No Documentation Specified
\Class{Root::Parser::Machine}{TraceFail}
No Documentation Specified
\begin{Interface}
@Class TraceFail extends Fail
  @Attribute fail : Fail end
  @Attribute name : String end
  @Operation fail end
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::Parser::Machine::TraceFail}{fail}
No Documentation Specified
\ClassOperation{Root::Parser::Machine::TraceFail}{init}
No Documentation Specified
\Class{Root}{Sheet}

      A sheet is a heterogeneous 2-d table of elements. The elements of the
      sheet are indexed by row and column. Each element may be of a different
      type that is defined by the type map.
\begin{Interface}
@Class Sheet extends Object
  @Attribute cols : Seq(Element) end
  @Attribute data : Array('Element') end
  @Attribute inspectWidth : Integer end
  @Attribute map : Operation end
  @Attribute rows : Seq(Element) end
  @Operation colIndex end
  @Operation getCell end
  @Operation hasRow end
  @Operation hasCol end
  @Operation hasCell end
  @Operation inspectDialog end
  @Operation initCells end
  @Operation pprintLine end
  @Operation pprint end
  @Operation rowIndex end
  @Operation setCell end
  @Operation toString end
  @Operation type end
end
\end{Interface}
\ClassOperation{Root::Sheet}{colIndex}
No Documentation Specified
\ClassOperation{Root::Sheet}{getCell}
No Documentation Specified
\ClassOperation{Root::Sheet}{hasRow}
No Documentation Specified
\ClassOperation{Root::Sheet}{hasCol}
No Documentation Specified
\ClassOperation{Root::Sheet}{hasCell}
No Documentation Specified
\ClassOperation{Root::Sheet}{inspectDialog}
No Documentation Specified
\ClassOperation{Root::Sheet}{initCells}

        Initialise the sheet with the cell values. Values is a sequence of
        rows. Each row is a sequence of values. Returns the receiver.
\ClassOperation{Root::Sheet}{pprintLine}
No Documentation Specified
\ClassOperation{Root::Sheet}{pprint}
No Documentation Specified
\ClassOperation{Root::Sheet}{rowIndex}
No Documentation Specified
\ClassOperation{Root::Sheet}{setCell}

        Sets the value of the cell indexed by (row,col).
        Returns the receiver.
\ClassOperation{Root::Sheet}{toString}
No Documentation Specified
\ClassOperation{Root::Sheet}{type}
No Documentation Specified
\Package{Root}{Stacks}
Stack related classes.
\Class{Root::Stacks}{Queue}

      A standard FIFO stack. The queue grows to accommodate
      elements as they are added.
\begin{Interface}
@Class Queue extends Object
  @Attribute elements : Vector end
  @Attribute first : Integer end
  @Attribute last : Integer end
  @Operation asSeq end
  @Operation empty end
  @Operation expand end
  @Operation isFull end
  @Operation isEmpty end
  @Operation indexOf end
  @Operation put end
  @Operation push end
  @Operation pop end
  @Operation ref end
  @Operation size end
  @Operation topIndex end
  @Operation top end
end
\end{Interface}
\ClassOperation{Root::Stacks::Queue}{asSeq}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{empty}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{expand}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{isFull}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{isEmpty}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{indexOf}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{put}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{push}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{pop}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{ref}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{size}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{topIndex}
No Documentation Specified
\ClassOperation{Root::Stacks::Queue}{top}
No Documentation Specified
\Class{Root::Stacks}{Stack}

      A standard LIFO stack. The stack grows to accommodate
      elements as they are added.
\begin{Interface}
@Class Stack extends Object
  @Attribute elements : Vector end
  @Attribute index : Integer end
  @Operation asSeq end
  @Operation empty end
  @Operation expand end
  @Operation isFull end
  @Operation isEmpty end
  @Operation indexOf end
  @Operation put end
  @Operation push end
  @Operation pop end
  @Operation ref end
  @Operation size end
  @Operation topIndex end
  @Operation top end
end
\end{Interface}
\ClassOperation{Root::Stacks::Stack}{asSeq}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{empty}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{expand}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{isFull}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{isEmpty}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{indexOf}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{put}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{push}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{pop}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{ref}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{size}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{topIndex}
No Documentation Specified
\ClassOperation{Root::Stacks::Stack}{top}
No Documentation Specified
\Class{Root::Stacks}{StackUnderflow}
No Documentation Specified
\begin{Interface}
@Class StackUnderflow extends Exception
  @Attribute stack : Stack end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Stacks::StackUnderflow}{toString}
No Documentation Specified
\Package{Root}{TopLevel}

      The top level package defines data and operations that control
      the top level loop for XMF.
\Class{Root::TopLevel}{Command}

      A top level command is typed at a top level loop and is
      preceded by '?'. A command is a name optionally followed
      by some arguments. If arguments are present then they must
      be terminated by ';'. Each argument is an expression.
\begin{Interface}
@Class Command extends Performable
  @Attribute args : Seq(String) end
  @Attribute command : String end
  @Attribute name : String end
  @Operation eval end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::TopLevel::Command}{eval}
No Documentation Specified
\ClassOperation{Root::TopLevel::Command}{toString}
No Documentation Specified
\Class{Root::TopLevel}{Loop}

       Create an instance of Loop and supply an input channel.
       This returns a command interpreter for the input channel.
       Start the command interpreter using 'loop/0'. The attributes
       of the class control the context and behaviour of the 
       command interpreter.
\begin{Interface}
@Class Loop extends Object
  @Attribute env : Env end
  @Attribute grammar : Grammar end
  @Attribute imports : Seq(NameSpace) end
  @Attribute inputChannel : InputChannel end
  @Attribute outputChannel : OutputChannel end
  @Attribute printBanner : Boolean end
  @Attribute prompt : String end
  @Attribute returnValue : Element end
  @Attribute startNT : String end
  @Attribute terminated : Boolean end
  @Attribute target : Element end
  @Operation exitOperation end
  @Operation handleException end
  @Operation loopEnv end
  @Operation loop end
  @Operation printBanner end
  @Operation returnOperation end
  @Operation readEvalPrint end
  @Operation setPrintBanner end
  @Operation setStartNT end
  @Operation setGrammar end
  @Operation setImports end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::TopLevel::Loop}{exitOperation}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{handleException}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{loopEnv}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{loop}

         Start the command interpreter. The interpreter will continually
         parse input from the input channel using the supplied grammar and
         starting non terminal. Each command must be performable - it is
         interpreted using 'eval/3'. The value is then printed. Any errors
         are trapped and a backtrace is printed. Use 'exit/0' to leave the
         loop and 'return/1' to exit and return a specific value.
\ClassOperation{Root::TopLevel::Loop}{printBanner}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{returnOperation}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{readEvalPrint}

         Read a command from the input channel, parse using the grammar
         eval and then print out the result.
\ClassOperation{Root::TopLevel::Loop}{setPrintBanner}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{setStartNT}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{setGrammar}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{setImports}
No Documentation Specified
\ClassOperation{Root::TopLevel::Loop}{toString}
No Documentation Specified
\Class{Root}{Version}

      This class defines operations that manage the version information
      maintained in the file Boot/verison.xml.
\begin{Interface}
@Class Version extends Object
  @Attribute XMF : Element end
  @Attribute delta : Element end
  @Attribute document : Document end
  @Attribute new : Boolean end
  @Attribute release : Element end
  @Attribute silent : Boolean end
  @Attribute version : Element end
  @Operation dialog end
  @Operation deltaId end
  @Operation incDelta end
  @Operation loadVersion end
  @Operation newVersion end
  @Operation newRelease end
  @Operation newVersionDialog end
  @Operation newReleaseDialog end
  @Operation newDeltaDialog end
  @Operation newDelta end
  @Operation releaseId end
  @Operation setXMF end
  @Operation setVersion end
  @Operation setRelease end
  @Operation setDelta end
  @Operation versionId end
  @Operation version end
  @Operation writeVersion end
end
\end{Interface}
\ClassOperation{Root::Version}{dialog}
No Documentation Specified
\ClassOperation{Root::Version}{deltaId}
No Documentation Specified
\ClassOperation{Root::Version}{incDelta}
No Documentation Specified
\ClassOperation{Root::Version}{loadVersion}
No Documentation Specified
\ClassOperation{Root::Version}{newVersion}
No Documentation Specified
\ClassOperation{Root::Version}{newRelease}
No Documentation Specified
\ClassOperation{Root::Version}{newVersionDialog}
No Documentation Specified
\ClassOperation{Root::Version}{newReleaseDialog}
No Documentation Specified
\ClassOperation{Root::Version}{newDeltaDialog}
No Documentation Specified
\ClassOperation{Root::Version}{newDelta}
No Documentation Specified
\ClassOperation{Root::Version}{releaseId}
No Documentation Specified
\ClassOperation{Root::Version}{setXMF}
No Documentation Specified
\ClassOperation{Root::Version}{setVersion}
No Documentation Specified
\ClassOperation{Root::Version}{setRelease}
No Documentation Specified
\ClassOperation{Root::Version}{setDelta}
No Documentation Specified
\ClassOperation{Root::Version}{versionId}
No Documentation Specified
\ClassOperation{Root::Version}{version}
No Documentation Specified
\ClassOperation{Root::Version}{writeVersion}
No Documentation Specified
\Package{Root}{Walkers}

      The Walkers package defines the abstract class Walker and a number
      of useful instances and extensions. An element walker is used to walk
      an arbitrary value and perform a task. The walker will handle cycles in
      the structure of the element. For example, a walker may be used to search
      a value, or collect information about its contents.
\Class{Root::Walkers}{Dispatcher}

       A dispatcher, like a walker, passes over an element performing a
       task. The difference between a dispatcher and a walker is that 
       the dispatcher can be programmed on a type-by-type basis and then
       dispatches to handlers whereas the types in a walker are fixed.
       A walker may be slightly more efficient, but less extensible and
       modular.
\begin{Interface}
@Class Dispatcher extends Class
  @Attribute cache : Table end
  @Attribute handlers : Seq(Handler) end
  @Operation addHandler end
  @Operation add end
  @Operation dispatch end
  @Operation defaultParents end
  @Operation getHandler end
  @Operation orderHandlers end
end
\end{Interface}
\ClassOperation{Root::Walkers::Dispatcher}{addHandler}
No Documentation Specified
\ClassOperation{Root::Walkers::Dispatcher}{add}
No Documentation Specified
\ClassOperation{Root::Walkers::Dispatcher}{dispatch}
No Documentation Specified
\ClassOperation{Root::Walkers::Dispatcher}{defaultParents}
No Documentation Specified
\ClassOperation{Root::Walkers::Dispatcher}{getHandler}
No Documentation Specified
\ClassOperation{Root::Walkers::Dispatcher}{orderHandlers}
No Documentation Specified
\Class{Root::Walkers}{DispatchingObject}
No Documentation Specified
\begin{Interface}
@Class DispatchingObject extends Object
  @Attribute table : Table end
  @Attribute visited : Integer end
  @Operation dispatch end
  @Operation encountered end
  @Operation encounter end
  @Operation reset end
  @Operation visited end
end
\end{Interface}
\ClassOperation{Root::Walkers::DispatchingObject}{dispatch}
No Documentation Specified
\ClassOperation{Root::Walkers::DispatchingObject}{encountered}
No Documentation Specified
\ClassOperation{Root::Walkers::DispatchingObject}{encounter}
No Documentation Specified
\ClassOperation{Root::Walkers::DispatchingObject}{reset}
No Documentation Specified
\ClassOperation{Root::Walkers::DispatchingObject}{visited}
No Documentation Specified
\Class{Root::Walkers}{DispatchError}
No Documentation Specified
\begin{Interface}
@Class DispatchError extends Exception
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Walkers::DispatchError}{toString}
No Documentation Specified
\Class{Root::Walkers}{Find}

      An instance of this class can be used to find all element in a given XMF
      value that satisfy the supplied predicate.
\begin{Interface}
@Class Find extends Walker
  @Attribute predicate : Operation end
  @Attribute results : Set(Element) end
  @Operation addToResults end
  @Operation defaultWalk end
  @Operation reWalk end
  @Operation results end
  @Operation toString end
  @Operation walkTable end
  @Operation walkString end
  @Operation walkSlot end
  @Operation walkSet end
  @Operation walkSeq end
  @Operation walkPostObject end
  @Operation walkPreObject end
  @Operation walkOperation end
  @Operation walkNull end
  @Operation walkInteger end
  @Operation walkBoolean end
  @Operation walk end
end
\end{Interface}
\ClassOperation{Root::Walkers::Find}{addToResults}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{defaultWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{reWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{results}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{toString}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkTable}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkString}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkSlot}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkSet}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkSeq}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkPostObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkPreObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkOperation}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkNull}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkInteger}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walkBoolean}
No Documentation Specified
\ClassOperation{Root::Walkers::Find}{walk}
No Documentation Specified
\Class{Root::Walkers}{Handler}

      A dispatch handler defines the code that is performed when a particular
      type of value is walked. The form of a handler is:
      @Handler <TYPE> in <DISP> (<VALUE>,<ARG>,<ENCOUNTER>) <EXP> en-d
      here the handler is invoked when a value of the given type is
      walked. The DISP expression defines the dispatcher object to which
      the handler is added. The names VALUE ARG and ENCOUNTER are bound to
      the walked object, the walker argument (often null) and whether this
      is a subsequent encounter or not.
\begin{Interface}
@Class Handler extends Object
  @Attribute handler : Operation end
  @Attribute type : Classifier end
  @Operation handler end
  @Operation inheritsFrom end
  @Operation toString end
  @Operation type end
end
\end{Interface}
\ClassOperation{Root::Walkers::Handler}{handler}
No Documentation Specified
\ClassOperation{Root::Walkers::Handler}{inheritsFrom}
No Documentation Specified
\ClassOperation{Root::Walkers::Handler}{toString}
No Documentation Specified
\ClassOperation{Root::Walkers::Handler}{type}
No Documentation Specified
\Class{Root::Walkers}{Lift}
No Documentation Specified
\begin{Interface}
@Class Lift extends DispatchingObject
  @Attribute stack : Stack end
  @Attribute varCount : Integer end
  @Operation newVar end
  @Operation newExp end
end
\end{Interface}
\ClassOperation{Root::Walkers::Lift}{newVar}
No Documentation Specified
\ClassOperation{Root::Walkers::Lift}{newExp}
No Documentation Specified
\Class{Root::Walkers}{RelinkOwner}
No Documentation Specified
\begin{Interface}
@Class RelinkOwner extends Walker
  @Operation defaultWalk end
  @Operation reWalk end
  @Operation walkTable end
  @Operation walkString end
  @Operation walkSlot end
  @Operation walkSet end
  @Operation walkSeq end
  @Operation walkPostObject end
  @Operation walkPreObject end
  @Operation walkObject end
  @Operation walkOperation end
  @Operation walkNull end
  @Operation walkInteger end
  @Operation walkBoolean end
end
\end{Interface}
\ClassOperation{Root::Walkers::RelinkOwner}{defaultWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{reWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkTable}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkString}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkSlot}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkSet}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkSeq}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkPostObject}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkPreObject}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkObject}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkOperation}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkNull}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkInteger}
No Documentation Specified
\ClassOperation{Root::Walkers::RelinkOwner}{walkBoolean}
No Documentation Specified
\Class{Root::Walkers}{Subst}

      A substitution walks over an XMF value and replaces all occurrences
      of an 'old' value with a 'new' value. The updated value is returned.
\begin{Interface}
@Class Subst extends Walker
  @Attribute new : Element end
  @Attribute old : Element end
  @Operation defaultWalk end
  @Operation reWalk end
  @Operation toString end
  @Operation walkTable end
  @Operation walkString end
  @Operation walkSlot end
  @Operation walkSet end
  @Operation walkSeq end
  @Operation walkPostObject end
  @Operation walkPreObject end
  @Operation walkOperation end
  @Operation walkObject end
  @Operation walkNull end
  @Operation walkInteger end
  @Operation walkBoolean end
  @Operation walk end
end
\end{Interface}
\ClassOperation{Root::Walkers::Subst}{defaultWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{reWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{toString}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkTable}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkString}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkSlot}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkSet}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkSeq}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkPostObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkPreObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkOperation}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkNull}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkInteger}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walkBoolean}
No Documentation Specified
\ClassOperation{Root::Walkers::Subst}{walk}
No Documentation Specified
\Class{Root::Walkers}{TypeCheckError}
No Documentation Specified
\begin{Interface}
@Class TypeCheckError extends Exception
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Walkers::TypeCheckError}{toString}
No Documentation Specified
\Class{Root::Walkers}{TypeCheckReport}
No Documentation Specified
\begin{Interface}
@Class TypeCheckReport extends Object
  @Attribute name : String end
  @Attribute ok : Boolean end
  @Attribute object : Object end
  @Attribute type : Classifier end
  @Attribute value : Element end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::Walkers::TypeCheckReport}{toString}
No Documentation Specified
\Class{Root::Walkers}{TypeChecker}
No Documentation Specified
\begin{Interface}
@Class TypeChecker extends Walker
  @Attribute justFailures : Boolean end
  @Attribute reports : Set(TypeCheckReport) end
  @Operation addToReports end
  @Operation defaultWalk end
  @Operation reWalk end
  @Operation toString end
  @Operation walkTable end
  @Operation walkString end
  @Operation walkSlot end
  @Operation walkSet end
  @Operation walkSeq end
  @Operation walkPostObject end
  @Operation walkPreObject end
  @Operation walkOperation end
  @Operation walkNull end
  @Operation walkInteger end
  @Operation walkBoolean end
end
\end{Interface}
\ClassOperation{Root::Walkers::TypeChecker}{addToReports}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{defaultWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{reWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{toString}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkTable}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkString}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkSlot}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkSet}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkSeq}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkPostObject}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkPreObject}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkOperation}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkNull}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkInteger}
No Documentation Specified
\ClassOperation{Root::Walkers::TypeChecker}{walkBoolean}
No Documentation Specified
\Class{Root::Walkers}{Walker}

      An element walker is used to perform some arbitrary task over the
      structure of a value. A walker recursively descen-ds into an elements
      structure and dispatches to appropriate operations depen-ding on the
      values of component elements. A walker handles cycles in a value by
      dispatching to a special operation after an element has been encountered
      for the first time. To create your own walker you should specialise this
      class or one of its descen-dants and implement the abstract operations
      or override the provided operations.
\begin{Interface}
@Class Walker isabstract extends Object
  @Attribute refCount : Integer end
  @Attribute table : Table end
  @Attribute visited : Integer end
  @Operation defaultWalk end
  @Operation encountered end
  @Operation encounter end
  @Operation encounter end
  @Operation getRef end
  @Operation initWalker end
  @Operation newRef end
  @Operation reWalk end
  @Operation reset end
  @Operation visited end
  @Operation walkTable end
  @Operation walkString end
  @Operation walkSlot end
  @Operation walkSet end
  @Operation walkSeq end
  @Operation walkOperation end
  @Operation walkPostObject end
  @Operation walkPreObject end
  @Operation walkNull end
  @Operation walkInteger end
  @Operation walkBoolean end
  @Operation walkObject end
  @Operation walk end
end
\end{Interface}
\ClassOperation{Root::Walkers::Walker}{defaultWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{encountered}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{encounter}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{encounter}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{getRef}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{initWalker}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{newRef}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{reWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{reset}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{visited}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkTable}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkString}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkSlot}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkSet}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkSeq}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkOperation}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkPostObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkPreObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkNull}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkInteger}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkBoolean}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walkObject}
No Documentation Specified
\ClassOperation{Root::Walkers::Walker}{walk}
No Documentation Specified
\Class{Root::Walkers}{XML}
No Documentation Specified
\begin{Interface}
@Class XML extends Walker
  @Operation defaultWalk end
  @Operation reWalk end
  @Operation walkTable end
  @Operation walkString end
  @Operation walkSlot end
  @Operation walkSet end
  @Operation walkSeq end
  @Operation walkRef end
  @Operation walkPostObject end
  @Operation walkPreObject end
  @Operation walkOperation end
  @Operation walkNull end
  @Operation walkInteger end
  @Operation walkBoolean end
end
\end{Interface}
\ClassOperation{Root::Walkers::XML}{defaultWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{reWalk}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkTable}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkString}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkSlot}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkSet}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkSeq}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkRef}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkPostObject}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkPreObject}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkOperation}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkNull}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkInteger}
No Documentation Specified
\ClassOperation{Root::Walkers::XML}{walkBoolean}
No Documentation Specified
\Class{Root}{XMF}
No Documentation Specified
\begin{Interface}
@Class XMF extends Object
  @Attribute buildDate : String end
  @Attribute clientManager : ClientManager end
  @Attribute homeDir : String end
  @Attribute version : String end
  @Operation buildDate end
  @Operation docDir end
  @Operation date end
  @Operation homeDir end
  @Operation load end
  @Operation setVersion end
  @Operation setHomeDir end
  @Operation saveDir end
  @Operation toString end
  @Operation version end
end
\end{Interface}
\ClassOperation{Root::XMF}{buildDate}
No Documentation Specified
\ClassOperation{Root::XMF}{docDir}
No Documentation Specified
\ClassOperation{Root::XMF}{date}
No Documentation Specified
\ClassOperation{Root::XMF}{homeDir}
No Documentation Specified
\ClassOperation{Root::XMF}{load}
No Documentation Specified
\ClassOperation{Root::XMF}{setVersion}
No Documentation Specified
\ClassOperation{Root::XMF}{setHomeDir}
No Documentation Specified
\ClassOperation{Root::XMF}{saveDir}
No Documentation Specified
\ClassOperation{Root::XMF}{toString}
No Documentation Specified
\ClassOperation{Root::XMF}{version}
No Documentation Specified
\Package{Root}{XML}

      The XML package defines classes that are used to represent XML documents.
\Class{Root::XML}{Attribute}

      An XML element attribute. The name and the value are both strings.
\begin{Interface}
@Class Attribute extends Object
  @Attribute name : String end
  @Attribute value : String end
  @Operation print end
  @Operation setValue end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Attribute}{print}
No Documentation Specified
\ClassOperation{Root::XML::Attribute}{setValue}
No Documentation Specified
\ClassOperation{Root::XML::Attribute}{toString}
No Documentation Specified
\Class{Root::XML}{Document}

      An XML document. Typically an XML document has been produced from a file

      and the resourceName of the document should define the file. A document

      has a root which is an XML node. A document that conforms to XMF.dtd can

      be reduced to form an XMF data value. Documents can be printed to an 
      output channel.
\begin{Interface}
@Class Document extends Resource
  @Attribute root : Node end
  @Operation print end
  @Operation print end
  @Operation pprint end
  @Operation root end
  @Operation reduce end
  @Operation setRoot end
  @Operation stripWhiteSpace end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Document}{print}
No Documentation Specified
\ClassOperation{Root::XML::Document}{print}
No Documentation Specified
\ClassOperation{Root::XML::Document}{pprint}

        Prints out the XML document using indentation to

        show nesting. The output is sent to the supplied

        output channel.
\ClassOperation{Root::XML::Document}{root}
No Documentation Specified
\ClassOperation{Root::XML::Document}{reduce}
No Documentation Specified
\ClassOperation{Root::XML::Document}{setRoot}
No Documentation Specified
\ClassOperation{Root::XML::Document}{stripWhiteSpace}

        When reading formatted XML documents the shitespace can be left

        as text elements. This operation returns a copy of the receiver

        with the whitespace removed.
\ClassOperation{Root::XML::Document}{toString}
No Documentation Specified
\Class{Root::XML}{Element}

      An XML element has a tag, some attributes and some children. Use 'get/1' to

      access the attribute values by name. If the element conforms to XMF.dtd then

      it can be reduced to an XMF data value using 'reduce/1' where the argument

      is a table of element identifiers to XMF data values.
\begin{Interface}
@Class Element extends Node
  @Attribute attributes : Set(Attribute) end
  @Attribute children : Seq(Node) end
  @Attribute tag : String end
  @Operation addToChildren end
  @Operation children end
  @Operation deleteFromChildren end
  @Operation filter end
  @Operation getAtt end
  @Operation hasAtt end
  @Operation isWhiteSpace end
  @Operation nameSpaceRef end
  @Operation put end
  @Operation print end
  @Operation pprint end
  @Operation reduceSlot end
  @Operation reduceSet end
  @Operation reduceSeq end
  @Operation reduceObject end
  @Operation reduceRef end
  @Operation reduce end
  @Operation setChildren end
  @Operation setTag end
  @Operation stripWhiteSpace end
  @Operation toString end
  @Operation tag end
end
\end{Interface}
\ClassOperation{Root::XML::Element}{addToChildren}
No Documentation Specified
\ClassOperation{Root::XML::Element}{children}
No Documentation Specified
\ClassOperation{Root::XML::Element}{deleteFromChildren}
No Documentation Specified
\ClassOperation{Root::XML::Element}{filter}
No Documentation Specified
\ClassOperation{Root::XML::Element}{getAtt}
No Documentation Specified
\ClassOperation{Root::XML::Element}{hasAtt}
No Documentation Specified
\ClassOperation{Root::XML::Element}{isWhiteSpace}
No Documentation Specified
\ClassOperation{Root::XML::Element}{nameSpaceRef}
No Documentation Specified
\ClassOperation{Root::XML::Element}{put}
No Documentation Specified
\ClassOperation{Root::XML::Element}{print}
No Documentation Specified
\ClassOperation{Root::XML::Element}{pprint}
No Documentation Specified
\ClassOperation{Root::XML::Element}{reduceSlot}
No Documentation Specified
\ClassOperation{Root::XML::Element}{reduceSet}
No Documentation Specified
\ClassOperation{Root::XML::Element}{reduceSeq}
No Documentation Specified
\ClassOperation{Root::XML::Element}{reduceObject}
No Documentation Specified
\ClassOperation{Root::XML::Element}{reduceRef}
No Documentation Specified
\ClassOperation{Root::XML::Element}{reduce}
No Documentation Specified
\ClassOperation{Root::XML::Element}{setChildren}
No Documentation Specified
\ClassOperation{Root::XML::Element}{setTag}
No Documentation Specified
\ClassOperation{Root::XML::Element}{stripWhiteSpace}
No Documentation Specified
\ClassOperation{Root::XML::Element}{toString}
No Documentation Specified
\ClassOperation{Root::XML::Element}{tag}
No Documentation Specified
\Class{Root::XML}{ExpectingTag}

      This exception is raised when element processing expects an element

      with a given tag and when the received node does not match.
\begin{Interface}
@Class ExpectingTag extends Exception
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::XML::ExpectingTag}{init}
No Documentation Specified
\Package{Root::XML}{Generator}

      This package provides language features for defining rules
      that translate instances of classes to XML.
\Class{Root::XML::Generator}{AttributeMap}
No Documentation Specified
\begin{Interface}
@Class AttributeMap extends Sugar
  @Attribute XMLName : String end
  @Attribute localName : String end
  @Attribute test : Performable end
  @Operation desugar end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::AttributeMap}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Generator::AttributeMap}{toString}
No Documentation Specified
\Class{Root::XML::Generator}{ElementMap}
No Documentation Specified
\begin{Interface}
@Class ElementMap isabstract extends Sugar
  @Attribute mapName : String end
  @Operation mappedName end
  @Operation setMapName end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::ElementMap}{mappedName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::ElementMap}{setMapName}
No Documentation Specified
\Class{Root::XML::Generator}{IdTable}
No Documentation Specified
\begin{Interface}
@Class IdTable extends Object
  @Attribute counter : Integer end
  @Attribute table : Table end
  @Operation allocateId end
  @Operation idAttribute end
  @Operation ref end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::IdTable}{allocateId}
No Documentation Specified
\ClassOperation{Root::XML::Generator::IdTable}{idAttribute}
No Documentation Specified
\ClassOperation{Root::XML::Generator::IdTable}{ref}
No Documentation Specified
\Class{Root::XML::Generator}{Join}
No Documentation Specified
\begin{Interface}
@Class Join extends ElementMap
  @Attribute map : ElementMap end
  @Operation changeName end
  @Operation desugar end
  @Operation mappedName end
  @Operation setMapName end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::Join}{changeName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Join}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Join}{mappedName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Join}{setMapName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Join}{toString}
No Documentation Specified
\Class{Root::XML::Generator}{Just}
No Documentation Specified
\begin{Interface}
@Class Just extends ElementMap
  @Attribute name : String end
  @Operation changeName end
  @Operation desugar end
  @Operation mappedName end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::Just}{changeName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Just}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Just}{mappedName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Just}{toString}
No Documentation Specified
\Class{Root::XML::Generator}{Map}
No Documentation Specified
\begin{Interface}
@Class Map extends ElementMap
  @Attribute map : ElementMap end
  @Operation changeName end
  @Operation desugar end
  @Operation mappedName end
  @Operation setMapName end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::Map}{changeName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Map}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Map}{mappedName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Map}{setMapName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Map}{toString}
No Documentation Specified
\Class{Root::XML::Generator}{Ref}
No Documentation Specified
\begin{Interface}
@Class Ref extends ElementMap
  @Attribute att : String end
  @Attribute name : String end
  @Attribute tag : String end
  @Operation changeName end
  @Operation desugar end
  @Operation mappedName end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::Ref}{changeName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Ref}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Ref}{mappedName}
No Documentation Specified
\ClassOperation{Root::XML::Generator::Ref}{toString}
No Documentation Specified
\Class{Root::XML::Generator}{ToXML}
No Documentation Specified
\begin{Interface}
@Class ToXML extends Sugar
  @Attribute attMaps : Seq(AttributeMap) end
  @Attribute elementMaps : Seq(ElementMap) end
  @Attribute id : String end
  @Attribute name : String end
  @Attribute tag : String end
  @Operation desugarElementMaps end
  @Operation desugarAttributeMaps end
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::XML::Generator::ToXML}{desugarElementMaps}
No Documentation Specified
\ClassOperation{Root::XML::Generator::ToXML}{desugarAttributeMaps}
No Documentation Specified
\ClassOperation{Root::XML::Generator::ToXML}{desugar}
No Documentation Specified
\Class{Root::XML}{Node}

      An XML node can occur as the root of a document or the child of an

      element.
\begin{Interface}
@Class Node isabstract extends Object
  @Operation isWhiteSpace end
  @Operation print end
  @Operation pprint end
  @Operation stripWhiteSpace end
end
\end{Interface}
\ClassOperation{Root::XML::Node}{isWhiteSpace}
No Documentation Specified
\ClassOperation{Root::XML::Node}{print}

        Prints the XML node to the output channel. The output

        occurs on a single line.
\ClassOperation{Root::XML::Node}{pprint}

        Prints the XML node to the supplied output channel

        using newlines and indentation to show nesting.
\ClassOperation{Root::XML::Node}{stripWhiteSpace}
No Documentation Specified
\Class{Root::XML}{NoAttribute}

      This exception is raised when an attribute of an element is requested and 
      when the attribute is not defined.
\begin{Interface}
@Class NoAttribute extends Exception
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::XML::NoAttribute}{init}
No Documentation Specified
\Package{Root::XML}{Parser}

      The Parser package defines a language for parsing XML
      documents and synthesising values during the parse. XML
      processing is performed by defining an XML grammar (like
      an XBNF grammar) and using it to recognise correctly
      formed XML input. As the input is processed, the elements
      and their attributes may be referenced and bound to variables.
      During the parse, actions can be performed in the context
      of the bound variables. The values produced by the actions
      are returned from the parse.
\Class{Root::XML::Parser}{AndAtt}

      Succeeds when both the left and the right pattern succeeds.
      Binds any names bound by the left and right and returns the
      value of the right hand pattern.
\begin{Interface}
@Class AndAtt extends Attribute
  @Attribute left : Attribute end
  @Attribute right : Attribute end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::AndAtt}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::AndAtt}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::AndAtt}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Any}

      Succeeds when the input is non-empty and produces the next imput.
\begin{Interface}
@Class Any extends Pattern
  @Operation desugar end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Any}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Any}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{Attribute}

      An attribute pattern defines a parser for the attributes of an
      element. If it succeeds then any names are bound and the value
      of the last pattern is returned.
\begin{Interface}
@Class Attribute isabstract extends Sugar
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Attribute}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{Action}

      An action is a performable expression that can access
      bound variables from the current parse and produces a
      value that is supplied to the continuation.
\begin{Interface}
@Class Action extends Pattern
  @Attribute exp : Performable end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Action}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Action}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Action}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{And}

      Succeeds when both the left and the right pattern succeeds.
      Binds any names bound by the left and right and returns the
      value of the right hand pattern.
\begin{Interface}
@Class And extends Pattern
  @Attribute left : Pattern end
  @Attribute right : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::And}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::And}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::And}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{AttAct}

      An action is a performable expression that can access
      bound variables from the current parse and produces a
      value.
\begin{Interface}
@Class AttAct extends Pattern
  @Attribute exp : Performable end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::AttAct}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{AttValue}

      Succeeds when the element has an attribute with the given
      name and when the attribute value is the given string.
\begin{Interface}
@Class AttValue extends Attribute
  @Attribute name : String end
  @Attribute value : String end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::AttValue}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::AttValue}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::AttValue}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Bind}

      A binding parses a pattern and then binds the name
      to the value of the pattern.
\begin{Interface}
@Class Bind extends Pattern
  @Attribute name : String end
  @Attribute pattern : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Bind}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Bind}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Bind}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{BindAtt}

      Succeeds when the element has an attribute with the given
      name and binds the name to the value of the attribute. If
      the class is initialised with a single argument then the 
      name of the var is the same as the name of the attribute.
\begin{Interface}
@Class BindAtt extends Attribute
  @Attribute att : String end
  @Attribute var : String end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::BindAtt}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::BindAtt}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::BindAtt}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Call}

      Try to match the named pattern. The result of the call
      is returned to the caller. The new clause is parsed in
      the context of a new environment.
\begin{Interface}
@Class Call extends Pattern
  @Attribute name : String end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Call}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Call}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Call}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Clause}

      A clause is a named pattern that is owned by a grammar.
\begin{Interface}
@Class Clause extends NamedElement,Sugar
  @Attribute body : Pattern end
  @Operation desugar end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Clause}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Clause}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{Element}

      A pattern that corresponds to an element with a tag,
      some attributes and children. A matching element is
      returned as the result.
\begin{Interface}
@Class Element extends Pattern
  @Attribute attributes : Attribute end
  @Attribute children : Pattern end
  @Attribute tag : String end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Element}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Element}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Element}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{EmptyAtt}

      Succeeds and produces an empty sequence.
\begin{Interface}
@Class EmptyAtt extends Pattern
  @Operation desugar end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::EmptyAtt}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::EmptyAtt}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{Empty}

      Succeeds and produces an empty sequence.
\begin{Interface}
@Class Empty extends Pattern
  @Operation desugar end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Empty}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Empty}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{Grammar}

      An XML grammar defines how to parse an XML element and
      to synthesise an XMF value from it. A grammar is a name 
      space for its clauses.
\begin{Interface}
@Class Grammar extends Sugar,NameSpace
  @Attribute clauses : Seq(Clause) end
  @Attribute debug : Boolean end
  @Operation addToClauses end
  @Operation add end
  @Operation desugar end
  @Operation debug end
  @Operation fail end
  @Operation imports end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Grammar}{addToClauses}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Grammar}{add}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Grammar}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Grammar}{debug}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Grammar}{fail}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Grammar}{imports}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Grammar}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Grammar}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Opt}

      An optional pattern.
\begin{Interface}
@Class Opt extends Pattern
  @Attribute pattern : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Opt}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Opt}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Opt}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{OptAtt}

      An optional attribute.
\begin{Interface}
@Class OptAtt extends Attribute
  @Attribute pattern : Attribute end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::OptAtt}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::OptAtt}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::OptAtt}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Or}

      Succeeds when either the left or the right pattern succeeds.
      Binding and return value occurs due to the successful pattern.
\begin{Interface}
@Class Or extends Pattern
  @Attribute left : Pattern end
  @Attribute right : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Or}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Or}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Or}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Plus}

      Succeeds when 1 or more occurrences of the pattern occur in
      the supplied element. The result is a sequence of values
      produced by each successfully parsed occurrence.
\begin{Interface}
@Class Plus extends Pattern
  @Attribute pattern : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Plus}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Plus}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Plus}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Pattern}

      A pattern is an XML element parser. The pattern recognises a supplied
      element and synthesises an XMF value. A pattern may bind names to
      values extracted from the element. When a pattern successfully matches
      an element it produces a value.
\begin{Interface}
@Class Pattern isabstract extends Sugar
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Pattern}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{Ref}

      A reference to an XML id. Instances of this class should be created
      in XML grammar rules. They represent references to XMF values. 
      References should be used with updates. An update occurs in a grammar
      rule in the form name := pattern. The name should be bound to an XML
      id. Occurrences of Ref(id) in XMF values synthesised by the parse
      will be automatically replaced with the value of the pattern that
      registered an update for the name whose value is the id.
\begin{Interface}
@Class Ref extends Object
  @Attribute id : String end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Ref}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{ResolveRefs}

      An XML parse may encounter id refs. Elsewhere in the parse,
      XMF values will have been synthesised and an id associated
      (using :=) with the synthesised value. This walker is used to
      replace all occurrences of Ref(id) with the value associated
      with the id.
\begin{Interface}
@Class ResolveRefs extends Walker
  @Attribute refTable : Table end
  @Operation defaultWalk end
  @Operation reWalk end
  @Operation toString end
  @Operation walkTable end
  @Operation walkString end
  @Operation walkSlot end
  @Operation walkSet end
  @Operation walkSeq end
  @Operation walkPostObject end
  @Operation walkPreObject end
  @Operation walkOperation end
  @Operation walkObject end
  @Operation walkNull end
  @Operation walkInteger end
  @Operation walkBoolean end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::ResolveRefs}{defaultWalk}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{reWalk}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{toString}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkTable}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkString}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkSlot}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkSet}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkSeq}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkPostObject}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkPreObject}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkOperation}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkObject}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkNull}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkInteger}
No Documentation Specified
\ClassOperation{Root::XML::Parser::ResolveRefs}{walkBoolean}
No Documentation Specified
\Class{Root::XML::Parser}{Star}

      Succeeds when 0 or more occurrences of the pattern occur in
      the supplied element. The result is a sequence of values
      produced by each successfully parsed occurrence.
\begin{Interface}
@Class Star extends Pattern
  @Attribute pattern : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Star}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Star}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Star}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Text}

      Succeeds when the next input element is text. The input element
      is returned.
\begin{Interface}
@Class Text extends Pattern
  @Operation desugar end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Text}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Text}{parse}
No Documentation Specified
\Class{Root::XML::Parser}{Update}

      An update parses a pattern and then associates the current value
      of the name to the value of the pattern in the current table of
      references. The reference table is used to resolve id references
      that occur in XML.
\begin{Interface}
@Class Update extends Pattern
  @Attribute name : String end
  @Attribute pattern : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Update}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Update}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Update}{toString}
No Documentation Specified
\Class{Root::XML::Parser}{Unordered}

      Similar to And except that there is no requirement for left
      to be performed before right. In addition you cannot rely on
      the return value of this pattern. You can, however rely on the
      bindings established (but do not make the binding sensitive 
      to the ordering of the component patterns).
\begin{Interface}
@Class Unordered extends Pattern
  @Attribute left : Pattern end
  @Attribute right : Pattern end
  @Operation desugar end
  @Operation parse end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XML::Parser::Unordered}{desugar}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Unordered}{parse}
No Documentation Specified
\ClassOperation{Root::XML::Parser::Unordered}{toString}
No Documentation Specified
\Class{Root::XML}{Text}

      A text node records the text occurring in an XML document.
\begin{Interface}
@Class Text extends Node
  @Attribute text : String end
  @Operation isWhiteSpace end
  @Operation print end
  @Operation pprint end
  @Operation setText end
  @Operation stripWhiteSpace end
  @Operation toString end
  @Operation text end
end
\end{Interface}
\ClassOperation{Root::XML::Text}{isWhiteSpace}
No Documentation Specified
\ClassOperation{Root::XML::Text}{print}
No Documentation Specified
\ClassOperation{Root::XML::Text}{pprint}
No Documentation Specified
\ClassOperation{Root::XML::Text}{setText}
No Documentation Specified
\ClassOperation{Root::XML::Text}{stripWhiteSpace}
No Documentation Specified
\ClassOperation{Root::XML::Text}{toString}
No Documentation Specified
\ClassOperation{Root::XML::Text}{text}
No Documentation Specified
\Class{Root::XML}{UnknownTag}

      This exception is raised when an XML document is being parsed and when

      an element with an unexpected tag is encountered.
\begin{Interface}
@Class UnknownTag extends Exception
  @Operation init end
end
\end{Interface}
\ClassOperation{Root::XML::UnknownTag}{init}
No Documentation Specified
\Package{Root}{XMap}

      This package defines various constructs that allow XMF objects to
      be mapped and synchronised.
\Class{Root::XMap}{AddRight}

      See AddLeft. this is identical except that the daemon fires when an element
      is added to the right hand container.
\begin{Interface}
@Class AddRight extends AddAction
end
\end{Interface}
\Class{Root::XMap}{AddLeft}

      The AddLeft construct occurs in a SyncContainers construct and is used to
      define a daemon that fires when an element is added to the left container
      of the two being synchronized. If the left handl container is updated
      with one or more values then this daemon is fired for each new element.
      The construct has a parameter which is bound to the value which is added.
      In the body of the daemon the value of 'self' is the object being updated
      (i.e. the container). All other scoping rules apply.
      
      Constructor: AddLeft(arg,body)
\begin{Interface}
@Class AddLeft extends AddAction
end
\end{Interface}
\Class{Root::XMap}{AddAction}

      An add action is a general action that can occur to a container.
      The AddAction construct is general and is specialized to particular 
      forms of container synchronization and mapping.
\begin{Interface}
@Class AddAction extends Sugar,SyncContainerAction
  @Attribute arg : String end
  @Attribute body : Performable end
  @Attribute name : String end
  @Operation desugar end
  @Operation setName end
end
\end{Interface}
\ClassOperation{Root::XMap::AddAction}{desugar}
No Documentation Specified
\ClassOperation{Root::XMap::AddAction}{setName}
No Documentation Specified
\Class{Root::XMap}{DeleteRight}

      The DeleteRight construct occurs in a SyncContainers construct and is used to
      define a daemon that fires when an element is removed from the right container
      of the two being synchronized. If the right hand container is updated
      by deleting one or more values then this daemon is fired for each new element.
      The construct has a parameter which is bound to the value which is deleted.
      In the body of the daemon the value of 'self' is the object being updated
      (i.e. the container). All other scoping rules apply.
     
      Constructor: DeleteRight(arg,body)
\begin{Interface}
@Class DeleteRight extends DeleteAction
end
\end{Interface}
\Class{Root::XMap}{DeleteLeft}

      See DeleteRight. This is the same except the daemon fires when elements are
      removed from the left hand container.
\begin{Interface}
@Class DeleteLeft extends DeleteAction
end
\end{Interface}
\Class{Root::XMap}{DeleteAction}

      A delete action is a general action that can occur to a container.
      The DeleteAction construct is general and is specialized to particular 
      forms of container synchronization and mapping.
\begin{Interface}
@Class DeleteAction extends Sugar,SyncContainerAction
  @Attribute arg : String end
  @Attribute body : Performable end
  @Attribute name : String end
  @Operation desugar end
  @Operation setName end
end
\end{Interface}
\ClassOperation{Root::XMap::DeleteAction}{desugar}
No Documentation Specified
\ClassOperation{Root::XMap::DeleteAction}{setName}
No Documentation Specified
\Class{Root::XMap}{Mapping}

      All mappings inherit from this class.
\begin{Interface}
@Class Mapping extends Object
  @Operation target end
end
\end{Interface}
\ClassOperation{Root::XMap::Mapping}{target}

        A mapping is invoked in order to transform domain elements.
        The target is always the mapping.
\Class{Root::XMap}{Map}
No Documentation Specified
\begin{Interface}
@Class Map extends Class
  @Attribute domains : Seq(Classifier) end
  @Attribute range : Classifier end
  @Operation defaultParents end
end
\end{Interface}
\ClassOperation{Root::XMap::Map}{defaultParents}
No Documentation Specified
\Class{Root::XMap}{SyncContainerAction}
No Documentation Specified
\begin{Interface}
@Class SyncContainerAction isabstract extends Object
end
\end{Interface}
\Class{Root::XMap}{Sync}

      This construct synchronizes two objects on respective slots. Once synchronized,
      the values of the two slots are the same. An update to the appropriate slot of

      either object will cause the change to be propagated to the other object.
      
      Constructor: Sync(object1,name1,object2,name2)
       The objects are expressions and the names are strings.
\begin{Interface}
@Class Sync extends Sugar
  @Attribute name2 : String end
  @Attribute name1 : String end
  @Attribute object2 : Performable end
  @Attribute object1 : Performable end
  @Operation desugar end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMap::Sync}{desugar}
No Documentation Specified
\ClassOperation{Root::XMap::Sync}{toString}
No Documentation Specified
\Class{Root::XMap}{SyncContainers}

       Two containers are synchronized using this construct. A container is an object
       with a slot whose value is a collection. Containers are synchronized with respect
       to a particular slot. A container may be synchronized (for containership) more than 
       once; each time the slot may be the same or may be different. The body of this
       construct is a collection of daemon definitions. Special patterns of daemons
       for containership synchronization are provided: AddLeft; DeleteLeft; AddRight;
       DeleteRight. In each case daemons are defined that fire when elements are
       added or deleted to the left or right container with respect to the defined slot.
       The daemon bodies can be any expression and scoping rules apply except that 'self'
       is interpreted in a daemon body as the object that has changed. The value of 'self'
       currently in scope at the point of definition is referred to in each daemon as 'outerSelf'.
       In each daemon the name of the slots being synchronized are bound to the values
       after they have been updated.
       
       Constructor: SyncContainers(leftContainer,leftAttribute,rightContainer,rightAttribute,actions)
         Left and right containers are expressions, attributes are strings and actions are performable
         elements of type SynContainerAction.
\begin{Interface}
@Class SyncContainers extends Sugar
  @Attribute actions : Seq(Performable) end
  @Attribute leftAttribute : String end
  @Attribute leftContainer : Performable end
  @Attribute rightAttribute : String end
  @Attribute rightContainer : Performable end
  @Operation desugarActions end
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::XMap::SyncContainers}{desugarActions}
No Documentation Specified
\ClassOperation{Root::XMap::SyncContainers}{desugar}
No Documentation Specified
\Class{Root::XMap}{SlotValueChanged}

      This construct adds a daemon that fires when the given slot value changes. The
      construct allows the new value and old value to be bound. The body of the
      construct is any expression. Modifiers allow this construct to control whether
      it is fired when a slot value changes, when new values are added or when existing
      values are removed.
      
      Constructor: SlotValueChanged(modifier,name,object,slot,names,body
        The object and body should be expressions. The slot is any expression whose
        value is a string or symbol. Modifier should be a string containing +, - or empty.
        If + then names should be a single name bound to each element that is added 
        to the slot. If - then names should be a single name bound to each value that is
        removed from the slot. If empty then names should be two names the first is bound
        to the new value and the second to the old value whn the slot value changes.
\begin{Interface}
@Class SlotValueChanged extends Sugar
  @Attribute body : Performable end
  @Attribute modifier : String end
  @Attribute names : Seq(String) end
  @Attribute name : String end
  @Attribute object : Performable end
  @Attribute slot : Performable end
  @Operation desugarRemove end
  @Operation desugarChanged end
  @Operation desugarAdd end
  @Operation desugar end
  @Operation name end
  @Operation setName end
end
\end{Interface}
\ClassOperation{Root::XMap::SlotValueChanged}{desugarRemove}
No Documentation Specified
\ClassOperation{Root::XMap::SlotValueChanged}{desugarChanged}
No Documentation Specified
\ClassOperation{Root::XMap::SlotValueChanged}{desugarAdd}
No Documentation Specified
\ClassOperation{Root::XMap::SlotValueChanged}{desugar}
No Documentation Specified
\ClassOperation{Root::XMap::SlotValueChanged}{name}
No Documentation Specified
\ClassOperation{Root::XMap::SlotValueChanged}{setName}
No Documentation Specified
\Package{Root}{XRules}

      This package defines data driven rules that can be used to 
      monitor the behaviour of objects as they change. Rules consist
      of pattern-based conditions that apply to multiple objects.
      When the conditions are satisfied, the rule fires by executing
      its body. The implementation of the rules is based on a RETE
      network. This is efficient because it maintains the state of
      incomplete matches. When an object changes state, a rule is
      fired without having to re-examine existing objects that have
      already satisfied parts of the rule.
      
      XRules are inte-nded to be used to define consistency conditions
      that are required to hold between multiple objects. Typically we
      might state that we require the names of two objects with the
      same owner to be different and to inform the user if this invariant
      is violated. Another typical case is requiring that the slots of
      two objects contain collections of the same size.
      
      XRules is built from the basic Daemon mechanisms defined in the
      XMap package.
\Package{Root::XRules}{Network}

      This package contains the definition of the XRules network
      classes. These classes control the management of objects
      maching the rules that have been compiled into the network.
\Class{Root::XRules}{RuleBase}
No Documentation Specified
\begin{Interface}
@Class RuleBase extends Object
  @Attribute name : String end
  @Attribute rules : Seq(Rule) end
  @Operation addToRules end
  @Operation add end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XRules::RuleBase}{addToRules}
No Documentation Specified
\ClassOperation{Root::XRules::RuleBase}{add}
No Documentation Specified
\ClassOperation{Root::XRules::RuleBase}{toString}
No Documentation Specified
\Package{Root::XRules}{Syntax}

      This package contains the definition of the XRules syntax
      classes. Concrete syntax for XRules is parsed into these
      structures.
\Class{Root::XRules::Syntax}{And}

      An and condition is satisfied when objects satisfy the left
      and the right conditions.
\begin{Interface}
@Class And extends Condition
  @Attribute left : Condition end
  @Attribute right : Condition end
end
\end{Interface}
\Class{Root::XRules::Syntax}{Condition}

      A condition is a boolean expression in terms of object patterns.
      A condition is satisfied when there exist a collection of objects
      that match the given patterns.
\begin{Interface}
@Class Condition isabstract extends Object
end
\end{Interface}
\Class{Root::XRules::Syntax}{Or}

      An or condition is satisfied when objects satisfy the left
      or the right conditions.
\begin{Interface}
@Class Or extends Condition
  @Attribute left : Condition end
  @Attribute right : Condition end
end
\end{Interface}
\Class{Root::XRules::Syntax}{Pattern}

      A pattern consists of a path and a sequence of variable names.
      The pattern is satisfied by an object whose class is defined by 
      the path. The class should define a constructor with the same
      form as the pattern. The variable names are matched against the 
      slots defined by the constructor. A pattern may optionally define
      a self name in which case the name is associated with the 
      matching object.
\begin{Interface}
@Class Pattern extends Condition
  @Attribute names : Seq(String) end
  @Attribute name : String end
  @Attribute path : Seq(String) end
end
\end{Interface}
\Class{Root::XRules::Syntax}{Rule}

      An XRule consists of a name, an antecedent, a condition and a body. The
      antecedent is a boolean combination of patterns. A condition is a boolean
      expression. A body is an action. The rule states that if the system ever
      changes so that the antecedent matches a configuration of objects and the
      condition is satisfied then the body is performed. Notice that the body
      is performed for each change to the participating objects so the condition
      should be used to filter out changes that should not fire the rule.
\begin{Interface}
@Class Rule extends Object
  @Attribute antecedent : Condition end
  @Attribute body : Performable end
  @Attribute condition : Performable end
  @Attribute name : String end
  @Operation lift end
end
\end{Interface}
\ClassOperation{Root::XRules::Syntax::Rule}{lift}
No Documentation Specified
\Package{Root::XRules}{Vars}

      This package defines classes that are used to maintain information
      on variables during the XRules compilation process.
\Package{Root}{XMatch}

     This package defines a simple string matching grammar that can be used
     to match and extract portions of strings. See the class Pattern for
     more details about how to define patterns and match them against strings.
\Class{Root::XMatch}{And}

      Matches when the left hand pattern matches before the right
      hand pattern. The results of the two patterns are appen-ded on
      the stack.
\begin{Interface}
@Class And extends Pattern
  @Attribute left : Pattern end
  @Attribute right : Pattern end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::And}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::And}{toString}
No Documentation Specified
\Class{Root::XMatch}{Bind}

      Matches when the pattern matches. The name is then bound to the
      value at the head of the stack.
\begin{Interface}
@Class Bind extends Pattern
  @Attribute name : String end
  @Attribute pattern : Pattern end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::Bind}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Bind}{toString}
No Documentation Specified
\Class{Root::XMatch}{Dot}

      Matches a single character in the input. The character is left
      as a single sequence at the head of the stack.
\begin{Interface}
@Class Dot extends Pattern
  @Operation match end
end
\end{Interface}
\ClassOperation{Root::XMatch::Dot}{match}
No Documentation Specified
\Class{Root::XMatch}{EOI}

      Matches in the case where the input is exhausted. Leaves the
      empty sequence at the head of the stack.
\begin{Interface}
@Class EOI extends Pattern
  @Operation match end
end
\end{Interface}
\ClassOperation{Root::XMatch::EOI}{match}
No Documentation Specified
\Class{Root::XMatch}{Empty}

      Always matches. Leaves the empty sequence at the head of the stack.
\begin{Interface}
@Class Empty extends Pattern
  @Operation match end
end
\end{Interface}
\ClassOperation{Root::XMatch::Empty}{match}
No Documentation Specified
\Class{Root::XMatch}{Literal}

      Matches when the prefix of the input is the literal value.
      Leaves the literal value as a sequence of chars at the head
      of the stack.
\begin{Interface}
@Class Literal extends Pattern
  @Attribute value : String end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::Literal}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Literal}{toString}
No Documentation Specified
\Class{Root::XMatch}{Negate}

      Matches when the pattern fails. No stack values or bindings
      occur as a result of this pattern.
\begin{Interface}
@Class Negate extends Pattern
  @Attribute pattern : Pattern end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::Negate}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Negate}{toString}
No Documentation Specified
\Class{Root::XMatch}{Opt}

      Always matches. This will try the pattern first. If it succeeds
      then continue with bindings and results from pattern. Otherwise
      just succeed as per Empty.
\begin{Interface}
@Class Opt extends Pattern
  @Attribute pattern : Pattern end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::Opt}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Opt}{toString}
No Documentation Specified
\Class{Root::XMatch}{Or}

      Matches when the left or the right hand pattern matches.
      Note that the stack values and bindings resulting from
      a successful match will be those from either left or right
      but not both.
\begin{Interface}
@Class Or extends Pattern
  @Attribute left : Pattern end
  @Attribute right : Pattern end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::Or}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Or}{toString}
No Documentation Specified
\Class{Root::XMatch}{Plus}

      Matches when 1 or more occurrences of pattern matches.
\begin{Interface}
@Class Plus extends Pattern
  @Attribute pattern : Pattern end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::Plus}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Plus}{toString}
No Documentation Specified
\Class{Root::XMatch}{Pattern}

      A string matching pattern has the following main constructs:
      
        o M N matches when M followed by N matches.
        o M | N matches when M or N matches.
        o not M matches when M fails to match.
        o M* matches when M matches 0 or more times (greedily).
        o M+ matches whem M matches 1 or more times (greedily).
        o n = M matches and binds n to the result.
        o . matches the next char in the input.
        o E always matches.
        o EOI matches when the input has been consumed.
        o XYA or 'XYZ' matches when the next input chars are XYZ.
        o [M] is the same as (M | E).
        o (M) matches when M matches.
        
      Each construct produces a sequence of chars being that
      portion of the input that it consumes. The result of a match
      is either null of the match fails or an environment containing
      the variable bindings from the match. 
      
      The pattern matching is fully backtracking through the search
      space defined by a given pattern. You can controk this yourself
      via the match/5 operation. Alternatively, the matchValue/2 operation
      provides a convenient way of invoking the machinery and getting
      back either null or an environment of bindings. Invoke matchValue/2
      as an operation in the Pattern name space.
\begin{Interface}
@Class Pattern isabstract extends Object
  @Operation match end
  @Operation matchValue end
  @Operation match end
  @Operation parse end
end
\end{Interface}
\ClassOperation{Root::XMatch::Pattern}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Pattern}{matchValue}

        Use this operation to match a pattern (supplied as a string)
        against a value (supplied as a string) to return an environment
        of bindings or null.
\ClassOperation{Root::XMatch::Pattern}{match}

        Matches the receiver against the value. Returns an environment
        of bindings or null.
\ClassOperation{Root::XMatch::Pattern}{parse}
No Documentation Specified
\Class{Root::XMatch}{Star}

      Matches when 0 or more occurrences of pattern matches. The occurrences
      are concatenated on the stack.
\begin{Interface}
@Class Star extends Pattern
  @Attribute pattern : Pattern end
  @Operation match end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XMatch::Star}{match}
No Documentation Specified
\ClassOperation{Root::XMatch::Star}{toString}
No Documentation Specified
\Package{Root}{XOCL}

      The XOCL package contains definitions that exten-d the basic
      features of the OCL package. Many of the classes in this
      package are abstract syntax structure types that are instantiated
      by parsers. The syntax structures define how to perform themselves,
      for example by turning themselves into machine instructions.
\Class{Root::XOCL}{Attribute}

        This class represents an attribute definition. Performing an
        attribute definition produces an attribute. An attribute definition
        consists of a name, the attribute type expression, some modifiers 
        and a documentation expression.
\begin{Interface}
@Class Attribute extends Def
  @Attribute doc : Performable end
  @Attribute init : Performable end
  @Attribute modifiers : AttributeModifiers end
  @Attribute type : Performable end
  @Operation add end
  @Operation accessor end
  @Operation compile end
  @Operation doc end
  @Operation extender end
  @Operation eval end
  @Operation initSlotsExp end
  @Operation initExp end
  @Operation lift end
  @Operation metaExp end
  @Operation operations end
  @Operation pprint end
  @Operation reducer end
  @Operation toString end
  @Operation updater end
end
\end{Interface}
\ClassOperation{Root::XOCL::Attribute}{add}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{accessor}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{compile}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{doc}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{extender}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{eval}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{initSlotsExp}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{initExp}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{metaExp}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{operations}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{pprint}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{reducer}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{toString}
No Documentation Specified
\ClassOperation{Root::XOCL::Attribute}{updater}
No Documentation Specified
\Class{Root::XOCL}{AbstractDoc}
No Documentation Specified
\begin{Interface}
@Class AbstractDoc isabstract extends Sugar
end
\end{Interface}
\Class{Root::XOCL}{AttributeModifiers}
No Documentation Specified
\begin{Interface}
@Class AttributeModifiers extends Object
  @Attribute accessor : Boolean end
  @Attribute extender : Boolean end
  @Attribute reducer : Boolean end
  @Attribute updater : Boolean end
  @Operation defineModifier end
  @Operation emptyModifier end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::AttributeModifiers}{defineModifier}
No Documentation Specified
\ClassOperation{Root::XOCL::AttributeModifiers}{emptyModifier}
No Documentation Specified
\ClassOperation{Root::XOCL::AttributeModifiers}{pprint}
No Documentation Specified
\Class{Root::XOCL}{AbstractOp}

      An abstract operation defines the signature of an operation without

      specifying the body. If it is ever called, an abstract operation 
      will signal an error. The intention is that an abstract operation

      is defined in an abstract class and that it is redefined in each 
      concrete sub-class.
      Constructor: AbstractOp(name,args,type)
       The name is a string, the args is a sequence of patterns, the type is 
       an expression producing a classifier.
      Syntax:

       AbstractOp ::= '@AbstractOp' Name '(' Pattern* ')' [ ':' Exp ] [ Exp ]

\begin{Interface}
@Class AbstractOp extends Sugar
  @Attribute args : Seq(Element) end
  @Attribute doc : Performable end
  @Attribute name : String end
  @Attribute type : Performable end
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::XOCL::AbstractOp}{desugar}
No Documentation Specified
\Class{Root::XOCL}{Bind}

      A value binding is an association between a name ans a value.
      A value binding can be added to a name space. Once added,
      the value can be referenced using its name via the name space
      using the '::' notation.
     
      Constructor: Bind(name,value}
        The name should be a string or a symbol and the value is an
        expression. The name will be coerced to be a symbol.
\begin{Interface}
@Class Bind extends Def
  @Attribute value : Performable end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation init end
  @Operation maxLocals end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Bind}{FV}
No Documentation Specified
\ClassOperation{Root::XOCL::Bind}{compile}
No Documentation Specified
\ClassOperation{Root::XOCL::Bind}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Bind}{init}
No Documentation Specified
\ClassOperation{Root::XOCL::Bind}{maxLocals}
No Documentation Specified
\ClassOperation{Root::XOCL::Bind}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Constraint}
No Documentation Specified
\begin{Interface}
@Class Constraint extends Sugar
  @Attribute body : Performable end
  @Attribute name : String end
  @Attribute reason : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Constraint}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Constraint}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Constructor}

      A constructor describes how to initialise a newly created instance of

      a class. Each class may define a number of constructors that are used

      when an instance of the class is sent an 'init/1' message. The constructor

      is a sequence of attribute names and an optional body. When an instance

      is initialised, the matching constructor is selected from the class.
      A constructor matches the initialisation arguments when it defines the

      same number of attribute names as the length of the initialization 
      arguments. The effect of using the selected constructor is to set

      the slots with the appropriate names in the constructor from the 
      initialization arguments and then to perform the body of the constructor.
      If defined, the body of the constructor must return 'self'. A constructor

      may optionally specify that it is a template for transforming an object

      into a string, it does so by including the optional modifier '!' after

      the sequence of names. If present, the body of the constructor is evaluated

      in a scope where the names of the object slots specified in the name list are

      bound to the supplied values.
\begin{Interface}
@Class Constructor extends Sugar
  @Attribute body : Performable end
  @Attribute doc : Performable end
  @Attribute names : Seq(String) end
  @Attribute toString : Boolean end
  @Operation add end
  @Operation desugar end
  @Operation namesToString end
  @Operation operations end
  @Operation pprint end
  @Operation toString end
  @Operation toStringOperation end
end
\end{Interface}
\ClassOperation{Root::XOCL::Constructor}{add}

        Elements can be added to a constructor. This allows sub-classes

        of constructor to add new features if required. The basic constructor

        can receive documentation expressions and body expressions.
\ClassOperation{Root::XOCL::Constructor}{desugar}

        A constructor expressions is sugar for the instantiation of

        the EMOF::Constructor class. Note that the documentation

        expression may be null if it has not been initialised. All

        of the constructor names are placed in scope for the constructor

        operation (careful since this will mean that self.NAME <> NAME

        in the constructor body.
\ClassOperation{Root::XOCL::Constructor}{namesToString}

	    Produce a sequence of comma separated names as an expression

	    for the 'toString/0' operation produced by including '!' in the

	    constructor definition.
\ClassOperation{Root::XOCL::Constructor}{operations}
No Documentation Specified
\ClassOperation{Root::XOCL::Constructor}{pprint}

        Write out the text of the constructor definition expression

        to the supplied output channel at the given indent.
\ClassOperation{Root::XOCL::Constructor}{toString}
No Documentation Specified
\ClassOperation{Root::XOCL::Constructor}{toStringOperation}

        Produce the 'toString/0' operation def that is added to a

        class definition if the '!' char is included in the

        constructor definition.
\Class{Root::XOCL}{Case}

      A case expression captures the often used pattern of
      dispatching on a value to do several different tasks.
\begin{Interface}
@Class Case extends Sugar
  @Attribute arms : Seq(CaseArm) end
  @Attribute default : Performable end
  @Attribute values : Seq(Performable) end
  @Operation desugarValues end
  @Operation desugarLast end
  @Operation desugarArms end
  @Operation desugar end
  @Operation lift end
  @Operation pprint end
  @Operation toString end
  @Operation wellFormed end
end
\end{Interface}
\ClassOperation{Root::XOCL::Case}{desugarValues}
No Documentation Specified
\ClassOperation{Root::XOCL::Case}{desugarLast}
No Documentation Specified
\ClassOperation{Root::XOCL::Case}{desugarArms}
No Documentation Specified
\ClassOperation{Root::XOCL::Case}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Case}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::Case}{pprint}
No Documentation Specified
\ClassOperation{Root::XOCL::Case}{toString}
No Documentation Specified
\ClassOperation{Root::XOCL::Case}{wellFormed}
No Documentation Specified
\Class{Root::XOCL}{CaseArm}
No Documentation Specified
\begin{Interface}
@Class CaseArm extends Object
  @Attribute action : Performable end
  @Attribute patterns : Seq(Pattern) end
  @Operation arity end
  @Operation desugarPatterns end
  @Operation desugar end
  @Operation lift end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XOCL::CaseArm}{arity}
No Documentation Specified
\ClassOperation{Root::XOCL::CaseArm}{desugarPatterns}
No Documentation Specified
\ClassOperation{Root::XOCL::CaseArm}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::CaseArm}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::CaseArm}{pprint}
No Documentation Specified
\ClassOperation{Root::XOCL::CaseArm}{toString}
No Documentation Specified
\Class{Root::XOCL}{Class}

      The class XOCL::Class is a class definition. When a class definition is
      performed, it produces a class. Classes (typically) live in name spaces and
      should be added to a name space. Either define a class using a 'context ...'
      construct or add a class directly to a name space and then initialise the
      class via its 'init/0' operation.
\begin{Interface}
@Class Class extends Def
  @Attribute defs : Seq(Performable) end
  @Attribute isAbstract : Boolean end
  @Attribute metaClass : Performable end
  @Attribute name : Symbol end
  @Attribute parents : Seq(Performable) end
  @Operation attributes end
  @Operation allDefs end
  @Operation constructors end
  @Operation compileClassPopulation end
  @Operation compileClassCreation end
  @Operation compile end
  @Operation eval end
  @Operation foldDefs end
  @Operation initExp end
  @Operation lift end
  @Operation metaExp end
  @Operation maxLocals end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Class}{attributes}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{allDefs}

         Computes a sequence of definitions that are performed
         and added to the new class when the class definition is performed.
         Extensions of XOCL::Class may wish to exten-d this operation
         to add new types of automatically defined definition.
\ClassOperation{Root::XOCL::Class}{constructors}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{compileClassPopulation}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{compileClassCreation}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{compile}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{eval}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{foldDefs}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{initExp}

         This operation returns initialisation actions that are to be
         performed on the new class. the argument is an expression that
         evaluates to the newly constructed class. Ensure that the final
         result produced by the return value is the class.
\ClassOperation{Root::XOCL::Class}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{metaExp}

         Returns an expression that evaluates to produce the class
         which is instantiated. Useful in sub-classes of this class.
\ClassOperation{Root::XOCL::Class}{maxLocals}
No Documentation Specified
\ClassOperation{Root::XOCL::Class}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Count}

      The count construct specifies a loop from a lower limit to an upper limit.
      The lower limit is the initial value of a loop variable and the upper
      limit is 1 greater than the final value of the variable.
      
      Constructor: Count(var,lower,upper,body)
\begin{Interface}
@Class Count extends Sugar
  @Attribute body : Performable end
  @Attribute lower : Performable end
  @Attribute upper : Performable end
  @Attribute var : String end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Count}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Count}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Clause}
No Documentation Specified
\begin{Interface}
@Class Clause extends Object
  @Attribute bindings : Seq(Binding) end
  @Attribute body : Performable end
  @Attribute name : String end
  @Attribute patterns : Seq(Pattern) end
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::XOCL::Clause}{desugar}
No Documentation Specified
\Class{Root::XOCL}{Def}

      A definition is a named performable syntactic element. The class
      Def is abstract and requires that all sub-classes have a name.
\begin{Interface}
@Class Def isabstract extends Performable
  @Attribute name : String end
end
\end{Interface}
\Class{Root::XOCL}{Doc}

      This class represents a documentation definition. It is
      sugar for an expression that constructs a kernel documentation
      object containing a documentation string.
\begin{Interface}
@Class Doc extends AbstractDoc
  @Attribute doc : String end
  @Operation desugar end
  @Operation lift end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Doc}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Doc}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::Doc}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Find}

      A find construct is used to perform an action in terms of an element
      of a collection. Typically we want to find the first element in a 
      collection that satisfies a given predicate and to perform an action.
      If no value exists that satisfies the predicate then we optionally
      want to perform some other action. This construct captures the pattern.
      Constructor: Find(collection,name,test,action,alternative)
\begin{Interface}
@Class Find extends Sugar
  @Attribute alternative : Performable end
  @Attribute action : Performable end
  @Attribute collection : Performable end
  @Attribute name : String end
  @Attribute test : Performable end
  @Operation desugar end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XOCL::Find}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Find}{pprint}
No Documentation Specified
\ClassOperation{Root::XOCL::Find}{toString}
No Documentation Specified
\Class{Root::XOCL}{For}

      A for loop selects elements from a sequence in turn and 
      performs an action. The for directives can be used to indicate
      looping through a collection or parts of a table. Using the
      directives for tables can be much more efficient because an
      intermediate collection is not constructed.
\begin{Interface}
@Class For extends Sugar
  @Attribute body : Performable end
  @Attribute coll : Performable end
  @Attribute directive : String end
  @Attribute name : String end
  @Operation desugarInTableValues end
  @Operation desugarInTableKeys end
  @Operation desugarIn end
  @Operation desugar end
  @Operation lift end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XOCL::For}{desugarInTableValues}
No Documentation Specified
\ClassOperation{Root::XOCL::For}{desugarInTableKeys}
No Documentation Specified
\ClassOperation{Root::XOCL::For}{desugarIn}
No Documentation Specified
\ClassOperation{Root::XOCL::For}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::For}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::For}{pprint}
No Documentation Specified
\ClassOperation{Root::XOCL::For}{toString}
No Documentation Specified
\Class{Root::XOCL}{Fork}

      The fork construct creates a new execution thread. The body of the
      Fork construct is the expression to be evaluated by the thread when 
      it starts up. A forked thread does not start immediately. At any given
      time there is a current thread that can choose to YIELD control. At
      this point in time, if there are any other threads waiting to
      run then one is (re)started. The order in which threads are activated
      via yield is in the order of thread creation.
\begin{Interface}
@Class Fork extends Sugar
  @Attribute body : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Fork}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Fork}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Imports}

      The imports expression is used to grab the current collection of
      imported name spaces. Imports are lexically scoped so it is necessary
      to grab the dynamics from the current stack frame.
\begin{Interface}
@Class Imports extends Sugar
  @Attribute body : Performable end
  @Attribute name : String end
  @Operation desugar end
end
\end{Interface}
\ClassOperation{Root::XOCL::Imports}{desugar}

        An imports expression grabs the dynamics from the current
        stack frame (via Kernel_imports) and then filters them for
        the imported tables (tagged with 2). The values in the tables
        are contained by the imported name spaces.
\Class{Root::XOCL}{Letrec}

      A letrec construct allows bindings to be established for a local
      scope. The bindings are mutually recursive. Since XMF has eager
      evaluation, this means that the values of the bindings should be
      operations.
     
      Constructor: Letrec(bindings,body)
\begin{Interface}
@Class Letrec extends Sugar
  @Attribute body : Performable end
  @Attribute bindings : Seq(ValueBinding) end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Letrec}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Letrec}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Map}
No Documentation Specified
\begin{Interface}
@Class Map extends Class
  @Attribute clauses : Seq(Clause) end
  @Attribute domains : Seq(Performable) end
  @Attribute range : Performable end
  @Operation allDefs end
  @Operation invokeDef end
  @Operation invokeBody end
  @Operation initExp end
  @Operation lift end
  @Operation metaExp end
end
\end{Interface}
\ClassOperation{Root::XOCL::Map}{allDefs}
No Documentation Specified
\ClassOperation{Root::XOCL::Map}{invokeDef}
No Documentation Specified
\ClassOperation{Root::XOCL::Map}{invokeBody}
No Documentation Specified
\ClassOperation{Root::XOCL::Map}{initExp}
No Documentation Specified
\ClassOperation{Root::XOCL::Map}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::Map}{metaExp}
No Documentation Specified
\Class{Root::XOCL}{NameSpace}

       A name space is a named container of named elements. This construct allows a name
       space to be defined statically together with some bindings. Once created, new
       named elements can be added or existing ones removed.
     
       Constructor: NameSpace(bindings)
         Each binding is an instance of OCL::ValueBinding.
\begin{Interface}
@Class NameSpace extends Sugar
  @Attribute bindings : Seq(ValueBinding) end
  @Attribute name : String end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::NameSpace}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::NameSpace}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Package}

      A package definition is represented as an instance of this class.
      When the instance is performed it creates a new kernel package.
      
      Constructor: Package(name,defs)
        The name is a string and the definitions are expressions.
        The definitions are mutually recursive if they have been
        defined statically in the same package.
\begin{Interface}
@Class Package extends Def
  @Attribute defs : Seq(Performable) end
  @Attribute name : String end
  @Operation compile end
  @Operation eval end
  @Operation init end
  @Operation maxLocals end
  @Operation newPackageExp end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::Package}{compile}
No Documentation Specified
\ClassOperation{Root::XOCL::Package}{eval}
No Documentation Specified
\ClassOperation{Root::XOCL::Package}{init}
No Documentation Specified
\ClassOperation{Root::XOCL::Package}{maxLocals}
No Documentation Specified
\ClassOperation{Root::XOCL::Package}{newPackageExp}
No Documentation Specified
\ClassOperation{Root::XOCL::Package}{pprint}
No Documentation Specified
\Class{Root::XOCL}{Sugar}

      A sugared expression is one that is new syntax masquerading as old

      syntax. A sugared expression defines an operation 'desugar/0' that

      translates the receiver into an expression at a higher level of detail.
      It is not necessary to define how a sugared expression is compiled or

      interpreted since these mechanisms simply call desugar and then try

      again.
\begin{Interface}
@Class Sugar isabstract extends Performable
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation typeExp end
end
\end{Interface}
\ClassOperation{Root::XOCL::Sugar}{FV}
No Documentation Specified
\ClassOperation{Root::XOCL::Sugar}{compile}
No Documentation Specified
\ClassOperation{Root::XOCL::Sugar}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::Sugar}{eval}
No Documentation Specified
\ClassOperation{Root::XOCL::Sugar}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::Sugar}{maxLocals}
No Documentation Specified
\ClassOperation{Root::XOCL::Sugar}{typeExp}
No Documentation Specified
\Class{Root::XOCL}{TypeCase}

       A typecase defines a dispatch table for an element based on
       its type. The type case value expression is evaluated and each
       type case arm is tried in turn. A typecase arm consists of a
       type and a body. If the value is of the specified type then the 
       arm body is performed and produces the value of the typecase.
       If no arm matches then there may be an optional default expression
       which is evaluated and produces the value of the typecase. If no
       arm matches and no default is specified then an error is signaled.
       
       Constructor: TypeCase(value,arms,default)
         The value is an expression, the arms is a sequence of type case
         arms. The default is an expression.
\begin{Interface}
@Class TypeCase extends Sugar
  @Attribute arms : Seq(TypeCaseArm) end
  @Attribute default : Performable end
  @Attribute value : Performable end
  @Operation desugarArms end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::TypeCase}{desugarArms}
No Documentation Specified
\ClassOperation{Root::XOCL::TypeCase}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::TypeCase}{pprint}
No Documentation Specified
\Class{Root::XOCL}{TypeCaseArm}
No Documentation Specified
\begin{Interface}
@Class TypeCaseArm extends Object
  @Attribute body : Performable end
  @Attribute type : Performable end
  @Operation desugar end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::TypeCaseArm}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::TypeCaseArm}{pprint}
No Documentation Specified
\Class{Root::XOCL}{While}

      A basic loop with a test. The test is performed at least once before the
      loop is entered each time. When the loop test returnes false, the loop terminates.
      The return value of a while expression is undefined.
      
      Constructor: While(test,body)
        Both args should be expressions. The test should return a boolean value.
\begin{Interface}
@Class While extends Performable
  @Attribute body : Performable end
  @Attribute test : Performable end
  @Operation FV end
  @Operation compile end
  @Operation eval end
  @Operation lift end
  @Operation maxLocals end
  @Operation pprint end
  @Operation toString end
end
\end{Interface}
\ClassOperation{Root::XOCL::While}{FV}
No Documentation Specified
\ClassOperation{Root::XOCL::While}{compile}
No Documentation Specified
\ClassOperation{Root::XOCL::While}{eval}
No Documentation Specified
\ClassOperation{Root::XOCL::While}{lift}
No Documentation Specified
\ClassOperation{Root::XOCL::While}{maxLocals}
No Documentation Specified
\ClassOperation{Root::XOCL::While}{pprint}
No Documentation Specified
\ClassOperation{Root::XOCL::While}{toString}
No Documentation Specified
\Class{Root::XOCL}{WithoutDaemons}

      The without daemons expression is used to turn daemons off for the

      evaluation of an expression in the context of an object. Often a

      daemon will fire and the code that handles the daemon should not

      cause recursive daemon invocation. This form can be used to safely

      turn off daemons temporarily for the scope of the handler.
      
      Constructor: WithoutDaemons(object,body)
        The object and body should be expressions. Daemons are switched 
        off for the scope of the evaluation of the body.
\begin{Interface}
@Class WithoutDaemons extends Performable
  @Attribute body : Performable end
  @Attribute object : Performable end
  @Operation FV end
  @Operation compile end
  @Operation desugar end
  @Operation init end
  @Operation maxLocals end
  @Operation pprint end
end
\end{Interface}
\ClassOperation{Root::XOCL::WithoutDaemons}{FV}
No Documentation Specified
\ClassOperation{Root::XOCL::WithoutDaemons}{compile}
No Documentation Specified
\ClassOperation{Root::XOCL::WithoutDaemons}{desugar}
No Documentation Specified
\ClassOperation{Root::XOCL::WithoutDaemons}{init}
No Documentation Specified
\ClassOperation{Root::XOCL::WithoutDaemons}{maxLocals}
No Documentation Specified
\ClassOperation{Root::XOCL::WithoutDaemons}{pprint}
No Documentation Specified
\Operation{}{anonymous}
No Documentation Specified
\Operation{Root}{gc}
\Operation{Root}{print}
\Operation{Root}{resetOperatorTable}
\Operation{Root}{restoreMachineState}
\Operation{Root}{saveMachineState}
