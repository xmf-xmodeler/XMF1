parserImport XOCL;

let 
    // Create the Kernel classes.
 
    Attribute             = Kernel_mkObj();
    BehaviouralFeature    = Kernel_mkObj();
    Bind                  = Kernel_mkObj();
    Boolean               = Kernel_mkObj();
    Class                 = Kernel_mkObj();
    Classifier            = Kernel_mkObj();
    CompiledOperation     = Kernel_mkObj();
    Constraint            = Kernel_mkObj();
    Contained             = Kernel_mkObj();
    Container             = Kernel_mkObj();
    DataType              = Kernel_mkObj();
    Element               = Kernel_mkObj();
    Integer               = Kernel_mkObj();
    NamedElement          = Kernel_mkObj();
    NameSpace             = Kernel_mkObj();
    Null                  = Kernel_mkObj();
    Object                = Kernel_mkObj();
    Op                    = Kernel_mkObj();
    Package               = Kernel_mkObj();
    Parameter             = Kernel_mkObj();
    Performable           = Kernel_mkObj();
    Resource              = Kernel_mkObj();
    SeqDataType           = Kernel_mkObj();
    SetDataType           = Kernel_mkObj();
    SeqType               = Kernel_mkObj();
    SetType               = Kernel_mkObj();
    String                = Kernel_mkObj();
    StructuralFeature     = Kernel_mkObj();
    Symbol                = Kernel_mkObj();
    Table                 = Kernel_mkObj();
    TypedElement          = Kernel_mkObj();

    // Packages and namespaces:

    XCore                  = Kernel_mkObj();
    Root                  = Kernel_mkObj();
    
    // Collection type constructor:
    
    mkCollType = @Operation(collType,parents,default)
      @Operation(elementType)
        let type = Kernel_mkObj()
        in Kernel_setOf(type,collType);
           Kernel_addAtt(type,"name",Kernel_mkSymbol(collType.name + "(" + elementType.name + ")"));
           Kernel_addAtt(type,"parents",parents);
           Kernel_addAtt(type,"operations",Set{});
           Kernel_addAtt(type,"elementType",elementType);
           Kernel_addAtt(type,"constraints",Set{});
           Kernel_addAtt(type,"default",default);
           Kernel_addAtt(type,"documentation","");
           Kernel_addAtt(type,"owner",type);
           Kernel_addAtt(type,"contents",Kernel_mkTable(100));
           Kernel_addAtt(type,"bindings",Set{});
           type
         end
      end
    end

  in
    let

      // A standard class creation operation:

      mkClass = @Operation(
                  class,          // The class object to be updated.
                  parents,        // A set of parent classes.
                  isAbstract,     // A boolean determines whether we can have instances.
                  attributes,     // A set of attributes for the class.
                  name,           // A string naming the class.
                  operations,     // A set of operations for instances of the class.
                  constraints,    // A set of constraints that classify instances of the class.
                  default,        // The default value for the class.
                  documentation,  // A documentation string for the class.
                  owner,          // The owner of the class (null, itself or a name space).
                  expander)       // An operation used to expand syntax terms.
         Kernel_setOf(class,Class);
         Kernel_addAtt(class,"parents",parents);
         Kernel_addAtt(class,"isAbstract",isAbstract);
         Kernel_addAtt(class,"attributes",attributes);
         Kernel_addAtt(class,"name",Kernel_mkSymbol(name));
         Kernel_addAtt(class,"operations",operations);
         Kernel_addAtt(class,"constraints",constraints);
         Kernel_addAtt(class,"default",default);
         Kernel_addAtt(class,"documentation",documentation);
         Kernel_addAtt(class,"owner",owner);
         Kernel_addAtt(class,"expander",expander);
         Kernel_addAtt(class,"contents",Kernel_mkTable(100));
         Kernel_addAtt(class,"bindings",Set{});
         class
      end;
      
      mkDataType = @Operation(dataType,parents,name,operations,constraints,default,documentation,owner)
        Kernel_setOf(dataType,DataType);
        Kernel_addAtt(dataType,"parents",parents);
        Kernel_addAtt(dataType,"name",Kernel_mkSymbol(name));
        Kernel_addAtt(dataType,"operations",operations);
        Kernel_addAtt(dataType,"constraints",constraints);
        Kernel_addAtt(dataType,"default",default);
        Kernel_addAtt(dataType,"documentation",documentation);
        Kernel_addAtt(dataType,"owner",owner);
        Kernel_addAtt(dataType,"contents",Kernel_mkTable(100));
        Kernel_addAtt(dataType,"bindings",Set{});
        dataType
      end;
      
      // Collection type constructors:
      
      mkSetType = mkCollType(SetDataType,Set{SetType},Set{});
      mkSeqType = mkCollType(SeqDataType,Set{SeqType},Seq{});

      // A standard attribute creation operation:

      mkAtt = @Operation(name,type,owner,isComposite)
         let att = Kernel_mkObj()
         in Kernel_setOf(att,Attribute);
            Kernel_addAtt(att,"name",Kernel_mkSymbol(name));
            Kernel_addAtt(att,"type",type);
            Kernel_addAtt(att,"owner",owner);
            Kernel_addAtt(att,"isComposite",isComposite);
            att
         end
      end;
      
      // Operations:
      
      Classifier_add =
        @Operation add(namedElement:NamedElement)
          if namedElement.isKindOf(Op)
          then 
            self.addOperation(namedElement); 
            super(namedElement)
          else 
            namedElement.setOwner(self); 
            super(namedElement)
          end
        end;
  
      Classifier_inheritsFrom =
       @Operation inheritsFrom(c:Classifier):Boolean
         if self = c
         then true
         else self.parents->exists(parent | parent.inheritsFrom(c))
         end
        end;
      
      Classifier_addOperation =
        @Operation addOperation(op)
          if self.hasOperation(op.name,op.arity)
          then self.remove(self.getOperation(op.name,op.arity))
          else self
          end;
          self.operations := self.operations.including(op);
          op.setOwner(self);
          resetOperatorTable();
          self
        end;
        
      Classifier_default =
        @Operation default()
          default
        end;
        
      Classifier_getOperation = 
        @Operation getOperation(name,arity)
          self.operations->select(op | op.name = name and op.arity = arity)->sel
        end;
        
      Classifier_hasOperation =
        @Operation hasOperation(name,arity)
          operations->exists(op | op.name = name and op.arity = arity)
        end;
        
      Classifier_removeOperation =
        @Operation removeOperation(op)
          op.owner := null;
          self.operations := operations->excluding(op)
        end;
        
      Contained_setOwner =
        @Operation setOwner(container:Container)
          self.owner := container
        end;
        
      Contained_removeFromOwner =
        @Operation setOwner()
          self.owner := null
        end;
        
      Container_add =
        @Operation add(element:Element):Container
          self.contents.put(element,element)
        end;
        
      Container_remove =
        @Operation remove(element:Element):Container
          self.contents.remove(element)
        end;
          
      Element_isKindOf =
        @Operation isKindOf(c:Classifier):Boolean
          if self = null
          then true
          else self.of().inheritsFrom(c)
          end
        end;
        
      Element_init =
        @Operation init():Element
          self
        end;
 
      Element_of =
        @Operation of():Element
          self.of()
        end;
         
      Integer_to =
        @Operation to(n:Integer):Seq(Integer)
          if self >= n
          then Seq{self}
          else Seq{self | (self + 1).to(n)}
          end
        end;
        
      NameSpace_getElement =
        @Operation getElement(name:String):Contained
          name := if not name.isKindOf(Symbol) then Kernel_mkSymbol(name) else name end;
          if self.hasElement(name)
          then self.contents.get(name)
          else self.error("no element " + self.name + "::" + name + " in " + contents.toString())
          end
        end;

      NameSpace_hasElement =
        @Operation hasElement(name:String):Boolean
          contents.hasKey(if not name.isKindOf(Symbol) then Kernel_mkSymbol(name) else name end)
        end;
        
      SeqOfElement_collect =
        @Operation collect(filter):Seq(Element)
          if self = Seq{}
          then self
          else Seq{filter(self->head) | self->tail.collect(filter)}
          end
        end;

      SeqOfElement_drop =
        @Operation drop(n:Integer):Seq(Element)
          if n = 0 or self = Seq{}
          then self
          else self->tail->drop(n-1)
          end
        end;

      SeqOfElement_excluding =
        @Operation excluding(element)
          if self = Seq{}
          then Seq{}
          else if self->head = element
               then self->tail->excluding(element)
               else Seq{self->head | self->tail->excluding(element)}
               end
          end
        end;
        
      SeqOfElement_reject =
        @Operation reject(pred):Seq(Element)
          if self = Seq{}
          then self
          else if pred(self->head)
               then self->tail->reject(pred)
               else Seq{self->head | self->tail->reject(pred)}
               end
          end
        end;

      SeqOfElement_size =
        @Operation size():Integer
          if self = Seq{}
          then 0
          else self->drop(1)->size + 1
          end
        end;

      SetOfElement_collect =
        @Operation collect(filter):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->collect(filter))
        end;

      SetOfElement_excluding =
        @Operation excluding(element):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->excluding(element))
        end;

      SetOfElement_exists =
        @Operation exists(pred):Boolean
          if self->size = 0
          then false
          else let element = self->sel
               in if pred(element)
                  then true
                  else self->excluding(element)->exists(pred)
                  end
               end
          end
        end;
        
      SetOfElement_including =
        @Operation including(element):Set(Element)
          Kernel_asSet(Seq{element | Kernel_asSeq(self)})
        end;
        
      SetOfElement_reject =
        @Operation reject(pred):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->reject(pred))
        end;

      SetOfElement_sel =
       @Operation sel():Element
         if self->size = 0
         then self.error("Cannot select an element from an empty set.")
         else Kernel_asSeq(self)->head
         end
       end;
       
      SetOfElement_select =
       @Operation select(predicate):Set(Element)
         if self->size = 0
         then self
         else 
           let element = self->sel
           in if predicate(element)
              then self->excluding(element).select(predicate)->including(element)
              else self->excluding(element).select(predicate)
              end
           end
         end
       end;
       
     SetOfElement_size =
       @Operation size():Integer
         Kernel_asSeq(self)->size
       end;
       
     Table_get =
       @Operation get(key:Element):Element
         Kernel_tableGet(self,key)
       end;
  
     Table_hasKey = 
       @Operation hasKey(key:Element):Boolean
         Kernel_tableHasKey(self,key)
       end;
  
     Table_put =
       @Operation put(key:Element,value:Element)
         Kernel_tablePut(self,key,value)
       end;
       
     Table_remove =
       @Operation remove(key:Element)
         Kernel_tableRemove(self,key)
       end
  
  in 
     // The following names are predefined in order to allow forward
     // references to class names when creating collection types.
     
     Kernel_addAtt(Attribute,"name",Kernel_mkSymbol("Attribute"));
     Kernel_addAtt(Classifier,"name",Kernel_mkSymbol("Classifier"));
     Kernel_addAtt(Constraint,"name",Kernel_mkSymbol("Constraint"));
     Kernel_addAtt(Element,"name",Kernel_mkSymbol("Element"));
     Kernel_addAtt(NameSpace,"name",Kernel_mkSymbol("NameSpace"));
     Kernel_addAtt(Op,"name",Kernel_mkSymbol("Operation"));
     Kernel_addAtt(Parameter,"name",Kernel_mkSymbol("Parameter"));
     Kernel_addAtt(SetDataType,"name",Kernel_mkSymbol("Set"));
     Kernel_addAtt(SeqDataType,"name",Kernel_mkSymbol("Seq")); 
     Kernel_addAtt(String,"name",Kernel_mkSymbol("String"));
     
     mkClass(Attribute,
             Set{StructuralFeature},
             false,
             Set{},
             "Attribute",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(BehaviouralFeature,
             Set{TypedElement},
             true,
             Set{mkAtt("parameters",mkSeqType(Parameter),BehaviouralFeature,true),
                 mkAtt("performable",Performable,BehaviouralFeature,true)},
             "BehaviouralFeature",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Bind,
             Set{NamedElement},
             false,
             Set{mkAtt("value",Element,Bind,true)},
             "Bind",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Boolean,Set{Element},"Boolean",Set{},Set{},false,"",XCore);
     
     mkClass(Class,
             Set{Classifier},
             false,
             Set{mkAtt("attributes",mkSetType(Attribute),Class,true),
                 mkAtt("isAbstract",Boolean,Class,false)},
             "Class",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(Classifier,
             Set{NameSpace},
             false,
             Set{mkAtt("parents",mkSetType(Classifier),Classifier,false),
                 mkAtt("operations",mkSetType(Op),Classifier,true),
                 mkAtt("constraints",mkSetType(Constraint),Classifier,true),
                 mkAtt("default",Element,Classifier,false),
                 mkAtt("documentation",String,Classifier,false)},
             "Classifier",
             Set{Classifier_add,
                 Classifier_addOperation,
                 Classifier_default,
                 Classifier_getOperation,
                 Classifier_hasOperation,
                 Classifier_inheritsFrom,
                 Classifier_removeOperation},
             Set{},
             null,
             "",
             XCore,
             null);

     mkClass(CompiledOperation,
             Set{Op},
             false,
             Set{},
             "CompiledOperation",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Constraint,Set{NamedElement},false,Set{},"Constraint",Set{},Set{},null,"",XCore,null);
     
     mkClass(Contained,
             Set{Object},
             true,
             Set{mkAtt("owner",Container,Contained,false)},
             "Contained",
             Set{Contained_setOwner,Contained_removeFromOwner},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Container,
             Set{Object},
             false,
             Set{mkAtt("contents",Table,Container,true)},
             "Container",
             Set{Container_add,Container_remove},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(DataType,
             Set{Classifier},
             true,
             Set{},
             "DataType",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Element,
             Set{},
             true,
             Set{},
             "Element",
             Set{Element_isKindOf,Element_init,Element_of},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Integer,Set{Element},"Integer",Set{Integer_to},Set{},0,"",XCore);
      
     mkClass(NamedElement,
             Set{Contained},
             true,
             Set{mkAtt("name",String,NamedElement,false)},
             "NamedElement",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(NameSpace,
             Set{Container,NamedElement},
             false,
             Set{mkAtt("bindings",mkSetType(Bind),NameSpace,true),
                 mkAtt("imports",mkSetType(NameSpace),NameSpace,false)},
             "NameSpace",
             Set{NameSpace_getElement,NameSpace_hasElement},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Null,Set{Element},"Null",Set{},Set{},null,"",XCore);
             
     mkClass(Object,Set{Element},false,Set{},"Object",Set{},Set{},null,"",XCore,null);
     
     mkClass(Op,
             Set{BehaviouralFeature},
             false,
             Set{mkAtt("documentation",String,Op,true)},
             "Operation",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(Package,
             Set{Classifier,Resource},
             false,
             Set{mkAtt("metaPackage",Package,Package,false)},
             "Package",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Parameter,
             Set{TypedElement},
             false,
             Set{},
             "Parameter",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Performable,
             Set{Object},
             true,
             Set{},
             "Performable",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
      
     mkClass(Resource,
             Set{Object},
             true,
             Set{mkAtt("resourceName",String,Resource,false)},
             "Resource",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     Kernel_setOf(SetType,SetDataType);
     Kernel_addAtt(SetType,"name",Kernel_mkSymbol("Set(Element)"));
     Kernel_addAtt(SetType,"parents",Set{Element});
     Kernel_addAtt(SetType,"elementType",Element);
     Kernel_addAtt(SetType,"operations",Set{
       SetOfElement_collect,
       SetOfElement_excluding,
       SetOfElement_exists,
       SetOfElement_including,
       SetOfElement_reject,
       SetOfElement_sel,
       SetOfElement_select,
       SetOfElement_size});
     Kernel_addAtt(SetType,"constraints",Set{});
     Kernel_addAtt(SetType,"default",Set{});
     Kernel_addAtt(SetType,"documentation","");
     Kernel_addAtt(SetType,"owner",XCore);
     Kernel_addAtt(SetType,"contents",Kernel_mkTable(100));
     Kernel_addAtt(SetType,"bindings",Set{});
     
     mkClass(SetDataType,
             Set{DataType},
             false,
             Set{mkAtt("elementType",Classifier,SetDataType,false)},
             "Set",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(SeqDataType,
             Set{DataType},
             false,
             Set{mkAtt("elementType",Classifier,SetDataType,false)},
             "Seq",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     Kernel_setOf(SeqType,SeqDataType);
     Kernel_addAtt(SeqType,"name",Kernel_mkSymbol("Seq(Element)"));
     Kernel_addAtt(SeqType,"parents",Set{Element});
     Kernel_addAtt(SeqType,"elementType",Element);
     Kernel_addAtt(SeqType,"operations",Set{
       SeqOfElement_collect,
       SeqOfElement_drop,
       SeqOfElement_excluding,
       SeqOfElement_reject,
       SeqOfElement_size});
     Kernel_addAtt(SeqType,"constraints",Set{});
     Kernel_addAtt(SeqType,"default",Seq{});
     Kernel_addAtt(SeqType,"documentation","");
     Kernel_addAtt(SeqType,"owner",XCore);    
     Kernel_addAtt(SeqType,"contents",Kernel_mkTable(100));  
     Kernel_addAtt(SeqType,"bindings",Set{});  
     
     mkDataType(String,Set{Element},"String",Set{},Set{},"","",XCore);
                          
     mkClass(StructuralFeature,
             Set{TypedElement},
             true,
             Set{},
             "StructuralFeature",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Symbol,Set{String},"Symbol",Set{},Set{},"","",XCore);
    
     mkClass(Table,
             Set{Element},
             true,
             Set{},
             "Table",
             Set{
               Table_hasKey,
               Table_get,
               Table_put,
               Table_remove},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(TypedElement,
             Set{NamedElement},
             true,
             Set{mkAtt("type",Classifier,TypedElement,false)},
             "TypedElement",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);

     // Set up the namespaces.

     Kernel_setOf(XCore,Package);
     Kernel_addAtt(XCore,"name",Kernel_mkSymbol("XCore"));
     Kernel_addAtt(XCore,"parents",Set{});
     Kernel_addAtt(XCore,"operations",Set{});
     Kernel_addAtt(XCore,"constraints",Set{});
     Kernel_addAtt(XCore,"default",null);
     Kernel_addAtt(XCore,"owner",Root);
     Kernel_addAtt(XCore,"documentation","");
     Kernel_addAtt(XCore,"resourceName","");
     Kernel_addAtt(XCore,"imports",Set{});
     Kernel_addAtt(XCore,"bindings",Set{});
     Kernel_addAtt(XCore,"contents",
       let table = Kernel_XCore_Table;
           contents = 
            Seq{
             Attribute,
             BehaviouralFeature, 
             Bind,
             Boolean,
             Class,
             Classifier,
             CompiledOperation,
             Constraint,
             Contained,
             Container,
             DataType,
             Element,
             Integer,
             NamedElement,
             NameSpace,
             Null,
             Object, 
             Op,
             Package,
             Parameter,
             Performable,
             Resource,
             SeqDataType,
             SetDataType,
             SeqType,
             SetType,
             String,
             StructuralFeature,
             Symbol,
             Table, 
             TypedElement}
        in @While not contents->isEmpty do
             let c = contents->head
             in Kernel_tablePut(table,c.name,c);
                contents := contents->tail;
                contents->size.println()
             end
           end;
           table
        end);
        
     Kernel_setOf(Root,NameSpace);
     Kernel_addAtt(Root,"name",Kernel_mkSymbol("Root"));
     Kernel_addAtt(Root,"owner",Root);
     Kernel_addAtt(Root,"imports",Set{});
     Kernel_addAtt(Root,"contents",Kernel_Root_Table);
     Kernel_addAtt(Root,"bindings",Set{});
     
     Kernel_tablePut(Root.contents,XCore.name,XCore);
     Kernel_tablePut(Root.contents,Root.name,Root);
             
     Kernel_setTypes(Boolean,Bind,CompiledOperation,Element,Class,Integer,String,SeqType,SetType,Symbol,Table,Null);

     Kernel_tablePut(XCore.contents,Kernel_mkSymbol("SetOfElement"),SetType);
     Kernel_tablePut(XCore.contents,Kernel_mkSymbol("SeqOfElement"),SeqType)
     
  end
end;

parserImport XOCL;

let 
    // Create the Kernel classes.
 
    Attribute             = Kernel_mkObj();
    BehaviouralFeature    = Kernel_mkObj();
    Bind                  = Kernel_mkObj();
    Boolean               = Kernel_mkObj();
    Class                 = Kernel_mkObj();
    Classifier            = Kernel_mkObj();
    CompiledOperation     = Kernel_mkObj();
    Constraint            = Kernel_mkObj();
    Contained             = Kernel_mkObj();
    Container             = Kernel_mkObj();
    DataType              = Kernel_mkObj();
    Element               = Kernel_mkObj();
    Integer               = Kernel_mkObj();
    NamedElement          = Kernel_mkObj();
    NameSpace             = Kernel_mkObj();
    Null                  = Kernel_mkObj();
    Object                = Kernel_mkObj();
    Op                    = Kernel_mkObj();
    Package               = Kernel_mkObj();
    Parameter             = Kernel_mkObj();
    Performable           = Kernel_mkObj();
    Resource              = Kernel_mkObj();
    SeqDataType           = Kernel_mkObj();
    SetDataType           = Kernel_mkObj();
    SeqType               = Kernel_mkObj();
    SetType               = Kernel_mkObj();
    String                = Kernel_mkObj();
    StructuralFeature     = Kernel_mkObj();
    Symbol                = Kernel_mkObj();
    Table                 = Kernel_mkObj();
    TypedElement          = Kernel_mkObj();

    // Packages and namespaces:

    XCore                  = Kernel_mkObj();
    Root                  = Kernel_mkObj();
    
    // Collection type constructor:
    
    mkCollType = @Operation(collType,parents,default)
      @Operation(elementType)
        let type = Kernel_mkObj()
        in Kernel_setOf(type,collType);
           Kernel_addAtt(type,"name",Kernel_mkSymbol(collType.name + "(" + elementType.name + ")"));
           Kernel_addAtt(type,"parents",parents);
           Kernel_addAtt(type,"operations",Set{});
           Kernel_addAtt(type,"elementType",elementType);
           Kernel_addAtt(type,"constraints",Set{});
           Kernel_addAtt(type,"default",default);
           Kernel_addAtt(type,"documentation","");
           Kernel_addAtt(type,"owner",type);
           Kernel_addAtt(type,"contents",Kernel_mkTable(100));
           Kernel_addAtt(type,"bindings",Set{});
           type
         end
      end
    end

  in
    let

      // A standard class creation operation:

      mkClass = @Operation(
                  class,          // The class object to be updated.
                  parents,        // A set of parent classes.
                  isAbstract,     // A boolean determines whether we can have instances.
                  attributes,     // A set of attributes for the class.
                  name,           // A string naming the class.
                  operations,     // A set of operations for instances of the class.
                  constraints,    // A set of constraints that classify instances of the class.
                  default,        // The default value for the class.
                  documentation,  // A documentation string for the class.
                  owner,          // The owner of the class (null, itself or a name space).
                  expander)       // An operation used to expand syntax terms.
         Kernel_setOf(class,Class);
         Kernel_addAtt(class,"parents",parents);
         Kernel_addAtt(class,"isAbstract",isAbstract);
         Kernel_addAtt(class,"attributes",attributes);
         Kernel_addAtt(class,"name",Kernel_mkSymbol(name));
         Kernel_addAtt(class,"operations",operations);
         Kernel_addAtt(class,"constraints",constraints);
         Kernel_addAtt(class,"default",default);
         Kernel_addAtt(class,"documentation",documentation);
         Kernel_addAtt(class,"owner",owner);
         Kernel_addAtt(class,"expander",expander);
         Kernel_addAtt(class,"contents",Kernel_mkTable(100));
         Kernel_addAtt(class,"bindings",Set{});
         class
      end;
      
      mkDataType = @Operation(dataType,parents,name,operations,constraints,default,documentation,owner)
        Kernel_setOf(dataType,DataType);
        Kernel_addAtt(dataType,"parents",parents);
        Kernel_addAtt(dataType,"name",Kernel_mkSymbol(name));
        Kernel_addAtt(dataType,"operations",operations);
        Kernel_addAtt(dataType,"constraints",constraints);
        Kernel_addAtt(dataType,"default",default);
        Kernel_addAtt(dataType,"documentation",documentation);
        Kernel_addAtt(dataType,"owner",owner);
        Kernel_addAtt(dataType,"contents",Kernel_mkTable(100));
        Kernel_addAtt(dataType,"bindings",Set{});
        dataType
      end;
      
      // Collection type constructors:
      
      mkSetType = mkCollType(SetDataType,Set{SetType},Set{});
      mkSeqType = mkCollType(SeqDataType,Set{SeqType},Seq{});

      // A standard attribute creation operation:

      mkAtt = @Operation(name,type,owner,isComposite)
         let att = Kernel_mkObj()
         in Kernel_setOf(att,Attribute);
            Kernel_addAtt(att,"name",Kernel_mkSymbol(name));
            Kernel_addAtt(att,"type",type);
            Kernel_addAtt(att,"owner",owner);
            Kernel_addAtt(att,"isComposite",isComposite);
            att
         end
      end;
      
      // Operations:
      
      Classifier_add =
        @Operation add(namedElement:NamedElement)
          if namedElement.isKindOf(Op)
          then 
            self.addOperation(namedElement); 
            super(namedElement)
          else 
            namedElement.setOwner(self); 
            super(namedElement)
          end
        end;
  
      Classifier_inheritsFrom =
       @Operation inheritsFrom(c:Classifier):Boolean
         if self = c
         then true
         else self.parents->exists(parent | parent.inheritsFrom(c))
         end
        end;
      
      Classifier_addOperation =
        @Operation addOperation(op)
          if self.hasOperation(op.name,op.arity)
          then self.remove(self.getOperation(op.name,op.arity))
          else self
          end;
          self.operations := self.operations.including(op);
          op.setOwner(self);
          resetOperatorTable();
          self
        end;
        
      Classifier_default =
        @Operation default()
          default
        end;
        
      Classifier_getOperation = 
        @Operation getOperation(name,arity)
          self.operations->select(op | op.name = name and op.arity = arity)->sel
        end;
        
      Classifier_hasOperation =
        @Operation hasOperation(name,arity)
          operations->exists(op | op.name = name and op.arity = arity)
        end;
        
      Classifier_removeOperation =
        @Operation removeOperation(op)
          op.owner := null;
          self.operations := operations->excluding(op)
        end;
        
      Contained_setOwner =
        @Operation setOwner(container:Container)
          self.owner := container
        end;
        
      Contained_removeFromOwner =
        @Operation setOwner()
          self.owner := null
        end;
        
      Container_add =
        @Operation add(element:Element):Container
          self.contents.put(element,element)
        end;
        
      Container_remove =
        @Operation remove(element:Element):Container
          self.contents.remove(element)
        end;
          
      Element_isKindOf =
        @Operation isKindOf(c:Classifier):Boolean
          if self = null
          then true
          else self.of().inheritsFrom(c)
          end
        end;
        
      Element_init =
        @Operation init():Element
          self
        end;
 
      Element_of =
        @Operation of():Element
          self.of()
        end;
         
      Integer_to =
        @Operation to(n:Integer):Seq(Integer)
          if self >= n
          then Seq{self}
          else Seq{self | (self + 1).to(n)}
          end
        end;
        
      NameSpace_getElement =
        @Operation getElement(name:String):Contained
          name := if not name.isKindOf(Symbol) then Kernel_mkSymbol(name) else name end;
          if self.hasElement(name)
          then self.contents.get(name)
          else self.error("no element " + self.name + "::" + name + " in " + contents.toString())
          end
        end;

      NameSpace_hasElement =
        @Operation hasElement(name:String):Boolean
          contents.hasKey(if not name.isKindOf(Symbol) then Kernel_mkSymbol(name) else name end)
        end;
        
      SeqOfElement_collect =
        @Operation collect(filter):Seq(Element)
          if self = Seq{}
          then self
          else Seq{filter(self->head) | self->tail.collect(filter)}
          end
        end;

      SeqOfElement_drop =
        @Operation drop(n:Integer):Seq(Element)
          if n = 0 or self = Seq{}
          then self
          else self->tail->drop(n-1)
          end
        end;

      SeqOfElement_excluding =
        @Operation excluding(element)
          if self = Seq{}
          then Seq{}
          else if self->head = element
               then self->tail->excluding(element)
               else Seq{self->head | self->tail->excluding(element)}
               end
          end
        end;
        
      SeqOfElement_reject =
        @Operation reject(pred):Seq(Element)
          if self = Seq{}
          then self
          else if pred(self->head)
               then self->tail->reject(pred)
               else Seq{self->head | self->tail->reject(pred)}
               end
          end
        end;

      SeqOfElement_size =
        @Operation size():Integer
          if self = Seq{}
          then 0
          else self->drop(1)->size + 1
          end
        end;

      SetOfElement_collect =
        @Operation collect(filter):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->collect(filter))
        end;

      SetOfElement_excluding =
        @Operation excluding(element):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->excluding(element))
        end;

      SetOfElement_exists =
        @Operation exists(pred):Boolean
          if self->size = 0
          then false
          else let element = self->sel
               in if pred(element)
                  then true
                  else self->excluding(element)->exists(pred)
                  end
               end
          end
        end;
        
      SetOfElement_including =
        @Operation including(element):Set(Element)
          Kernel_asSet(Seq{element | Kernel_asSeq(self)})
        end;
        
      SetOfElement_reject =
        @Operation reject(pred):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->reject(pred))
        end;

      SetOfElement_sel =
       @Operation sel():Element
         if self->size = 0
         then self.error("Cannot select an element from an empty set.")
         else Kernel_asSeq(self)->head
         end
       end;
       
      SetOfElement_select =
       @Operation select(predicate):Set(Element)
         if self->size = 0
         then self
         else 
           let element = self->sel
           in if predicate(element)
              then self->excluding(element).select(predicate)->including(element)
              else self->excluding(element).select(predicate)
              end
           end
         end
       end;
       
     SetOfElement_size =
       @Operation size():Integer
         Kernel_asSeq(self)->size
       end;
       
     Table_get =
       @Operation get(key:Element):Element
         Kernel_tableGet(self,key)
       end;
  
     Table_hasKey = 
       @Operation hasKey(key:Element):Boolean
         Kernel_tableHasKey(self,key)
       end;
  
     Table_put =
       @Operation put(key:Element,value:Element)
         Kernel_tablePut(self,key,value)
       end;
       
     Table_remove =
       @Operation remove(key:Element)
         Kernel_tableRemove(self,key)
       end
  
  in 
     // The following names are predefined in order to allow forward
     // references to class names when creating collection types.
     
     Kernel_addAtt(Attribute,"name",Kernel_mkSymbol("Attribute"));
     Kernel_addAtt(Classifier,"name",Kernel_mkSymbol("Classifier"));
     Kernel_addAtt(Constraint,"name",Kernel_mkSymbol("Constraint"));
     Kernel_addAtt(Element,"name",Kernel_mkSymbol("Element"));
     Kernel_addAtt(NameSpace,"name",Kernel_mkSymbol("NameSpace"));
     Kernel_addAtt(Op,"name",Kernel_mkSymbol("Operation"));
     Kernel_addAtt(Parameter,"name",Kernel_mkSymbol("Parameter"));
     Kernel_addAtt(SetDataType,"name",Kernel_mkSymbol("Set"));
     Kernel_addAtt(SeqDataType,"name",Kernel_mkSymbol("Seq")); 
     Kernel_addAtt(String,"name",Kernel_mkSymbol("String"));
     
     mkClass(Attribute,
             Set{StructuralFeature},
             false,
             Set{},
             "Attribute",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(BehaviouralFeature,
             Set{TypedElement},
             true,
             Set{mkAtt("parameters",mkSeqType(Parameter),BehaviouralFeature,true),
                 mkAtt("performable",Performable,BehaviouralFeature,true)},
             "BehaviouralFeature",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Bind,
             Set{NamedElement},
             false,
             Set{mkAtt("value",Element,Bind,true)},
             "Bind",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Boolean,Set{Element},"Boolean",Set{},Set{},false,"",XCore);
     
     mkClass(Class,
             Set{Classifier},
             false,
             Set{mkAtt("attributes",mkSetType(Attribute),Class,true),
                 mkAtt("isAbstract",Boolean,Class,false)},
             "Class",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(Classifier,
             Set{NameSpace},
             false,
             Set{mkAtt("parents",mkSetType(Classifier),Classifier,false),
                 mkAtt("operations",mkSetType(Op),Classifier,true),
                 mkAtt("constraints",mkSetType(Constraint),Classifier,true),
                 mkAtt("default",Element,Classifier,false),
                 mkAtt("documentation",String,Classifier,false)},
             "Classifier",
             Set{Classifier_add,
                 Classifier_addOperation,
                 Classifier_default,
                 Classifier_getOperation,
                 Classifier_hasOperation,
                 Classifier_inheritsFrom,
                 Classifier_removeOperation},
             Set{},
             null,
             "",
             XCore,
             null);

     mkClass(CompiledOperation,
             Set{Op},
             false,
             Set{},
             "CompiledOperation",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Constraint,Set{NamedElement},false,Set{},"Constraint",Set{},Set{},null,"",XCore,null);
     
     mkClass(Contained,
             Set{Object},
             true,
             Set{mkAtt("owner",Container,Contained,false)},
             "Contained",
             Set{Contained_setOwner,Contained_removeFromOwner},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Container,
             Set{Object},
             false,
             Set{mkAtt("contents",Table,Container,true)},
             "Container",
             Set{Container_add,Container_remove},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(DataType,
             Set{Classifier},
             true,
             Set{},
             "DataType",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Element,
             Set{},
             true,
             Set{},
             "Element",
             Set{Element_isKindOf,Element_init,Element_of},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Integer,Set{Element},"Integer",Set{Integer_to},Set{},0,"",XCore);
      
     mkClass(NamedElement,
             Set{Contained},
             true,
             Set{mkAtt("name",String,NamedElement,false)},
             "NamedElement",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(NameSpace,
             Set{Container,NamedElement},
             false,
             Set{mkAtt("bindings",mkSetType(Bind),NameSpace,true),
                 mkAtt("imports",mkSetType(NameSpace),NameSpace,false)},
             "NameSpace",
             Set{NameSpace_getElement,NameSpace_hasElement},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Null,Set{Element},"Null",Set{},Set{},null,"",XCore);
             
     mkClass(Object,Set{Element},false,Set{},"Object",Set{},Set{},null,"",XCore,null);
     
     mkClass(Op,
             Set{BehaviouralFeature},
             false,
             Set{mkAtt("documentation",String,Op,true)},
             "Operation",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(Package,
             Set{Classifier,Resource},
             false,
             Set{mkAtt("metaPackage",Package,Package,false)},
             "Package",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Parameter,
             Set{TypedElement},
             false,
             Set{},
             "Parameter",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Performable,
             Set{Object},
             true,
             Set{},
             "Performable",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
      
     mkClass(Resource,
             Set{Object},
             true,
             Set{mkAtt("resourceName",String,Resource,false)},
             "Resource",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     Kernel_setOf(SetType,SetDataType);
     Kernel_addAtt(SetType,"name",Kernel_mkSymbol("Set(Element)"));
     Kernel_addAtt(SetType,"parents",Set{Element});
     Kernel_addAtt(SetType,"elementType",Element);
     Kernel_addAtt(SetType,"operations",Set{
       SetOfElement_collect,
       SetOfElement_excluding,
       SetOfElement_exists,
       SetOfElement_including,
       SetOfElement_reject,
       SetOfElement_sel,
       SetOfElement_select,
       SetOfElement_size});
     Kernel_addAtt(SetType,"constraints",Set{});
     Kernel_addAtt(SetType,"default",Set{});
     Kernel_addAtt(SetType,"documentation","");
     Kernel_addAtt(SetType,"owner",XCore);
     Kernel_addAtt(SetType,"contents",Kernel_mkTable(100));
     Kernel_addAtt(SetType,"bindings",Set{});
     
     mkClass(SetDataType,
             Set{DataType},
             false,
             Set{mkAtt("elementType",Classifier,SetDataType,false)},
             "Set",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(SeqDataType,
             Set{DataType},
             false,
             Set{mkAtt("elementType",Classifier,SetDataType,false)},
             "Seq",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     Kernel_setOf(SeqType,SeqDataType);
     Kernel_addAtt(SeqType,"name",Kernel_mkSymbol("Seq(Element)"));
     Kernel_addAtt(SeqType,"parents",Set{Element});
     Kernel_addAtt(SeqType,"elementType",Element);
     Kernel_addAtt(SeqType,"operations",Set{
       SeqOfElement_collect,
       SeqOfElement_drop,
       SeqOfElement_excluding,
       SeqOfElement_reject,
       SeqOfElement_size});
     Kernel_addAtt(SeqType,"constraints",Set{});
     Kernel_addAtt(SeqType,"default",Seq{});
     Kernel_addAtt(SeqType,"documentation","");
     Kernel_addAtt(SeqType,"owner",XCore);    
     Kernel_addAtt(SeqType,"contents",Kernel_mkTable(100));  
     Kernel_addAtt(SeqType,"bindings",Set{});  
     
     mkDataType(String,Set{Element},"String",Set{},Set{},"","",XCore);
                          
     mkClass(StructuralFeature,
             Set{TypedElement},
             true,
             Set{},
             "StructuralFeature",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Symbol,Set{String},"Symbol",Set{},Set{},"","",XCore);
    
     mkClass(Table,
             Set{Element},
             true,
             Set{},
             "Table",
             Set{
               Table_hasKey,
               Table_get,
               Table_put,
               Table_remove},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(TypedElement,
             Set{NamedElement},
             true,
             Set{mkAtt("type",Classifier,TypedElement,false)},
             "TypedElement",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);

     // Set up the namespaces.

     Kernel_setOf(XCore,Package);
     Kernel_addAtt(XCore,"name",Kernel_mkSymbol("XCore"));
     Kernel_addAtt(XCore,"parents",Set{});
     Kernel_addAtt(XCore,"operations",Set{});
     Kernel_addAtt(XCore,"constraints",Set{});
     Kernel_addAtt(XCore,"default",null);
     Kernel_addAtt(XCore,"owner",Root);
     Kernel_addAtt(XCore,"documentation","");
     Kernel_addAtt(XCore,"resourceName","");
     Kernel_addAtt(XCore,"imports",Set{});
     Kernel_addAtt(XCore,"bindings",Set{});
     Kernel_addAtt(XCore,"contents",
       let table = Kernel_XCore_Table;
           contents = 
            Seq{
             Attribute,
             BehaviouralFeature, 
             Bind,
             Boolean,
             Class,
             Classifier,
             CompiledOperation,
             Constraint,
             Contained,
             Container,
             DataType,
             Element,
             Integer,
             NamedElement,
             NameSpace,
             Null,
             Object, 
             Op,
             Package,
             Parameter,
             Performable,
             Resource,
             SeqDataType,
             SetDataType,
             SeqType,
             SetType,
             String,
             StructuralFeature,
             Symbol,
             Table, 
             TypedElement}
        in @While not contents->isEmpty do
             let c = contents->head
             in Kernel_tablePut(table,c.name,c);
                contents := contents->tail;
                contents->size.println()
             end
           end;
           table
        end);
        
     Kernel_setOf(Root,NameSpace);
     Kernel_addAtt(Root,"name",Kernel_mkSymbol("Root"));
     Kernel_addAtt(Root,"owner",Root);
     Kernel_addAtt(Root,"imports",Set{});
     Kernel_addAtt(Root,"contents",Kernel_Root_Table);
     Kernel_addAtt(Root,"bindings",Set{});
     
     Kernel_tablePut(Root.contents,XCore.name,XCore);
     Kernel_tablePut(Root.contents,Root.name,Root);
             
     Kernel_setTypes(Boolean,Bind,CompiledOperation,Element,Class,Integer,String,SeqType,SetType,Symbol,Table,Null);

     Kernel_tablePut(XCore.contents,Kernel_mkSymbol("SetOfElement"),SetType);
     Kernel_tablePut(XCore.contents,Kernel_mkSymbol("SeqOfElement"),SeqType)
     
  end
end;

parserImport XOCL;

let 
    // Create the Kernel classes.
 
    Attribute             = Kernel_mkObj();
    BehaviouralFeature    = Kernel_mkObj();
    Bind                  = Kernel_mkObj();
    Boolean               = Kernel_mkObj();
    Class                 = Kernel_mkObj();
    Classifier            = Kernel_mkObj();
    CompiledOperation     = Kernel_mkObj();
    Constraint            = Kernel_mkObj();
    Contained             = Kernel_mkObj();
    Container             = Kernel_mkObj();
    DataType              = Kernel_mkObj();
    Element               = Kernel_mkObj();
    Integer               = Kernel_mkObj();
    NamedElement          = Kernel_mkObj();
    NameSpace             = Kernel_mkObj();
    Null                  = Kernel_mkObj();
    Object                = Kernel_mkObj();
    Op                    = Kernel_mkObj();
    Package               = Kernel_mkObj();
    Parameter             = Kernel_mkObj();
    Performable           = Kernel_mkObj();
    Resource              = Kernel_mkObj();
    SeqDataType           = Kernel_mkObj();
    SetDataType           = Kernel_mkObj();
    SeqType               = Kernel_mkObj();
    SetType               = Kernel_mkObj();
    String                = Kernel_mkObj();
    StructuralFeature     = Kernel_mkObj();
    Symbol                = Kernel_mkObj();
    Table                 = Kernel_mkObj();
    TypedElement          = Kernel_mkObj();

    // Packages and namespaces:

    XCore                  = Kernel_mkObj();
    Root                  = Kernel_mkObj();
    
    // Collection type constructor:
    
    mkCollType = @Operation(collType,parents,default)
      @Operation(elementType)
        let type = Kernel_mkObj()
        in Kernel_setOf(type,collType);
           Kernel_addAtt(type,"name",Kernel_mkSymbol(collType.name + "(" + elementType.name + ")"));
           Kernel_addAtt(type,"parents",parents);
           Kernel_addAtt(type,"operations",Set{});
           Kernel_addAtt(type,"elementType",elementType);
           Kernel_addAtt(type,"constraints",Set{});
           Kernel_addAtt(type,"default",default);
           Kernel_addAtt(type,"documentation","");
           Kernel_addAtt(type,"owner",type);
           Kernel_addAtt(type,"contents",Kernel_mkTable(100));
           Kernel_addAtt(type,"bindings",Set{});
           type
         end
      end
    end

  in
    let

      // A standard class creation operation:

      mkClass = @Operation(
                  class,          // The class object to be updated.
                  parents,        // A set of parent classes.
                  isAbstract,     // A boolean determines whether we can have instances.
                  attributes,     // A set of attributes for the class.
                  name,           // A string naming the class.
                  operations,     // A set of operations for instances of the class.
                  constraints,    // A set of constraints that classify instances of the class.
                  default,        // The default value for the class.
                  documentation,  // A documentation string for the class.
                  owner,          // The owner of the class (null, itself or a name space).
                  expander)       // An operation used to expand syntax terms.
         Kernel_setOf(class,Class);
         Kernel_addAtt(class,"parents",parents);
         Kernel_addAtt(class,"isAbstract",isAbstract);
         Kernel_addAtt(class,"attributes",attributes);
         Kernel_addAtt(class,"name",Kernel_mkSymbol(name));
         Kernel_addAtt(class,"operations",operations);
         Kernel_addAtt(class,"constraints",constraints);
         Kernel_addAtt(class,"default",default);
         Kernel_addAtt(class,"documentation",documentation);
         Kernel_addAtt(class,"owner",owner);
         Kernel_addAtt(class,"expander",expander);
         Kernel_addAtt(class,"contents",Kernel_mkTable(100));
         Kernel_addAtt(class,"bindings",Set{});
         class
      end;
      
      mkDataType = @Operation(dataType,parents,name,operations,constraints,default,documentation,owner)
        Kernel_setOf(dataType,DataType);
        Kernel_addAtt(dataType,"parents",parents);
        Kernel_addAtt(dataType,"name",Kernel_mkSymbol(name));
        Kernel_addAtt(dataType,"operations",operations);
        Kernel_addAtt(dataType,"constraints",constraints);
        Kernel_addAtt(dataType,"default",default);
        Kernel_addAtt(dataType,"documentation",documentation);
        Kernel_addAtt(dataType,"owner",owner);
        Kernel_addAtt(dataType,"contents",Kernel_mkTable(100));
        Kernel_addAtt(dataType,"bindings",Set{});
        dataType
      end;
      
      // Collection type constructors:
      
      mkSetType = mkCollType(SetDataType,Set{SetType},Set{});
      mkSeqType = mkCollType(SeqDataType,Set{SeqType},Seq{});

      // A standard attribute creation operation:

      mkAtt = @Operation(name,type,owner,isComposite)
         let att = Kernel_mkObj()
         in Kernel_setOf(att,Attribute);
            Kernel_addAtt(att,"name",Kernel_mkSymbol(name));
            Kernel_addAtt(att,"type",type);
            Kernel_addAtt(att,"owner",owner);
            Kernel_addAtt(att,"isComposite",isComposite);
            att
         end
      end;
      
      // Operations:
      
      Classifier_add =
        @Operation add(namedElement:NamedElement)
          if namedElement.isKindOf(Op)
          then 
            self.addOperation(namedElement); 
            super(namedElement)
          else 
            namedElement.setOwner(self); 
            super(namedElement)
          end
        end;
  
      Classifier_inheritsFrom =
       @Operation inheritsFrom(c:Classifier):Boolean
         if self = c
         then true
         else self.parents->exists(parent | parent.inheritsFrom(c))
         end
        end;
      
      Classifier_addOperation =
        @Operation addOperation(op)
          if self.hasOperation(op.name,op.arity)
          then self.remove(self.getOperation(op.name,op.arity))
          else self
          end;
          self.operations := self.operations.including(op);
          op.setOwner(self);
          resetOperatorTable();
          self
        end;
        
      Classifier_default =
        @Operation default()
          default
        end;
        
      Classifier_getOperation = 
        @Operation getOperation(name,arity)
          self.operations->select(op | op.name = name and op.arity = arity)->sel
        end;
        
      Classifier_hasOperation =
        @Operation hasOperation(name,arity)
          operations->exists(op | op.name = name and op.arity = arity)
        end;
        
      Classifier_removeOperation =
        @Operation removeOperation(op)
          op.owner := null;
          self.operations := operations->excluding(op)
        end;
        
      Contained_setOwner =
        @Operation setOwner(container:Container)
          self.owner := container
        end;
        
      Contained_removeFromOwner =
        @Operation setOwner()
          self.owner := null
        end;
        
      Container_add =
        @Operation add(element:Element):Container
          self.contents.put(element,element)
        end;
        
      Container_remove =
        @Operation remove(element:Element):Container
          self.contents.remove(element)
        end;
          
      Element_isKindOf =
        @Operation isKindOf(c:Classifier):Boolean
          if self = null
          then true
          else self.of().inheritsFrom(c)
          end
        end;
        
      Element_init =
        @Operation init():Element
          self
        end;
 
      Element_of =
        @Operation of():Element
          self.of()
        end;
         
      Integer_to =
        @Operation to(n:Integer):Seq(Integer)
          if self >= n
          then Seq{self}
          else Seq{self | (self + 1).to(n)}
          end
        end;
        
      NameSpace_getElement =
        @Operation getElement(name:String):Contained
          name := if not name.isKindOf(Symbol) then Kernel_mkSymbol(name) else name end;
          if self.hasElement(name)
          then self.contents.get(name)
          else self.error("no element " + self.name + "::" + name + " in " + contents.toString())
          end
        end;

      NameSpace_hasElement =
        @Operation hasElement(name:String):Boolean
          contents.hasKey(if not name.isKindOf(Symbol) then Kernel_mkSymbol(name) else name end)
        end;
        
      SeqOfElement_collect =
        @Operation collect(filter):Seq(Element)
          if self = Seq{}
          then self
          else Seq{filter(self->head) | self->tail.collect(filter)}
          end
        end;

      SeqOfElement_drop =
        @Operation drop(n:Integer):Seq(Element)
          if n = 0 or self = Seq{}
          then self
          else self->tail->drop(n-1)
          end
        end;

      SeqOfElement_excluding =
        @Operation excluding(element)
          if self = Seq{}
          then Seq{}
          else if self->head = element
               then self->tail->excluding(element)
               else Seq{self->head | self->tail->excluding(element)}
               end
          end
        end;
        
      SeqOfElement_reject =
        @Operation reject(pred):Seq(Element)
          if self = Seq{}
          then self
          else if pred(self->head)
               then self->tail->reject(pred)
               else Seq{self->head | self->tail->reject(pred)}
               end
          end
        end;

      SeqOfElement_size =
        @Operation size():Integer
          if self = Seq{}
          then 0
          else self->drop(1)->size + 1
          end
        end;

      SetOfElement_collect =
        @Operation collect(filter):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->collect(filter))
        end;

      SetOfElement_excluding =
        @Operation excluding(element):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->excluding(element))
        end;

      SetOfElement_exists =
        @Operation exists(pred):Boolean
          if self->size = 0
          then false
          else let element = self->sel
               in if pred(element)
                  then true
                  else self->excluding(element)->exists(pred)
                  end
               end
          end
        end;
        
      SetOfElement_including =
        @Operation including(element):Set(Element)
          Kernel_asSet(Seq{element | Kernel_asSeq(self)})
        end;
        
      SetOfElement_reject =
        @Operation reject(pred):Set(Element)
          Kernel_asSet(Kernel_asSeq(self)->reject(pred))
        end;

      SetOfElement_sel =
       @Operation sel():Element
         if self->size = 0
         then self.error("Cannot select an element from an empty set.")
         else Kernel_asSeq(self)->head
         end
       end;
       
      SetOfElement_select =
       @Operation select(predicate):Set(Element)
         if self->size = 0
         then self
         else 
           let element = self->sel
           in if predicate(element)
              then self->excluding(element).select(predicate)->including(element)
              else self->excluding(element).select(predicate)
              end
           end
         end
       end;
       
     SetOfElement_size =
       @Operation size():Integer
         Kernel_asSeq(self)->size
       end;
       
     Table_get =
       @Operation get(key:Element):Element
         Kernel_tableGet(self,key)
       end;
  
     Table_hasKey = 
       @Operation hasKey(key:Element):Boolean
         Kernel_tableHasKey(self,key)
       end;
  
     Table_put =
       @Operation put(key:Element,value:Element)
         Kernel_tablePut(self,key,value)
       end;
       
     Table_remove =
       @Operation remove(key:Element)
         Kernel_tableRemove(self,key)
       end
  
  in 
     // The following names are predefined in order to allow forward
     // references to class names when creating collection types.
     
     Kernel_addAtt(Attribute,"name",Kernel_mkSymbol("Attribute"));
     Kernel_addAtt(Classifier,"name",Kernel_mkSymbol("Classifier"));
     Kernel_addAtt(Constraint,"name",Kernel_mkSymbol("Constraint"));
     Kernel_addAtt(Element,"name",Kernel_mkSymbol("Element"));
     Kernel_addAtt(NameSpace,"name",Kernel_mkSymbol("NameSpace"));
     Kernel_addAtt(Op,"name",Kernel_mkSymbol("Operation"));
     Kernel_addAtt(Parameter,"name",Kernel_mkSymbol("Parameter"));
     Kernel_addAtt(SetDataType,"name",Kernel_mkSymbol("Set"));
     Kernel_addAtt(SeqDataType,"name",Kernel_mkSymbol("Seq")); 
     Kernel_addAtt(String,"name",Kernel_mkSymbol("String"));
     
     mkClass(Attribute,
             Set{StructuralFeature},
             false,
             Set{},
             "Attribute",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(BehaviouralFeature,
             Set{TypedElement},
             true,
             Set{mkAtt("parameters",mkSeqType(Parameter),BehaviouralFeature,true),
                 mkAtt("performable",Performable,BehaviouralFeature,true)},
             "BehaviouralFeature",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Bind,
             Set{NamedElement},
             false,
             Set{mkAtt("value",Element,Bind,true)},
             "Bind",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Boolean,Set{Element},"Boolean",Set{},Set{},false,"",XCore);
     
     mkClass(Class,
             Set{Classifier},
             false,
             Set{mkAtt("attributes",mkSetType(Attribute),Class,true),
                 mkAtt("isAbstract",Boolean,Class,false)},
             "Class",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(Classifier,
             Set{NameSpace},
             false,
             Set{mkAtt("parents",mkSetType(Classifier),Classifier,false),
                 mkAtt("operations",mkSetType(Op),Classifier,true),
                 mkAtt("constraints",mkSetType(Constraint),Classifier,true),
                 mkAtt("default",Element,Classifier,false),
                 mkAtt("documentation",String,Classifier,false)},
             "Classifier",
             Set{Classifier_add,
                 Classifier_addOperation,
                 Classifier_default,
                 Classifier_getOperation,
                 Classifier_hasOperation,
                 Classifier_inheritsFrom,
                 Classifier_removeOperation},
             Set{},
             null,
             "",
             XCore,
             null);

     mkClass(CompiledOperation,
             Set{Op},
             false,
             Set{},
             "CompiledOperation",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Constraint,Set{NamedElement},false,Set{},"Constraint",Set{},Set{},null,"",XCore,null);
     
     mkClass(Contained,
             Set{Object},
             true,
             Set{mkAtt("owner",Container,Contained,false)},
             "Contained",
             Set{Contained_setOwner,Contained_removeFromOwner},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Container,
             Set{Object},
             false,
             Set{mkAtt("contents",Table,Container,true)},
             "Container",
             Set{Container_add,Container_remove},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(DataType,
             Set{Classifier},
             true,
             Set{},
             "DataType",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Element,
             Set{},
             true,
             Set{},
             "Element",
             Set{Element_isKindOf,Element_init,Element_of},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Integer,Set{Element},"Integer",Set{Integer_to},Set{},0,"",XCore);
      
     mkClass(NamedElement,
             Set{Contained},
             true,
             Set{mkAtt("name",String,NamedElement,false)},
             "NamedElement",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(NameSpace,
             Set{Container,NamedElement},
             false,
             Set{mkAtt("bindings",mkSetType(Bind),NameSpace,true),
                 mkAtt("imports",mkSetType(NameSpace),NameSpace,false)},
             "NameSpace",
             Set{NameSpace_getElement,NameSpace_hasElement},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Null,Set{Element},"Null",Set{},Set{},null,"",XCore);
             
     mkClass(Object,Set{Element},false,Set{},"Object",Set{},Set{},null,"",XCore,null);
     
     mkClass(Op,
             Set{BehaviouralFeature},
             false,
             Set{mkAtt("documentation",String,Op,true)},
             "Operation",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
     
     mkClass(Package,
             Set{Classifier,Resource},
             false,
             Set{mkAtt("metaPackage",Package,Package,false)},
             "Package",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Parameter,
             Set{TypedElement},
             false,
             Set{},
             "Parameter",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(Performable,
             Set{Object},
             true,
             Set{},
             "Performable",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
      
     mkClass(Resource,
             Set{Object},
             true,
             Set{mkAtt("resourceName",String,Resource,false)},
             "Resource",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     Kernel_setOf(SetType,SetDataType);
     Kernel_addAtt(SetType,"name",Kernel_mkSymbol("Set(Element)"));
     Kernel_addAtt(SetType,"parents",Set{Element});
     Kernel_addAtt(SetType,"elementType",Element);
     Kernel_addAtt(SetType,"operations",Set{
       SetOfElement_collect,
       SetOfElement_excluding,
       SetOfElement_exists,
       SetOfElement_including,
       SetOfElement_reject,
       SetOfElement_sel,
       SetOfElement_select,
       SetOfElement_size});
     Kernel_addAtt(SetType,"constraints",Set{});
     Kernel_addAtt(SetType,"default",Set{});
     Kernel_addAtt(SetType,"documentation","");
     Kernel_addAtt(SetType,"owner",XCore);
     Kernel_addAtt(SetType,"contents",Kernel_mkTable(100));
     Kernel_addAtt(SetType,"bindings",Set{});
     
     mkClass(SetDataType,
             Set{DataType},
             false,
             Set{mkAtt("elementType",Classifier,SetDataType,false)},
             "Set",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(SeqDataType,
             Set{DataType},
             false,
             Set{mkAtt("elementType",Classifier,SetDataType,false)},
             "Seq",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     Kernel_setOf(SeqType,SeqDataType);
     Kernel_addAtt(SeqType,"name",Kernel_mkSymbol("Seq(Element)"));
     Kernel_addAtt(SeqType,"parents",Set{Element});
     Kernel_addAtt(SeqType,"elementType",Element);
     Kernel_addAtt(SeqType,"operations",Set{
       SeqOfElement_collect,
       SeqOfElement_drop,
       SeqOfElement_excluding,
       SeqOfElement_reject,
       SeqOfElement_size});
     Kernel_addAtt(SeqType,"constraints",Set{});
     Kernel_addAtt(SeqType,"default",Seq{});
     Kernel_addAtt(SeqType,"documentation","");
     Kernel_addAtt(SeqType,"owner",XCore);    
     Kernel_addAtt(SeqType,"contents",Kernel_mkTable(100));  
     Kernel_addAtt(SeqType,"bindings",Set{});  
     
     mkDataType(String,Set{Element},"String",Set{},Set{},"","",XCore);
                          
     mkClass(StructuralFeature,
             Set{TypedElement},
             true,
             Set{},
             "StructuralFeature",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkDataType(Symbol,Set{String},"Symbol",Set{},Set{},"","",XCore);
    
     mkClass(Table,
             Set{Element},
             true,
             Set{},
             "Table",
             Set{
               Table_hasKey,
               Table_get,
               Table_put,
               Table_remove},
             Set{},
             null,
             "",
             XCore,
             null);
             
     mkClass(TypedElement,
             Set{NamedElement},
             true,
             Set{mkAtt("type",Classifier,TypedElement,false)},
             "TypedElement",
             Set{},
             Set{},
             null,
             "",
             XCore,
             null);

     // Set up the namespaces.

     Kernel_setOf(XCore,Package);
     Kernel_addAtt(XCore,"name",Kernel_mkSymbol("XCore"));
     Kernel_addAtt(XCore,"parents",Set{});
     Kernel_addAtt(XCore,"operations",Set{});
     Kernel_addAtt(XCore,"constraints",Set{});
     Kernel_addAtt(XCore,"default",null);
     Kernel_addAtt(XCore,"owner",Root);
     Kernel_addAtt(XCore,"documentation","");
     Kernel_addAtt(XCore,"resourceName","");
     Kernel_addAtt(XCore,"imports",Set{});
     Kernel_addAtt(XCore,"bindings",Set{});
     Kernel_addAtt(XCore,"contents",
       let table = Kernel_XCore_Table;
           contents = 
            Seq{
             Attribute,
             BehaviouralFeature, 
             Bind,
             Boolean,
             Class,
             Classifier,
             CompiledOperation,
             Constraint,
             Contained,
             Container,
             DataType,
             Element,
             Integer,
             NamedElement,
             NameSpace,
             Null,
             Object, 
             Op,
             Package,
             Parameter,
             Performable,
             Resource,
             SeqDataType,
             SetDataType,
             SeqType,
             SetType,
             String,
             StructuralFeature,
             Symbol,
             Table, 
             TypedElement}
        in @While not contents->isEmpty do
             let c = contents->head
             in Kernel_tablePut(table,c.name,c);
                contents := contents->tail;
                contents->size.println()
             end
           end;
           table
        end);
        
     Kernel_setOf(Root,NameSpace);
     Kernel_addAtt(Root,"name",Kernel_mkSymbol("Root"));
     Kernel_addAtt(Root,"owner",Root);
     Kernel_addAtt(Root,"imports",Set{});
     Kernel_addAtt(Root,"contents",Kernel_Root_Table);
     Kernel_addAtt(Root,"bindings",Set{});
     
     Kernel_tablePut(Root.contents,XCore.name,XCore);
     Kernel_tablePut(Root.contents,Root.name,Root);
             
     Kernel_setTypes(Boolean,Bind,CompiledOperation,Element,Class,Integer,String,SeqType,SetType,Symbol,Table,Null);

     Kernel_tablePut(XCore.contents,Kernel_mkSymbol("SetOfElement"),SetType);
     Kernel_tablePut(XCore.contents,Kernel_mkSymbol("SeqOfElement"),SeqType)
     
  end
end;